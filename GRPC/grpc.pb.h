// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: grpc.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_grpc_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_grpc_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/any.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_grpc_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_grpc_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[12]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_grpc_2eproto;
class AccessLogInfo;
struct AccessLogInfoDefaultTypeInternal;
extern AccessLogInfoDefaultTypeInternal _AccessLogInfo_default_instance_;
class CommonRequest;
struct CommonRequestDefaultTypeInternal;
extern CommonRequestDefaultTypeInternal _CommonRequest_default_instance_;
class CommonResponse;
struct CommonResponseDefaultTypeInternal;
extern CommonResponseDefaultTypeInternal _CommonResponse_default_instance_;
class DBInfo;
struct DBInfoDefaultTypeInternal;
extern DBInfoDefaultTypeInternal _DBInfo_default_instance_;
class FunInfo;
struct FunInfoDefaultTypeInternal;
extern FunInfoDefaultTypeInternal _FunInfo_default_instance_;
class IPManageInfo;
struct IPManageInfoDefaultTypeInternal;
extern IPManageInfoDefaultTypeInternal _IPManageInfo_default_instance_;
class Monitor;
struct MonitorDefaultTypeInternal;
extern MonitorDefaultTypeInternal _Monitor_default_instance_;
class QueryHeadInfo;
struct QueryHeadInfoDefaultTypeInternal;
extern QueryHeadInfoDefaultTypeInternal _QueryHeadInfo_default_instance_;
class QueryLogInfo;
struct QueryLogInfoDefaultTypeInternal;
extern QueryLogInfoDefaultTypeInternal _QueryLogInfo_default_instance_;
class QueryResultInfo;
struct QueryResultInfoDefaultTypeInternal;
extern QueryResultInfoDefaultTypeInternal _QueryResultInfo_default_instance_;
class TxnLogInfo;
struct TxnLogInfoDefaultTypeInternal;
extern TxnLogInfoDefaultTypeInternal _TxnLogInfo_default_instance_;
class UserInfo;
struct UserInfoDefaultTypeInternal;
extern UserInfoDefaultTypeInternal _UserInfo_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::AccessLogInfo* Arena::CreateMaybeMessage<::AccessLogInfo>(Arena*);
template<> ::CommonRequest* Arena::CreateMaybeMessage<::CommonRequest>(Arena*);
template<> ::CommonResponse* Arena::CreateMaybeMessage<::CommonResponse>(Arena*);
template<> ::DBInfo* Arena::CreateMaybeMessage<::DBInfo>(Arena*);
template<> ::FunInfo* Arena::CreateMaybeMessage<::FunInfo>(Arena*);
template<> ::IPManageInfo* Arena::CreateMaybeMessage<::IPManageInfo>(Arena*);
template<> ::Monitor* Arena::CreateMaybeMessage<::Monitor>(Arena*);
template<> ::QueryHeadInfo* Arena::CreateMaybeMessage<::QueryHeadInfo>(Arena*);
template<> ::QueryLogInfo* Arena::CreateMaybeMessage<::QueryLogInfo>(Arena*);
template<> ::QueryResultInfo* Arena::CreateMaybeMessage<::QueryResultInfo>(Arena*);
template<> ::TxnLogInfo* Arena::CreateMaybeMessage<::TxnLogInfo>(Arena*);
template<> ::UserInfo* Arena::CreateMaybeMessage<::UserInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class CommonRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CommonRequest) */ {
 public:
  inline CommonRequest() : CommonRequest(nullptr) {}
  ~CommonRequest() override;
  explicit constexpr CommonRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommonRequest(const CommonRequest& from);
  CommonRequest(CommonRequest&& from) noexcept
    : CommonRequest() {
    *this = ::std::move(from);
  }

  inline CommonRequest& operator=(const CommonRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommonRequest& operator=(CommonRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommonRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommonRequest* internal_default_instance() {
    return reinterpret_cast<const CommonRequest*>(
               &_CommonRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CommonRequest& a, CommonRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CommonRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommonRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommonRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommonRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CommonRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CommonRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommonRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CommonRequest";
  }
  protected:
  explicit CommonRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kPasswordFieldNumber = 2,
    kOperationFieldNumber = 3,
    kEncryptionFieldNumber = 4,
    kDbNameFieldNumber = 5,
    kDbPathFieldNumber = 6,
    kLoadCsrFieldNumber = 7,
    kIsBackupFieldNumber = 8,
    kTypeFieldNumber = 9,
    kOpUsernameFieldNumber = 10,
    kOpPasswordFieldNumber = 11,
    kPrivilegesFieldNumber = 12,
    kBackupPathFieldNumber = 13,
    kSparqlFieldNumber = 14,
    kFormatFieldNumber = 15,
    kIsolevelFieldNumber = 16,
    kTidFieldNumber = 17,
    kFileFieldNumber = 18,
    kDateFieldNumber = 19,
    kIpTypeFieldNumber = 22,
    kIpsFieldNumber = 23,
    kFunInfoFieldNumber = 24,
    kPageNoFieldNumber = 20,
    kPageSizeFieldNumber = 21,
  };
  // required string username = 1;
  bool has_username() const;
  private:
  bool _internal_has_username() const;
  public:
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // required string password = 2;
  bool has_password() const;
  private:
  bool _internal_has_password() const;
  public:
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // optional string operation = 3;
  bool has_operation() const;
  private:
  bool _internal_has_operation() const;
  public:
  void clear_operation();
  const std::string& operation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_operation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_operation();
  PROTOBUF_NODISCARD std::string* release_operation();
  void set_allocated_operation(std::string* operation);
  private:
  const std::string& _internal_operation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operation(const std::string& value);
  std::string* _internal_mutable_operation();
  public:

  // optional string encryption = 4;
  bool has_encryption() const;
  private:
  bool _internal_has_encryption() const;
  public:
  void clear_encryption();
  const std::string& encryption() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_encryption(ArgT0&& arg0, ArgT... args);
  std::string* mutable_encryption();
  PROTOBUF_NODISCARD std::string* release_encryption();
  void set_allocated_encryption(std::string* encryption);
  private:
  const std::string& _internal_encryption() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_encryption(const std::string& value);
  std::string* _internal_mutable_encryption();
  public:

  // optional string db_name = 5;
  bool has_db_name() const;
  private:
  bool _internal_has_db_name() const;
  public:
  void clear_db_name();
  const std::string& db_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_db_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_db_name();
  PROTOBUF_NODISCARD std::string* release_db_name();
  void set_allocated_db_name(std::string* db_name);
  private:
  const std::string& _internal_db_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_db_name(const std::string& value);
  std::string* _internal_mutable_db_name();
  public:

  // optional string db_path = 6;
  bool has_db_path() const;
  private:
  bool _internal_has_db_path() const;
  public:
  void clear_db_path();
  const std::string& db_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_db_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_db_path();
  PROTOBUF_NODISCARD std::string* release_db_path();
  void set_allocated_db_path(std::string* db_path);
  private:
  const std::string& _internal_db_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_db_path(const std::string& value);
  std::string* _internal_mutable_db_path();
  public:

  // optional string load_csr = 7;
  bool has_load_csr() const;
  private:
  bool _internal_has_load_csr() const;
  public:
  void clear_load_csr();
  const std::string& load_csr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_load_csr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_load_csr();
  PROTOBUF_NODISCARD std::string* release_load_csr();
  void set_allocated_load_csr(std::string* load_csr);
  private:
  const std::string& _internal_load_csr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_load_csr(const std::string& value);
  std::string* _internal_mutable_load_csr();
  public:

  // optional string is_backup = 8;
  bool has_is_backup() const;
  private:
  bool _internal_has_is_backup() const;
  public:
  void clear_is_backup();
  const std::string& is_backup() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_is_backup(ArgT0&& arg0, ArgT... args);
  std::string* mutable_is_backup();
  PROTOBUF_NODISCARD std::string* release_is_backup();
  void set_allocated_is_backup(std::string* is_backup);
  private:
  const std::string& _internal_is_backup() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_is_backup(const std::string& value);
  std::string* _internal_mutable_is_backup();
  public:

  // optional string type = 9;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // optional string op_username = 10;
  bool has_op_username() const;
  private:
  bool _internal_has_op_username() const;
  public:
  void clear_op_username();
  const std::string& op_username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_op_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_op_username();
  PROTOBUF_NODISCARD std::string* release_op_username();
  void set_allocated_op_username(std::string* op_username);
  private:
  const std::string& _internal_op_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_op_username(const std::string& value);
  std::string* _internal_mutable_op_username();
  public:

  // optional string op_password = 11;
  bool has_op_password() const;
  private:
  bool _internal_has_op_password() const;
  public:
  void clear_op_password();
  const std::string& op_password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_op_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_op_password();
  PROTOBUF_NODISCARD std::string* release_op_password();
  void set_allocated_op_password(std::string* op_password);
  private:
  const std::string& _internal_op_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_op_password(const std::string& value);
  std::string* _internal_mutable_op_password();
  public:

  // optional string privileges = 12;
  bool has_privileges() const;
  private:
  bool _internal_has_privileges() const;
  public:
  void clear_privileges();
  const std::string& privileges() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_privileges(ArgT0&& arg0, ArgT... args);
  std::string* mutable_privileges();
  PROTOBUF_NODISCARD std::string* release_privileges();
  void set_allocated_privileges(std::string* privileges);
  private:
  const std::string& _internal_privileges() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_privileges(const std::string& value);
  std::string* _internal_mutable_privileges();
  public:

  // optional string backup_path = 13;
  bool has_backup_path() const;
  private:
  bool _internal_has_backup_path() const;
  public:
  void clear_backup_path();
  const std::string& backup_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_backup_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_backup_path();
  PROTOBUF_NODISCARD std::string* release_backup_path();
  void set_allocated_backup_path(std::string* backup_path);
  private:
  const std::string& _internal_backup_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_backup_path(const std::string& value);
  std::string* _internal_mutable_backup_path();
  public:

  // optional string sparql = 14;
  bool has_sparql() const;
  private:
  bool _internal_has_sparql() const;
  public:
  void clear_sparql();
  const std::string& sparql() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sparql(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sparql();
  PROTOBUF_NODISCARD std::string* release_sparql();
  void set_allocated_sparql(std::string* sparql);
  private:
  const std::string& _internal_sparql() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sparql(const std::string& value);
  std::string* _internal_mutable_sparql();
  public:

  // optional string format = 15;
  bool has_format() const;
  private:
  bool _internal_has_format() const;
  public:
  void clear_format();
  const std::string& format() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_format(ArgT0&& arg0, ArgT... args);
  std::string* mutable_format();
  PROTOBUF_NODISCARD std::string* release_format();
  void set_allocated_format(std::string* format);
  private:
  const std::string& _internal_format() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_format(const std::string& value);
  std::string* _internal_mutable_format();
  public:

  // optional string isolevel = 16;
  bool has_isolevel() const;
  private:
  bool _internal_has_isolevel() const;
  public:
  void clear_isolevel();
  const std::string& isolevel() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_isolevel(ArgT0&& arg0, ArgT... args);
  std::string* mutable_isolevel();
  PROTOBUF_NODISCARD std::string* release_isolevel();
  void set_allocated_isolevel(std::string* isolevel);
  private:
  const std::string& _internal_isolevel() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_isolevel(const std::string& value);
  std::string* _internal_mutable_isolevel();
  public:

  // optional string tid = 17;
  bool has_tid() const;
  private:
  bool _internal_has_tid() const;
  public:
  void clear_tid();
  const std::string& tid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tid();
  PROTOBUF_NODISCARD std::string* release_tid();
  void set_allocated_tid(std::string* tid);
  private:
  const std::string& _internal_tid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tid(const std::string& value);
  std::string* _internal_mutable_tid();
  public:

  // optional string file = 18;
  bool has_file() const;
  private:
  bool _internal_has_file() const;
  public:
  void clear_file();
  const std::string& file() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file();
  PROTOBUF_NODISCARD std::string* release_file();
  void set_allocated_file(std::string* file);
  private:
  const std::string& _internal_file() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file(const std::string& value);
  std::string* _internal_mutable_file();
  public:

  // optional string date = 19;
  bool has_date() const;
  private:
  bool _internal_has_date() const;
  public:
  void clear_date();
  const std::string& date() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_date(ArgT0&& arg0, ArgT... args);
  std::string* mutable_date();
  PROTOBUF_NODISCARD std::string* release_date();
  void set_allocated_date(std::string* date);
  private:
  const std::string& _internal_date() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_date(const std::string& value);
  std::string* _internal_mutable_date();
  public:

  // optional string ip_type = 22;
  bool has_ip_type() const;
  private:
  bool _internal_has_ip_type() const;
  public:
  void clear_ip_type();
  const std::string& ip_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip_type();
  PROTOBUF_NODISCARD std::string* release_ip_type();
  void set_allocated_ip_type(std::string* ip_type);
  private:
  const std::string& _internal_ip_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip_type(const std::string& value);
  std::string* _internal_mutable_ip_type();
  public:

  // optional string ips = 23;
  bool has_ips() const;
  private:
  bool _internal_has_ips() const;
  public:
  void clear_ips();
  const std::string& ips() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ips(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ips();
  PROTOBUF_NODISCARD std::string* release_ips();
  void set_allocated_ips(std::string* ips);
  private:
  const std::string& _internal_ips() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ips(const std::string& value);
  std::string* _internal_mutable_ips();
  public:

  // optional .FunInfo fun_info = 24;
  bool has_fun_info() const;
  private:
  bool _internal_has_fun_info() const;
  public:
  void clear_fun_info();
  const ::FunInfo& fun_info() const;
  PROTOBUF_NODISCARD ::FunInfo* release_fun_info();
  ::FunInfo* mutable_fun_info();
  void set_allocated_fun_info(::FunInfo* fun_info);
  private:
  const ::FunInfo& _internal_fun_info() const;
  ::FunInfo* _internal_mutable_fun_info();
  public:
  void unsafe_arena_set_allocated_fun_info(
      ::FunInfo* fun_info);
  ::FunInfo* unsafe_arena_release_fun_info();

  // optional int32 pageNo = 20;
  bool has_pageno() const;
  private:
  bool _internal_has_pageno() const;
  public:
  void clear_pageno();
  int32_t pageno() const;
  void set_pageno(int32_t value);
  private:
  int32_t _internal_pageno() const;
  void _internal_set_pageno(int32_t value);
  public:

  // optional int32 pageSize = 21;
  bool has_pagesize() const;
  private:
  bool _internal_has_pagesize() const;
  public:
  void clear_pagesize();
  int32_t pagesize() const;
  void set_pagesize(int32_t value);
  private:
  int32_t _internal_pagesize() const;
  void _internal_set_pagesize(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CommonRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr operation_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encryption_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr db_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr db_path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr load_csr_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr is_backup_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr op_username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr op_password_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr privileges_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr backup_path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sparql_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr format_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr isolevel_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr date_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ips_;
  ::FunInfo* fun_info_;
  int32_t pageno_;
  int32_t pagesize_;
  friend struct ::TableStruct_grpc_2eproto;
};
// -------------------------------------------------------------------

class Monitor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Monitor) */ {
 public:
  inline Monitor() : Monitor(nullptr) {}
  ~Monitor() override;
  explicit constexpr Monitor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Monitor(const Monitor& from);
  Monitor(Monitor&& from) noexcept
    : Monitor() {
    *this = ::std::move(from);
  }

  inline Monitor& operator=(const Monitor& from) {
    CopyFrom(from);
    return *this;
  }
  inline Monitor& operator=(Monitor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Monitor& default_instance() {
    return *internal_default_instance();
  }
  static inline const Monitor* internal_default_instance() {
    return reinterpret_cast<const Monitor*>(
               &_Monitor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Monitor& a, Monitor& b) {
    a.Swap(&b);
  }
  inline void Swap(Monitor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Monitor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Monitor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Monitor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Monitor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Monitor& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Monitor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Monitor";
  }
  protected:
  explicit Monitor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDatabaseFieldNumber = 1,
    kCreatorFieldNumber = 2,
    kBuiltTimeFieldNumber = 3,
    kTripleNumFieldNumber = 4,
    kEntityNumFieldNumber = 5,
    kLiteralNumFieldNumber = 6,
    kSubjectNumFieldNumber = 7,
    kPredicateNumFieldNumber = 8,
    kConnectionNumFieldNumber = 9,
  };
  // optional string database = 1;
  bool has_database() const;
  private:
  bool _internal_has_database() const;
  public:
  void clear_database();
  const std::string& database() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_database(ArgT0&& arg0, ArgT... args);
  std::string* mutable_database();
  PROTOBUF_NODISCARD std::string* release_database();
  void set_allocated_database(std::string* database);
  private:
  const std::string& _internal_database() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_database(const std::string& value);
  std::string* _internal_mutable_database();
  public:

  // optional string creator = 2;
  bool has_creator() const;
  private:
  bool _internal_has_creator() const;
  public:
  void clear_creator();
  const std::string& creator() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_creator(ArgT0&& arg0, ArgT... args);
  std::string* mutable_creator();
  PROTOBUF_NODISCARD std::string* release_creator();
  void set_allocated_creator(std::string* creator);
  private:
  const std::string& _internal_creator() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_creator(const std::string& value);
  std::string* _internal_mutable_creator();
  public:

  // optional string built_time = 3;
  bool has_built_time() const;
  private:
  bool _internal_has_built_time() const;
  public:
  void clear_built_time();
  const std::string& built_time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_built_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_built_time();
  PROTOBUF_NODISCARD std::string* release_built_time();
  void set_allocated_built_time(std::string* built_time);
  private:
  const std::string& _internal_built_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_built_time(const std::string& value);
  std::string* _internal_mutable_built_time();
  public:

  // optional string triple_num = 4;
  bool has_triple_num() const;
  private:
  bool _internal_has_triple_num() const;
  public:
  void clear_triple_num();
  const std::string& triple_num() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_triple_num(ArgT0&& arg0, ArgT... args);
  std::string* mutable_triple_num();
  PROTOBUF_NODISCARD std::string* release_triple_num();
  void set_allocated_triple_num(std::string* triple_num);
  private:
  const std::string& _internal_triple_num() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_triple_num(const std::string& value);
  std::string* _internal_mutable_triple_num();
  public:

  // optional int32 entity_num = 5;
  bool has_entity_num() const;
  private:
  bool _internal_has_entity_num() const;
  public:
  void clear_entity_num();
  int32_t entity_num() const;
  void set_entity_num(int32_t value);
  private:
  int32_t _internal_entity_num() const;
  void _internal_set_entity_num(int32_t value);
  public:

  // optional int32 literal_num = 6;
  bool has_literal_num() const;
  private:
  bool _internal_has_literal_num() const;
  public:
  void clear_literal_num();
  int32_t literal_num() const;
  void set_literal_num(int32_t value);
  private:
  int32_t _internal_literal_num() const;
  void _internal_set_literal_num(int32_t value);
  public:

  // optional int32 subject_num = 7;
  bool has_subject_num() const;
  private:
  bool _internal_has_subject_num() const;
  public:
  void clear_subject_num();
  int32_t subject_num() const;
  void set_subject_num(int32_t value);
  private:
  int32_t _internal_subject_num() const;
  void _internal_set_subject_num(int32_t value);
  public:

  // optional int32 predicate_num = 8;
  bool has_predicate_num() const;
  private:
  bool _internal_has_predicate_num() const;
  public:
  void clear_predicate_num();
  int32_t predicate_num() const;
  void set_predicate_num(int32_t value);
  private:
  int32_t _internal_predicate_num() const;
  void _internal_set_predicate_num(int32_t value);
  public:

  // optional int32 connection_num = 9;
  bool has_connection_num() const;
  private:
  bool _internal_has_connection_num() const;
  public:
  void clear_connection_num();
  int32_t connection_num() const;
  void set_connection_num(int32_t value);
  private:
  int32_t _internal_connection_num() const;
  void _internal_set_connection_num(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Monitor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr database_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr creator_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr built_time_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr triple_num_;
  int32_t entity_num_;
  int32_t literal_num_;
  int32_t subject_num_;
  int32_t predicate_num_;
  int32_t connection_num_;
  friend struct ::TableStruct_grpc_2eproto;
};
// -------------------------------------------------------------------

class UserInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UserInfo) */ {
 public:
  inline UserInfo() : UserInfo(nullptr) {}
  ~UserInfo() override;
  explicit constexpr UserInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserInfo(const UserInfo& from);
  UserInfo(UserInfo&& from) noexcept
    : UserInfo() {
    *this = ::std::move(from);
  }

  inline UserInfo& operator=(const UserInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserInfo& operator=(UserInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserInfo* internal_default_instance() {
    return reinterpret_cast<const UserInfo*>(
               &_UserInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(UserInfo& a, UserInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(UserInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UserInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UserInfo";
  }
  protected:
  explicit UserInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kPasswordFieldNumber = 2,
    kQueryPrivilegeFieldNumber = 3,
    kUpdatePrivilegeFieldNumber = 4,
    kLoadPrivilegeFieldNumber = 5,
    kUnloadPrivilegeFieldNumber = 6,
    kBackupPrivilegeFieldNumber = 7,
    kRestorePrivilegeFieldNumber = 8,
    kExportPrivilegeFieldNumber = 9,
  };
  // optional string username = 1;
  bool has_username() const;
  private:
  bool _internal_has_username() const;
  public:
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // optional string password = 2;
  bool has_password() const;
  private:
  bool _internal_has_password() const;
  public:
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // optional string query_privilege = 3;
  bool has_query_privilege() const;
  private:
  bool _internal_has_query_privilege() const;
  public:
  void clear_query_privilege();
  const std::string& query_privilege() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_query_privilege(ArgT0&& arg0, ArgT... args);
  std::string* mutable_query_privilege();
  PROTOBUF_NODISCARD std::string* release_query_privilege();
  void set_allocated_query_privilege(std::string* query_privilege);
  private:
  const std::string& _internal_query_privilege() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_query_privilege(const std::string& value);
  std::string* _internal_mutable_query_privilege();
  public:

  // optional string update_privilege = 4;
  bool has_update_privilege() const;
  private:
  bool _internal_has_update_privilege() const;
  public:
  void clear_update_privilege();
  const std::string& update_privilege() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_update_privilege(ArgT0&& arg0, ArgT... args);
  std::string* mutable_update_privilege();
  PROTOBUF_NODISCARD std::string* release_update_privilege();
  void set_allocated_update_privilege(std::string* update_privilege);
  private:
  const std::string& _internal_update_privilege() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_update_privilege(const std::string& value);
  std::string* _internal_mutable_update_privilege();
  public:

  // optional string load_privilege = 5;
  bool has_load_privilege() const;
  private:
  bool _internal_has_load_privilege() const;
  public:
  void clear_load_privilege();
  const std::string& load_privilege() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_load_privilege(ArgT0&& arg0, ArgT... args);
  std::string* mutable_load_privilege();
  PROTOBUF_NODISCARD std::string* release_load_privilege();
  void set_allocated_load_privilege(std::string* load_privilege);
  private:
  const std::string& _internal_load_privilege() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_load_privilege(const std::string& value);
  std::string* _internal_mutable_load_privilege();
  public:

  // optional string unload_privilege = 6;
  bool has_unload_privilege() const;
  private:
  bool _internal_has_unload_privilege() const;
  public:
  void clear_unload_privilege();
  const std::string& unload_privilege() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_unload_privilege(ArgT0&& arg0, ArgT... args);
  std::string* mutable_unload_privilege();
  PROTOBUF_NODISCARD std::string* release_unload_privilege();
  void set_allocated_unload_privilege(std::string* unload_privilege);
  private:
  const std::string& _internal_unload_privilege() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_unload_privilege(const std::string& value);
  std::string* _internal_mutable_unload_privilege();
  public:

  // optional string backup_privilege = 7;
  bool has_backup_privilege() const;
  private:
  bool _internal_has_backup_privilege() const;
  public:
  void clear_backup_privilege();
  const std::string& backup_privilege() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_backup_privilege(ArgT0&& arg0, ArgT... args);
  std::string* mutable_backup_privilege();
  PROTOBUF_NODISCARD std::string* release_backup_privilege();
  void set_allocated_backup_privilege(std::string* backup_privilege);
  private:
  const std::string& _internal_backup_privilege() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_backup_privilege(const std::string& value);
  std::string* _internal_mutable_backup_privilege();
  public:

  // optional string restore_privilege = 8;
  bool has_restore_privilege() const;
  private:
  bool _internal_has_restore_privilege() const;
  public:
  void clear_restore_privilege();
  const std::string& restore_privilege() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_restore_privilege(ArgT0&& arg0, ArgT... args);
  std::string* mutable_restore_privilege();
  PROTOBUF_NODISCARD std::string* release_restore_privilege();
  void set_allocated_restore_privilege(std::string* restore_privilege);
  private:
  const std::string& _internal_restore_privilege() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_restore_privilege(const std::string& value);
  std::string* _internal_mutable_restore_privilege();
  public:

  // optional string export_privilege = 9;
  bool has_export_privilege() const;
  private:
  bool _internal_has_export_privilege() const;
  public:
  void clear_export_privilege();
  const std::string& export_privilege() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_export_privilege(ArgT0&& arg0, ArgT... args);
  std::string* mutable_export_privilege();
  PROTOBUF_NODISCARD std::string* release_export_privilege();
  void set_allocated_export_privilege(std::string* export_privilege);
  private:
  const std::string& _internal_export_privilege() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_export_privilege(const std::string& value);
  std::string* _internal_mutable_export_privilege();
  public:

  // @@protoc_insertion_point(class_scope:UserInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr query_privilege_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr update_privilege_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr load_privilege_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr unload_privilege_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr backup_privilege_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr restore_privilege_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr export_privilege_;
  friend struct ::TableStruct_grpc_2eproto;
};
// -------------------------------------------------------------------

class DBInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DBInfo) */ {
 public:
  inline DBInfo() : DBInfo(nullptr) {}
  ~DBInfo() override;
  explicit constexpr DBInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DBInfo(const DBInfo& from);
  DBInfo(DBInfo&& from) noexcept
    : DBInfo() {
    *this = ::std::move(from);
  }

  inline DBInfo& operator=(const DBInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DBInfo& operator=(DBInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DBInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const DBInfo* internal_default_instance() {
    return reinterpret_cast<const DBInfo*>(
               &_DBInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(DBInfo& a, DBInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(DBInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DBInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DBInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DBInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DBInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DBInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DBInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DBInfo";
  }
  protected:
  explicit DBInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDatabaseFieldNumber = 1,
    kCreatorFieldNumber = 2,
    kBuiltTimeFieldNumber = 3,
    kStatusFieldNumber = 4,
  };
  // optional string database = 1;
  bool has_database() const;
  private:
  bool _internal_has_database() const;
  public:
  void clear_database();
  const std::string& database() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_database(ArgT0&& arg0, ArgT... args);
  std::string* mutable_database();
  PROTOBUF_NODISCARD std::string* release_database();
  void set_allocated_database(std::string* database);
  private:
  const std::string& _internal_database() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_database(const std::string& value);
  std::string* _internal_mutable_database();
  public:

  // optional string creator = 2;
  bool has_creator() const;
  private:
  bool _internal_has_creator() const;
  public:
  void clear_creator();
  const std::string& creator() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_creator(ArgT0&& arg0, ArgT... args);
  std::string* mutable_creator();
  PROTOBUF_NODISCARD std::string* release_creator();
  void set_allocated_creator(std::string* creator);
  private:
  const std::string& _internal_creator() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_creator(const std::string& value);
  std::string* _internal_mutable_creator();
  public:

  // optional string built_time = 3;
  bool has_built_time() const;
  private:
  bool _internal_has_built_time() const;
  public:
  void clear_built_time();
  const std::string& built_time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_built_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_built_time();
  PROTOBUF_NODISCARD std::string* release_built_time();
  void set_allocated_built_time(std::string* built_time);
  private:
  const std::string& _internal_built_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_built_time(const std::string& value);
  std::string* _internal_mutable_built_time();
  public:

  // optional string status = 4;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // @@protoc_insertion_point(class_scope:DBInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr database_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr creator_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr built_time_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  friend struct ::TableStruct_grpc_2eproto;
};
// -------------------------------------------------------------------

class QueryHeadInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:QueryHeadInfo) */ {
 public:
  inline QueryHeadInfo() : QueryHeadInfo(nullptr) {}
  ~QueryHeadInfo() override;
  explicit constexpr QueryHeadInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryHeadInfo(const QueryHeadInfo& from);
  QueryHeadInfo(QueryHeadInfo&& from) noexcept
    : QueryHeadInfo() {
    *this = ::std::move(from);
  }

  inline QueryHeadInfo& operator=(const QueryHeadInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryHeadInfo& operator=(QueryHeadInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryHeadInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryHeadInfo* internal_default_instance() {
    return reinterpret_cast<const QueryHeadInfo*>(
               &_QueryHeadInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(QueryHeadInfo& a, QueryHeadInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryHeadInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryHeadInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryHeadInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryHeadInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryHeadInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const QueryHeadInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryHeadInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "QueryHeadInfo";
  }
  protected:
  explicit QueryHeadInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLinkFieldNumber = 1,
    kVarsFieldNumber = 2,
  };
  // repeated string link = 1;
  int link_size() const;
  private:
  int _internal_link_size() const;
  public:
  void clear_link();
  const std::string& link(int index) const;
  std::string* mutable_link(int index);
  void set_link(int index, const std::string& value);
  void set_link(int index, std::string&& value);
  void set_link(int index, const char* value);
  void set_link(int index, const char* value, size_t size);
  std::string* add_link();
  void add_link(const std::string& value);
  void add_link(std::string&& value);
  void add_link(const char* value);
  void add_link(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& link() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_link();
  private:
  const std::string& _internal_link(int index) const;
  std::string* _internal_add_link();
  public:

  // repeated string vars = 2;
  int vars_size() const;
  private:
  int _internal_vars_size() const;
  public:
  void clear_vars();
  const std::string& vars(int index) const;
  std::string* mutable_vars(int index);
  void set_vars(int index, const std::string& value);
  void set_vars(int index, std::string&& value);
  void set_vars(int index, const char* value);
  void set_vars(int index, const char* value, size_t size);
  std::string* add_vars();
  void add_vars(const std::string& value);
  void add_vars(std::string&& value);
  void add_vars(const char* value);
  void add_vars(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& vars() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_vars();
  private:
  const std::string& _internal_vars(int index) const;
  std::string* _internal_add_vars();
  public:

  // @@protoc_insertion_point(class_scope:QueryHeadInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> link_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> vars_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_grpc_2eproto;
};
// -------------------------------------------------------------------

class QueryResultInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:QueryResultInfo) */ {
 public:
  inline QueryResultInfo() : QueryResultInfo(nullptr) {}
  ~QueryResultInfo() override;
  explicit constexpr QueryResultInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryResultInfo(const QueryResultInfo& from);
  QueryResultInfo(QueryResultInfo&& from) noexcept
    : QueryResultInfo() {
    *this = ::std::move(from);
  }

  inline QueryResultInfo& operator=(const QueryResultInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryResultInfo& operator=(QueryResultInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryResultInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryResultInfo* internal_default_instance() {
    return reinterpret_cast<const QueryResultInfo*>(
               &_QueryResultInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(QueryResultInfo& a, QueryResultInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryResultInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryResultInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryResultInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryResultInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryResultInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const QueryResultInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryResultInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "QueryResultInfo";
  }
  protected:
  explicit QueryResultInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBindingsFieldNumber = 1,
  };
  // repeated string bindings = 1;
  int bindings_size() const;
  private:
  int _internal_bindings_size() const;
  public:
  void clear_bindings();
  const std::string& bindings(int index) const;
  std::string* mutable_bindings(int index);
  void set_bindings(int index, const std::string& value);
  void set_bindings(int index, std::string&& value);
  void set_bindings(int index, const char* value);
  void set_bindings(int index, const char* value, size_t size);
  std::string* add_bindings();
  void add_bindings(const std::string& value);
  void add_bindings(std::string&& value);
  void add_bindings(const char* value);
  void add_bindings(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& bindings() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_bindings();
  private:
  const std::string& _internal_bindings(int index) const;
  std::string* _internal_add_bindings();
  public:

  // @@protoc_insertion_point(class_scope:QueryResultInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> bindings_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_grpc_2eproto;
};
// -------------------------------------------------------------------

class TxnLogInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TxnLogInfo) */ {
 public:
  inline TxnLogInfo() : TxnLogInfo(nullptr) {}
  ~TxnLogInfo() override;
  explicit constexpr TxnLogInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TxnLogInfo(const TxnLogInfo& from);
  TxnLogInfo(TxnLogInfo&& from) noexcept
    : TxnLogInfo() {
    *this = ::std::move(from);
  }

  inline TxnLogInfo& operator=(const TxnLogInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TxnLogInfo& operator=(TxnLogInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TxnLogInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TxnLogInfo* internal_default_instance() {
    return reinterpret_cast<const TxnLogInfo*>(
               &_TxnLogInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(TxnLogInfo& a, TxnLogInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TxnLogInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TxnLogInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TxnLogInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TxnLogInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TxnLogInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TxnLogInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TxnLogInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TxnLogInfo";
  }
  protected:
  explicit TxnLogInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDbNameFieldNumber = 1,
    kTIDFieldNumber = 2,
    kUserFieldNumber = 3,
    kBeginTimeFieldNumber = 4,
    kStateFieldNumber = 5,
    kEndTimeFieldNumber = 6,
  };
  // optional string db_name = 1;
  bool has_db_name() const;
  private:
  bool _internal_has_db_name() const;
  public:
  void clear_db_name();
  const std::string& db_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_db_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_db_name();
  PROTOBUF_NODISCARD std::string* release_db_name();
  void set_allocated_db_name(std::string* db_name);
  private:
  const std::string& _internal_db_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_db_name(const std::string& value);
  std::string* _internal_mutable_db_name();
  public:

  // optional string TID = 2;
  bool has_tid() const;
  private:
  bool _internal_has_tid() const;
  public:
  void clear_tid();
  const std::string& tid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tid();
  PROTOBUF_NODISCARD std::string* release_tid();
  void set_allocated_tid(std::string* tid);
  private:
  const std::string& _internal_tid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tid(const std::string& value);
  std::string* _internal_mutable_tid();
  public:

  // optional string user = 3;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const std::string& user() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user();
  PROTOBUF_NODISCARD std::string* release_user();
  void set_allocated_user(std::string* user);
  private:
  const std::string& _internal_user() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user(const std::string& value);
  std::string* _internal_mutable_user();
  public:

  // optional string begin_time = 4;
  bool has_begin_time() const;
  private:
  bool _internal_has_begin_time() const;
  public:
  void clear_begin_time();
  const std::string& begin_time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_begin_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_begin_time();
  PROTOBUF_NODISCARD std::string* release_begin_time();
  void set_allocated_begin_time(std::string* begin_time);
  private:
  const std::string& _internal_begin_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_begin_time(const std::string& value);
  std::string* _internal_mutable_begin_time();
  public:

  // optional string state = 5;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  const std::string& state() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_state(ArgT0&& arg0, ArgT... args);
  std::string* mutable_state();
  PROTOBUF_NODISCARD std::string* release_state();
  void set_allocated_state(std::string* state);
  private:
  const std::string& _internal_state() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_state(const std::string& value);
  std::string* _internal_mutable_state();
  public:

  // optional string end_time = 6;
  bool has_end_time() const;
  private:
  bool _internal_has_end_time() const;
  public:
  void clear_end_time();
  const std::string& end_time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_end_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_end_time();
  PROTOBUF_NODISCARD std::string* release_end_time();
  void set_allocated_end_time(std::string* end_time);
  private:
  const std::string& _internal_end_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_end_time(const std::string& value);
  std::string* _internal_mutable_end_time();
  public:

  // @@protoc_insertion_point(class_scope:TxnLogInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr db_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr begin_time_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr state_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr end_time_;
  friend struct ::TableStruct_grpc_2eproto;
};
// -------------------------------------------------------------------

class QueryLogInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:QueryLogInfo) */ {
 public:
  inline QueryLogInfo() : QueryLogInfo(nullptr) {}
  ~QueryLogInfo() override;
  explicit constexpr QueryLogInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryLogInfo(const QueryLogInfo& from);
  QueryLogInfo(QueryLogInfo&& from) noexcept
    : QueryLogInfo() {
    *this = ::std::move(from);
  }

  inline QueryLogInfo& operator=(const QueryLogInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryLogInfo& operator=(QueryLogInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryLogInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryLogInfo* internal_default_instance() {
    return reinterpret_cast<const QueryLogInfo*>(
               &_QueryLogInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(QueryLogInfo& a, QueryLogInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryLogInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryLogInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryLogInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryLogInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryLogInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const QueryLogInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryLogInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "QueryLogInfo";
  }
  protected:
  explicit QueryLogInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQueryDateTimeFieldNumber = 1,
    kSparqlFieldNumber = 2,
    kFormatFieldNumber = 3,
    kRemoteIPFieldNumber = 4,
    kFileNameFieldNumber = 5,
    kQueryTimeFieldNumber = 6,
    kAnsNumFieldNumber = 7,
  };
  // optional string QueryDateTime = 1;
  bool has_querydatetime() const;
  private:
  bool _internal_has_querydatetime() const;
  public:
  void clear_querydatetime();
  const std::string& querydatetime() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_querydatetime(ArgT0&& arg0, ArgT... args);
  std::string* mutable_querydatetime();
  PROTOBUF_NODISCARD std::string* release_querydatetime();
  void set_allocated_querydatetime(std::string* querydatetime);
  private:
  const std::string& _internal_querydatetime() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_querydatetime(const std::string& value);
  std::string* _internal_mutable_querydatetime();
  public:

  // optional string Sparql = 2;
  bool has_sparql() const;
  private:
  bool _internal_has_sparql() const;
  public:
  void clear_sparql();
  const std::string& sparql() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sparql(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sparql();
  PROTOBUF_NODISCARD std::string* release_sparql();
  void set_allocated_sparql(std::string* sparql);
  private:
  const std::string& _internal_sparql() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sparql(const std::string& value);
  std::string* _internal_mutable_sparql();
  public:

  // optional string Format = 3;
  bool has_format() const;
  private:
  bool _internal_has_format() const;
  public:
  void clear_format();
  const std::string& format() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_format(ArgT0&& arg0, ArgT... args);
  std::string* mutable_format();
  PROTOBUF_NODISCARD std::string* release_format();
  void set_allocated_format(std::string* format);
  private:
  const std::string& _internal_format() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_format(const std::string& value);
  std::string* _internal_mutable_format();
  public:

  // optional string RemoteIP = 4;
  bool has_remoteip() const;
  private:
  bool _internal_has_remoteip() const;
  public:
  void clear_remoteip();
  const std::string& remoteip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_remoteip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_remoteip();
  PROTOBUF_NODISCARD std::string* release_remoteip();
  void set_allocated_remoteip(std::string* remoteip);
  private:
  const std::string& _internal_remoteip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_remoteip(const std::string& value);
  std::string* _internal_mutable_remoteip();
  public:

  // optional string FileName = 5;
  bool has_filename() const;
  private:
  bool _internal_has_filename() const;
  public:
  void clear_filename();
  const std::string& filename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filename();
  PROTOBUF_NODISCARD std::string* release_filename();
  void set_allocated_filename(std::string* filename);
  private:
  const std::string& _internal_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filename(const std::string& value);
  std::string* _internal_mutable_filename();
  public:

  // optional int32 QueryTime = 6;
  bool has_querytime() const;
  private:
  bool _internal_has_querytime() const;
  public:
  void clear_querytime();
  int32_t querytime() const;
  void set_querytime(int32_t value);
  private:
  int32_t _internal_querytime() const;
  void _internal_set_querytime(int32_t value);
  public:

  // optional int32 AnsNum = 7;
  bool has_ansnum() const;
  private:
  bool _internal_has_ansnum() const;
  public:
  void clear_ansnum();
  int32_t ansnum() const;
  void set_ansnum(int32_t value);
  private:
  int32_t _internal_ansnum() const;
  void _internal_set_ansnum(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:QueryLogInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr querydatetime_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sparql_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr format_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr remoteip_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
  int32_t querytime_;
  int32_t ansnum_;
  friend struct ::TableStruct_grpc_2eproto;
};
// -------------------------------------------------------------------

class AccessLogInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AccessLogInfo) */ {
 public:
  inline AccessLogInfo() : AccessLogInfo(nullptr) {}
  ~AccessLogInfo() override;
  explicit constexpr AccessLogInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AccessLogInfo(const AccessLogInfo& from);
  AccessLogInfo(AccessLogInfo&& from) noexcept
    : AccessLogInfo() {
    *this = ::std::move(from);
  }

  inline AccessLogInfo& operator=(const AccessLogInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccessLogInfo& operator=(AccessLogInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AccessLogInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccessLogInfo* internal_default_instance() {
    return reinterpret_cast<const AccessLogInfo*>(
               &_AccessLogInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(AccessLogInfo& a, AccessLogInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(AccessLogInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccessLogInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AccessLogInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AccessLogInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AccessLogInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AccessLogInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccessLogInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AccessLogInfo";
  }
  protected:
  explicit AccessLogInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpFieldNumber = 1,
    kOperationFieldNumber = 2,
    kCreatetimeFieldNumber = 3,
    kMsgFieldNumber = 5,
    kCodeFieldNumber = 4,
  };
  // optional string ip = 1;
  bool has_ip() const;
  private:
  bool _internal_has_ip() const;
  public:
  void clear_ip();
  const std::string& ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip();
  PROTOBUF_NODISCARD std::string* release_ip();
  void set_allocated_ip(std::string* ip);
  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(const std::string& value);
  std::string* _internal_mutable_ip();
  public:

  // optional string operation = 2;
  bool has_operation() const;
  private:
  bool _internal_has_operation() const;
  public:
  void clear_operation();
  const std::string& operation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_operation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_operation();
  PROTOBUF_NODISCARD std::string* release_operation();
  void set_allocated_operation(std::string* operation);
  private:
  const std::string& _internal_operation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operation(const std::string& value);
  std::string* _internal_mutable_operation();
  public:

  // optional string createtime = 3;
  bool has_createtime() const;
  private:
  bool _internal_has_createtime() const;
  public:
  void clear_createtime();
  const std::string& createtime() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_createtime(ArgT0&& arg0, ArgT... args);
  std::string* mutable_createtime();
  PROTOBUF_NODISCARD std::string* release_createtime();
  void set_allocated_createtime(std::string* createtime);
  private:
  const std::string& _internal_createtime() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_createtime(const std::string& value);
  std::string* _internal_mutable_createtime();
  public:

  // optional string msg = 5;
  bool has_msg() const;
  private:
  bool _internal_has_msg() const;
  public:
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // optional int32 code = 4;
  bool has_code() const;
  private:
  bool _internal_has_code() const;
  public:
  void clear_code();
  int32_t code() const;
  void set_code(int32_t value);
  private:
  int32_t _internal_code() const;
  void _internal_set_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:AccessLogInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr operation_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr createtime_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  int32_t code_;
  friend struct ::TableStruct_grpc_2eproto;
};
// -------------------------------------------------------------------

class IPManageInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IPManageInfo) */ {
 public:
  inline IPManageInfo() : IPManageInfo(nullptr) {}
  ~IPManageInfo() override;
  explicit constexpr IPManageInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IPManageInfo(const IPManageInfo& from);
  IPManageInfo(IPManageInfo&& from) noexcept
    : IPManageInfo() {
    *this = ::std::move(from);
  }

  inline IPManageInfo& operator=(const IPManageInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline IPManageInfo& operator=(IPManageInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IPManageInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const IPManageInfo* internal_default_instance() {
    return reinterpret_cast<const IPManageInfo*>(
               &_IPManageInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(IPManageInfo& a, IPManageInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(IPManageInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IPManageInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IPManageInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IPManageInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IPManageInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IPManageInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IPManageInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IPManageInfo";
  }
  protected:
  explicit IPManageInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpsFieldNumber = 2,
    kIpTypeFieldNumber = 1,
  };
  // repeated string ips = 2;
  int ips_size() const;
  private:
  int _internal_ips_size() const;
  public:
  void clear_ips();
  const std::string& ips(int index) const;
  std::string* mutable_ips(int index);
  void set_ips(int index, const std::string& value);
  void set_ips(int index, std::string&& value);
  void set_ips(int index, const char* value);
  void set_ips(int index, const char* value, size_t size);
  std::string* add_ips();
  void add_ips(const std::string& value);
  void add_ips(std::string&& value);
  void add_ips(const char* value);
  void add_ips(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& ips() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_ips();
  private:
  const std::string& _internal_ips(int index) const;
  std::string* _internal_add_ips();
  public:

  // optional string ip_type = 1;
  bool has_ip_type() const;
  private:
  bool _internal_has_ip_type() const;
  public:
  void clear_ip_type();
  const std::string& ip_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip_type();
  PROTOBUF_NODISCARD std::string* release_ip_type();
  void set_allocated_ip_type(std::string* ip_type);
  private:
  const std::string& _internal_ip_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip_type(const std::string& value);
  std::string* _internal_mutable_ip_type();
  public:

  // @@protoc_insertion_point(class_scope:IPManageInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> ips_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_type_;
  friend struct ::TableStruct_grpc_2eproto;
};
// -------------------------------------------------------------------

class FunInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:FunInfo) */ {
 public:
  inline FunInfo() : FunInfo(nullptr) {}
  ~FunInfo() override;
  explicit constexpr FunInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FunInfo(const FunInfo& from);
  FunInfo(FunInfo&& from) noexcept
    : FunInfo() {
    *this = ::std::move(from);
  }

  inline FunInfo& operator=(const FunInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline FunInfo& operator=(FunInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FunInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const FunInfo* internal_default_instance() {
    return reinterpret_cast<const FunInfo*>(
               &_FunInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(FunInfo& a, FunInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(FunInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FunInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FunInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FunInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FunInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FunInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FunInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "FunInfo";
  }
  protected:
  explicit FunInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFunNameFieldNumber = 1,
    kFunDescFieldNumber = 2,
    kFunArgsFieldNumber = 3,
    kFunBodyFieldNumber = 4,
    kFunSubsFieldNumber = 5,
    kFunStatusFieldNumber = 6,
    kFunReturnFieldNumber = 7,
    kLastTimeFieldNumber = 8,
    kFunReviewFieldNumber = 9,
  };
  // optional string fun_name = 1;
  bool has_fun_name() const;
  private:
  bool _internal_has_fun_name() const;
  public:
  void clear_fun_name();
  const std::string& fun_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fun_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fun_name();
  PROTOBUF_NODISCARD std::string* release_fun_name();
  void set_allocated_fun_name(std::string* fun_name);
  private:
  const std::string& _internal_fun_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fun_name(const std::string& value);
  std::string* _internal_mutable_fun_name();
  public:

  // optional string fun_desc = 2;
  bool has_fun_desc() const;
  private:
  bool _internal_has_fun_desc() const;
  public:
  void clear_fun_desc();
  const std::string& fun_desc() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fun_desc(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fun_desc();
  PROTOBUF_NODISCARD std::string* release_fun_desc();
  void set_allocated_fun_desc(std::string* fun_desc);
  private:
  const std::string& _internal_fun_desc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fun_desc(const std::string& value);
  std::string* _internal_mutable_fun_desc();
  public:

  // optional string fun_args = 3;
  bool has_fun_args() const;
  private:
  bool _internal_has_fun_args() const;
  public:
  void clear_fun_args();
  const std::string& fun_args() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fun_args(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fun_args();
  PROTOBUF_NODISCARD std::string* release_fun_args();
  void set_allocated_fun_args(std::string* fun_args);
  private:
  const std::string& _internal_fun_args() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fun_args(const std::string& value);
  std::string* _internal_mutable_fun_args();
  public:

  // optional string fun_body = 4;
  bool has_fun_body() const;
  private:
  bool _internal_has_fun_body() const;
  public:
  void clear_fun_body();
  const std::string& fun_body() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fun_body(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fun_body();
  PROTOBUF_NODISCARD std::string* release_fun_body();
  void set_allocated_fun_body(std::string* fun_body);
  private:
  const std::string& _internal_fun_body() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fun_body(const std::string& value);
  std::string* _internal_mutable_fun_body();
  public:

  // optional string fun_subs = 5;
  bool has_fun_subs() const;
  private:
  bool _internal_has_fun_subs() const;
  public:
  void clear_fun_subs();
  const std::string& fun_subs() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fun_subs(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fun_subs();
  PROTOBUF_NODISCARD std::string* release_fun_subs();
  void set_allocated_fun_subs(std::string* fun_subs);
  private:
  const std::string& _internal_fun_subs() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fun_subs(const std::string& value);
  std::string* _internal_mutable_fun_subs();
  public:

  // optional string fun_status = 6;
  bool has_fun_status() const;
  private:
  bool _internal_has_fun_status() const;
  public:
  void clear_fun_status();
  const std::string& fun_status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fun_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fun_status();
  PROTOBUF_NODISCARD std::string* release_fun_status();
  void set_allocated_fun_status(std::string* fun_status);
  private:
  const std::string& _internal_fun_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fun_status(const std::string& value);
  std::string* _internal_mutable_fun_status();
  public:

  // optional string fun_return = 7;
  bool has_fun_return() const;
  private:
  bool _internal_has_fun_return() const;
  public:
  void clear_fun_return();
  const std::string& fun_return() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fun_return(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fun_return();
  PROTOBUF_NODISCARD std::string* release_fun_return();
  void set_allocated_fun_return(std::string* fun_return);
  private:
  const std::string& _internal_fun_return() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fun_return(const std::string& value);
  std::string* _internal_mutable_fun_return();
  public:

  // optional string last_time = 8;
  bool has_last_time() const;
  private:
  bool _internal_has_last_time() const;
  public:
  void clear_last_time();
  const std::string& last_time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_last_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_last_time();
  PROTOBUF_NODISCARD std::string* release_last_time();
  void set_allocated_last_time(std::string* last_time);
  private:
  const std::string& _internal_last_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_last_time(const std::string& value);
  std::string* _internal_mutable_last_time();
  public:

  // optional string fun_review = 9;
  bool has_fun_review() const;
  private:
  bool _internal_has_fun_review() const;
  public:
  void clear_fun_review();
  const std::string& fun_review() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fun_review(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fun_review();
  PROTOBUF_NODISCARD std::string* release_fun_review();
  void set_allocated_fun_review(std::string* fun_review);
  private:
  const std::string& _internal_fun_review() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fun_review(const std::string& value);
  std::string* _internal_mutable_fun_review();
  public:

  // @@protoc_insertion_point(class_scope:FunInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fun_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fun_desc_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fun_args_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fun_body_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fun_subs_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fun_status_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fun_return_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr last_time_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fun_review_;
  friend struct ::TableStruct_grpc_2eproto;
};
// -------------------------------------------------------------------

class CommonResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CommonResponse) */ {
 public:
  inline CommonResponse() : CommonResponse(nullptr) {}
  ~CommonResponse() override;
  explicit constexpr CommonResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommonResponse(const CommonResponse& from);
  CommonResponse(CommonResponse&& from) noexcept
    : CommonResponse() {
    *this = ::std::move(from);
  }

  inline CommonResponse& operator=(const CommonResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommonResponse& operator=(CommonResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommonResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommonResponse* internal_default_instance() {
    return reinterpret_cast<const CommonResponse*>(
               &_CommonResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(CommonResponse& a, CommonResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CommonResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommonResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommonResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommonResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CommonResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CommonResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommonResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CommonResponse";
  }
  protected:
  explicit CommonResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseBodyFieldNumber = 3,
    kListFieldNumber = 13,
    kStatusMsgFieldNumber = 2,
    kThreadIdFieldNumber = 8,
    kQueryTimeFieldNumber = 9,
    kFileNameFieldNumber = 10,
    kFilepathFieldNumber = 11,
    kTIDFieldNumber = 12,
    kCoreVersionFieldNumber = 14,
    kLicensetypeFieldNumber = 15,
    kSuccessNumFieldNumber = 16,
    kBackupfilepathFieldNumber = 21,
    kResultFieldNumber = 22,
    kHeadFieldNumber = 4,
    kResultsFieldNumber = 5,
    kStatusCodeFieldNumber = 1,
    kAnsNumFieldNumber = 6,
    kOutputLimitFieldNumber = 7,
    kTotalSizeFieldNumber = 17,
    kTotalPageFieldNumber = 18,
    kPageNoFieldNumber = 19,
    kPageSizeFieldNumber = 20,
  };
  // repeated .google.protobuf.Any ResponseBody = 3;
  int responsebody_size() const;
  private:
  int _internal_responsebody_size() const;
  public:
  void clear_responsebody();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_responsebody(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any >*
      mutable_responsebody();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_responsebody(int index) const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_add_responsebody();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Any& responsebody(int index) const;
  ::PROTOBUF_NAMESPACE_ID::Any* add_responsebody();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any >&
      responsebody() const;

  // repeated .google.protobuf.Any list = 13;
  int list_size() const;
  private:
  int _internal_list_size() const;
  public:
  void clear_list();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any >*
      mutable_list();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_list(int index) const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_add_list();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Any& list(int index) const;
  ::PROTOBUF_NAMESPACE_ID::Any* add_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any >&
      list() const;

  // optional string StatusMsg = 2;
  bool has_statusmsg() const;
  private:
  bool _internal_has_statusmsg() const;
  public:
  void clear_statusmsg();
  const std::string& statusmsg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_statusmsg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_statusmsg();
  PROTOBUF_NODISCARD std::string* release_statusmsg();
  void set_allocated_statusmsg(std::string* statusmsg);
  private:
  const std::string& _internal_statusmsg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_statusmsg(const std::string& value);
  std::string* _internal_mutable_statusmsg();
  public:

  // optional string ThreadId = 8;
  bool has_threadid() const;
  private:
  bool _internal_has_threadid() const;
  public:
  void clear_threadid();
  const std::string& threadid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_threadid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_threadid();
  PROTOBUF_NODISCARD std::string* release_threadid();
  void set_allocated_threadid(std::string* threadid);
  private:
  const std::string& _internal_threadid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_threadid(const std::string& value);
  std::string* _internal_mutable_threadid();
  public:

  // optional string QueryTime = 9;
  bool has_querytime() const;
  private:
  bool _internal_has_querytime() const;
  public:
  void clear_querytime();
  const std::string& querytime() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_querytime(ArgT0&& arg0, ArgT... args);
  std::string* mutable_querytime();
  PROTOBUF_NODISCARD std::string* release_querytime();
  void set_allocated_querytime(std::string* querytime);
  private:
  const std::string& _internal_querytime() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_querytime(const std::string& value);
  std::string* _internal_mutable_querytime();
  public:

  // optional string FileName = 10;
  bool has_filename() const;
  private:
  bool _internal_has_filename() const;
  public:
  void clear_filename();
  const std::string& filename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filename();
  PROTOBUF_NODISCARD std::string* release_filename();
  void set_allocated_filename(std::string* filename);
  private:
  const std::string& _internal_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filename(const std::string& value);
  std::string* _internal_mutable_filename();
  public:

  // optional string filepath = 11;
  bool has_filepath() const;
  private:
  bool _internal_has_filepath() const;
  public:
  void clear_filepath();
  const std::string& filepath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filepath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filepath();
  PROTOBUF_NODISCARD std::string* release_filepath();
  void set_allocated_filepath(std::string* filepath);
  private:
  const std::string& _internal_filepath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filepath(const std::string& value);
  std::string* _internal_mutable_filepath();
  public:

  // optional string TID = 12;
  bool has_tid() const;
  private:
  bool _internal_has_tid() const;
  public:
  void clear_tid();
  const std::string& tid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tid();
  PROTOBUF_NODISCARD std::string* release_tid();
  void set_allocated_tid(std::string* tid);
  private:
  const std::string& _internal_tid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tid(const std::string& value);
  std::string* _internal_mutable_tid();
  public:

  // optional string CoreVersion = 14;
  bool has_coreversion() const;
  private:
  bool _internal_has_coreversion() const;
  public:
  void clear_coreversion();
  const std::string& coreversion() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_coreversion(ArgT0&& arg0, ArgT... args);
  std::string* mutable_coreversion();
  PROTOBUF_NODISCARD std::string* release_coreversion();
  void set_allocated_coreversion(std::string* coreversion);
  private:
  const std::string& _internal_coreversion() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_coreversion(const std::string& value);
  std::string* _internal_mutable_coreversion();
  public:

  // optional string licensetype = 15;
  bool has_licensetype() const;
  private:
  bool _internal_has_licensetype() const;
  public:
  void clear_licensetype();
  const std::string& licensetype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_licensetype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_licensetype();
  PROTOBUF_NODISCARD std::string* release_licensetype();
  void set_allocated_licensetype(std::string* licensetype);
  private:
  const std::string& _internal_licensetype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_licensetype(const std::string& value);
  std::string* _internal_mutable_licensetype();
  public:

  // optional string success_num = 16;
  bool has_success_num() const;
  private:
  bool _internal_has_success_num() const;
  public:
  void clear_success_num();
  const std::string& success_num() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_success_num(ArgT0&& arg0, ArgT... args);
  std::string* mutable_success_num();
  PROTOBUF_NODISCARD std::string* release_success_num();
  void set_allocated_success_num(std::string* success_num);
  private:
  const std::string& _internal_success_num() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_success_num(const std::string& value);
  std::string* _internal_mutable_success_num();
  public:

  // optional string backupfilepath = 21;
  bool has_backupfilepath() const;
  private:
  bool _internal_has_backupfilepath() const;
  public:
  void clear_backupfilepath();
  const std::string& backupfilepath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_backupfilepath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_backupfilepath();
  PROTOBUF_NODISCARD std::string* release_backupfilepath();
  void set_allocated_backupfilepath(std::string* backupfilepath);
  private:
  const std::string& _internal_backupfilepath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_backupfilepath(const std::string& value);
  std::string* _internal_mutable_backupfilepath();
  public:

  // optional string Result = 22;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const std::string& result() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_result(ArgT0&& arg0, ArgT... args);
  std::string* mutable_result();
  PROTOBUF_NODISCARD std::string* release_result();
  void set_allocated_result(std::string* result);
  private:
  const std::string& _internal_result() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_result(const std::string& value);
  std::string* _internal_mutable_result();
  public:

  // optional .QueryHeadInfo head = 4;
  bool has_head() const;
  private:
  bool _internal_has_head() const;
  public:
  void clear_head();
  const ::QueryHeadInfo& head() const;
  PROTOBUF_NODISCARD ::QueryHeadInfo* release_head();
  ::QueryHeadInfo* mutable_head();
  void set_allocated_head(::QueryHeadInfo* head);
  private:
  const ::QueryHeadInfo& _internal_head() const;
  ::QueryHeadInfo* _internal_mutable_head();
  public:
  void unsafe_arena_set_allocated_head(
      ::QueryHeadInfo* head);
  ::QueryHeadInfo* unsafe_arena_release_head();

  // optional .QueryResultInfo results = 5;
  bool has_results() const;
  private:
  bool _internal_has_results() const;
  public:
  void clear_results();
  const ::QueryResultInfo& results() const;
  PROTOBUF_NODISCARD ::QueryResultInfo* release_results();
  ::QueryResultInfo* mutable_results();
  void set_allocated_results(::QueryResultInfo* results);
  private:
  const ::QueryResultInfo& _internal_results() const;
  ::QueryResultInfo* _internal_mutable_results();
  public:
  void unsafe_arena_set_allocated_results(
      ::QueryResultInfo* results);
  ::QueryResultInfo* unsafe_arena_release_results();

  // optional int32 StatusCode = 1;
  bool has_statuscode() const;
  private:
  bool _internal_has_statuscode() const;
  public:
  void clear_statuscode();
  int32_t statuscode() const;
  void set_statuscode(int32_t value);
  private:
  int32_t _internal_statuscode() const;
  void _internal_set_statuscode(int32_t value);
  public:

  // optional int32 AnsNum = 6;
  bool has_ansnum() const;
  private:
  bool _internal_has_ansnum() const;
  public:
  void clear_ansnum();
  int32_t ansnum() const;
  void set_ansnum(int32_t value);
  private:
  int32_t _internal_ansnum() const;
  void _internal_set_ansnum(int32_t value);
  public:

  // optional int32 OutputLimit = 7;
  bool has_outputlimit() const;
  private:
  bool _internal_has_outputlimit() const;
  public:
  void clear_outputlimit();
  int32_t outputlimit() const;
  void set_outputlimit(int32_t value);
  private:
  int32_t _internal_outputlimit() const;
  void _internal_set_outputlimit(int32_t value);
  public:

  // optional int32 totalSize = 17;
  bool has_totalsize() const;
  private:
  bool _internal_has_totalsize() const;
  public:
  void clear_totalsize();
  int32_t totalsize() const;
  void set_totalsize(int32_t value);
  private:
  int32_t _internal_totalsize() const;
  void _internal_set_totalsize(int32_t value);
  public:

  // optional int32 totalPage = 18;
  bool has_totalpage() const;
  private:
  bool _internal_has_totalpage() const;
  public:
  void clear_totalpage();
  int32_t totalpage() const;
  void set_totalpage(int32_t value);
  private:
  int32_t _internal_totalpage() const;
  void _internal_set_totalpage(int32_t value);
  public:

  // optional int32 pageNo = 19;
  bool has_pageno() const;
  private:
  bool _internal_has_pageno() const;
  public:
  void clear_pageno();
  int32_t pageno() const;
  void set_pageno(int32_t value);
  private:
  int32_t _internal_pageno() const;
  void _internal_set_pageno(int32_t value);
  public:

  // optional int32 pageSize = 20;
  bool has_pagesize() const;
  private:
  bool _internal_has_pagesize() const;
  public:
  void clear_pagesize();
  int32_t pagesize() const;
  void set_pagesize(int32_t value);
  private:
  int32_t _internal_pagesize() const;
  void _internal_set_pagesize(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CommonResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any > responsebody_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any > list_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr statusmsg_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr threadid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr querytime_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filepath_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr coreversion_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr licensetype_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr success_num_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr backupfilepath_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr result_;
  ::QueryHeadInfo* head_;
  ::QueryResultInfo* results_;
  int32_t statuscode_;
  int32_t ansnum_;
  int32_t outputlimit_;
  int32_t totalsize_;
  int32_t totalpage_;
  int32_t pageno_;
  int32_t pagesize_;
  friend struct ::TableStruct_grpc_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CommonRequest

// required string username = 1;
inline bool CommonRequest::_internal_has_username() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommonRequest::has_username() const {
  return _internal_has_username();
}
inline void CommonRequest::clear_username() {
  username_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommonRequest::username() const {
  // @@protoc_insertion_point(field_get:CommonRequest.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonRequest::set_username(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonRequest.username)
}
inline std::string* CommonRequest::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:CommonRequest.username)
  return _s;
}
inline const std::string& CommonRequest::_internal_username() const {
  return username_.Get();
}
inline void CommonRequest::_internal_set_username(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonRequest::_internal_mutable_username() {
  _has_bits_[0] |= 0x00000001u;
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonRequest::release_username() {
  // @@protoc_insertion_point(field_release:CommonRequest.username)
  if (!_internal_has_username()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = username_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (username_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonRequest::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (username_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonRequest.username)
}

// required string password = 2;
inline bool CommonRequest::_internal_has_password() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommonRequest::has_password() const {
  return _internal_has_password();
}
inline void CommonRequest::clear_password() {
  password_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CommonRequest::password() const {
  // @@protoc_insertion_point(field_get:CommonRequest.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonRequest::set_password(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonRequest.password)
}
inline std::string* CommonRequest::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:CommonRequest.password)
  return _s;
}
inline const std::string& CommonRequest::_internal_password() const {
  return password_.Get();
}
inline void CommonRequest::_internal_set_password(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonRequest::_internal_mutable_password() {
  _has_bits_[0] |= 0x00000002u;
  return password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonRequest::release_password() {
  // @@protoc_insertion_point(field_release:CommonRequest.password)
  if (!_internal_has_password()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = password_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (password_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonRequest::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (password_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonRequest.password)
}

// optional string operation = 3;
inline bool CommonRequest::_internal_has_operation() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CommonRequest::has_operation() const {
  return _internal_has_operation();
}
inline void CommonRequest::clear_operation() {
  operation_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CommonRequest::operation() const {
  // @@protoc_insertion_point(field_get:CommonRequest.operation)
  return _internal_operation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonRequest::set_operation(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 operation_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonRequest.operation)
}
inline std::string* CommonRequest::mutable_operation() {
  std::string* _s = _internal_mutable_operation();
  // @@protoc_insertion_point(field_mutable:CommonRequest.operation)
  return _s;
}
inline const std::string& CommonRequest::_internal_operation() const {
  return operation_.Get();
}
inline void CommonRequest::_internal_set_operation(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  operation_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonRequest::_internal_mutable_operation() {
  _has_bits_[0] |= 0x00000004u;
  return operation_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonRequest::release_operation() {
  // @@protoc_insertion_point(field_release:CommonRequest.operation)
  if (!_internal_has_operation()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = operation_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (operation_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    operation_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonRequest::set_allocated_operation(std::string* operation) {
  if (operation != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  operation_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), operation,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (operation_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    operation_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonRequest.operation)
}

// optional string encryption = 4;
inline bool CommonRequest::_internal_has_encryption() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CommonRequest::has_encryption() const {
  return _internal_has_encryption();
}
inline void CommonRequest::clear_encryption() {
  encryption_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CommonRequest::encryption() const {
  // @@protoc_insertion_point(field_get:CommonRequest.encryption)
  return _internal_encryption();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonRequest::set_encryption(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 encryption_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonRequest.encryption)
}
inline std::string* CommonRequest::mutable_encryption() {
  std::string* _s = _internal_mutable_encryption();
  // @@protoc_insertion_point(field_mutable:CommonRequest.encryption)
  return _s;
}
inline const std::string& CommonRequest::_internal_encryption() const {
  return encryption_.Get();
}
inline void CommonRequest::_internal_set_encryption(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  encryption_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonRequest::_internal_mutable_encryption() {
  _has_bits_[0] |= 0x00000008u;
  return encryption_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonRequest::release_encryption() {
  // @@protoc_insertion_point(field_release:CommonRequest.encryption)
  if (!_internal_has_encryption()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = encryption_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (encryption_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    encryption_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonRequest::set_allocated_encryption(std::string* encryption) {
  if (encryption != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  encryption_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), encryption,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (encryption_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    encryption_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonRequest.encryption)
}

// optional string db_name = 5;
inline bool CommonRequest::_internal_has_db_name() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CommonRequest::has_db_name() const {
  return _internal_has_db_name();
}
inline void CommonRequest::clear_db_name() {
  db_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& CommonRequest::db_name() const {
  // @@protoc_insertion_point(field_get:CommonRequest.db_name)
  return _internal_db_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonRequest::set_db_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 db_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonRequest.db_name)
}
inline std::string* CommonRequest::mutable_db_name() {
  std::string* _s = _internal_mutable_db_name();
  // @@protoc_insertion_point(field_mutable:CommonRequest.db_name)
  return _s;
}
inline const std::string& CommonRequest::_internal_db_name() const {
  return db_name_.Get();
}
inline void CommonRequest::_internal_set_db_name(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  db_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonRequest::_internal_mutable_db_name() {
  _has_bits_[0] |= 0x00000010u;
  return db_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonRequest::release_db_name() {
  // @@protoc_insertion_point(field_release:CommonRequest.db_name)
  if (!_internal_has_db_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = db_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (db_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    db_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonRequest::set_allocated_db_name(std::string* db_name) {
  if (db_name != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  db_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), db_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (db_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    db_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonRequest.db_name)
}

// optional string db_path = 6;
inline bool CommonRequest::_internal_has_db_path() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CommonRequest::has_db_path() const {
  return _internal_has_db_path();
}
inline void CommonRequest::clear_db_path() {
  db_path_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& CommonRequest::db_path() const {
  // @@protoc_insertion_point(field_get:CommonRequest.db_path)
  return _internal_db_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonRequest::set_db_path(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 db_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonRequest.db_path)
}
inline std::string* CommonRequest::mutable_db_path() {
  std::string* _s = _internal_mutable_db_path();
  // @@protoc_insertion_point(field_mutable:CommonRequest.db_path)
  return _s;
}
inline const std::string& CommonRequest::_internal_db_path() const {
  return db_path_.Get();
}
inline void CommonRequest::_internal_set_db_path(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  db_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonRequest::_internal_mutable_db_path() {
  _has_bits_[0] |= 0x00000020u;
  return db_path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonRequest::release_db_path() {
  // @@protoc_insertion_point(field_release:CommonRequest.db_path)
  if (!_internal_has_db_path()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  auto* p = db_path_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (db_path_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    db_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonRequest::set_allocated_db_path(std::string* db_path) {
  if (db_path != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  db_path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), db_path,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (db_path_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    db_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonRequest.db_path)
}

// optional string load_csr = 7;
inline bool CommonRequest::_internal_has_load_csr() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CommonRequest::has_load_csr() const {
  return _internal_has_load_csr();
}
inline void CommonRequest::clear_load_csr() {
  load_csr_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& CommonRequest::load_csr() const {
  // @@protoc_insertion_point(field_get:CommonRequest.load_csr)
  return _internal_load_csr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonRequest::set_load_csr(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000040u;
 load_csr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonRequest.load_csr)
}
inline std::string* CommonRequest::mutable_load_csr() {
  std::string* _s = _internal_mutable_load_csr();
  // @@protoc_insertion_point(field_mutable:CommonRequest.load_csr)
  return _s;
}
inline const std::string& CommonRequest::_internal_load_csr() const {
  return load_csr_.Get();
}
inline void CommonRequest::_internal_set_load_csr(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  load_csr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonRequest::_internal_mutable_load_csr() {
  _has_bits_[0] |= 0x00000040u;
  return load_csr_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonRequest::release_load_csr() {
  // @@protoc_insertion_point(field_release:CommonRequest.load_csr)
  if (!_internal_has_load_csr()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  auto* p = load_csr_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (load_csr_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    load_csr_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonRequest::set_allocated_load_csr(std::string* load_csr) {
  if (load_csr != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  load_csr_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), load_csr,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (load_csr_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    load_csr_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonRequest.load_csr)
}

// optional string is_backup = 8;
inline bool CommonRequest::_internal_has_is_backup() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CommonRequest::has_is_backup() const {
  return _internal_has_is_backup();
}
inline void CommonRequest::clear_is_backup() {
  is_backup_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000080u;
}
inline const std::string& CommonRequest::is_backup() const {
  // @@protoc_insertion_point(field_get:CommonRequest.is_backup)
  return _internal_is_backup();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonRequest::set_is_backup(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000080u;
 is_backup_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonRequest.is_backup)
}
inline std::string* CommonRequest::mutable_is_backup() {
  std::string* _s = _internal_mutable_is_backup();
  // @@protoc_insertion_point(field_mutable:CommonRequest.is_backup)
  return _s;
}
inline const std::string& CommonRequest::_internal_is_backup() const {
  return is_backup_.Get();
}
inline void CommonRequest::_internal_set_is_backup(const std::string& value) {
  _has_bits_[0] |= 0x00000080u;
  is_backup_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonRequest::_internal_mutable_is_backup() {
  _has_bits_[0] |= 0x00000080u;
  return is_backup_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonRequest::release_is_backup() {
  // @@protoc_insertion_point(field_release:CommonRequest.is_backup)
  if (!_internal_has_is_backup()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000080u;
  auto* p = is_backup_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (is_backup_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    is_backup_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonRequest::set_allocated_is_backup(std::string* is_backup) {
  if (is_backup != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  is_backup_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), is_backup,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (is_backup_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    is_backup_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonRequest.is_backup)
}

// optional string type = 9;
inline bool CommonRequest::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CommonRequest::has_type() const {
  return _internal_has_type();
}
inline void CommonRequest::clear_type() {
  type_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000100u;
}
inline const std::string& CommonRequest::type() const {
  // @@protoc_insertion_point(field_get:CommonRequest.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonRequest::set_type(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000100u;
 type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonRequest.type)
}
inline std::string* CommonRequest::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:CommonRequest.type)
  return _s;
}
inline const std::string& CommonRequest::_internal_type() const {
  return type_.Get();
}
inline void CommonRequest::_internal_set_type(const std::string& value) {
  _has_bits_[0] |= 0x00000100u;
  type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonRequest::_internal_mutable_type() {
  _has_bits_[0] |= 0x00000100u;
  return type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonRequest::release_type() {
  // @@protoc_insertion_point(field_release:CommonRequest.type)
  if (!_internal_has_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000100u;
  auto* p = type_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonRequest::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonRequest.type)
}

// optional string op_username = 10;
inline bool CommonRequest::_internal_has_op_username() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool CommonRequest::has_op_username() const {
  return _internal_has_op_username();
}
inline void CommonRequest::clear_op_username() {
  op_username_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000200u;
}
inline const std::string& CommonRequest::op_username() const {
  // @@protoc_insertion_point(field_get:CommonRequest.op_username)
  return _internal_op_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonRequest::set_op_username(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000200u;
 op_username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonRequest.op_username)
}
inline std::string* CommonRequest::mutable_op_username() {
  std::string* _s = _internal_mutable_op_username();
  // @@protoc_insertion_point(field_mutable:CommonRequest.op_username)
  return _s;
}
inline const std::string& CommonRequest::_internal_op_username() const {
  return op_username_.Get();
}
inline void CommonRequest::_internal_set_op_username(const std::string& value) {
  _has_bits_[0] |= 0x00000200u;
  op_username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonRequest::_internal_mutable_op_username() {
  _has_bits_[0] |= 0x00000200u;
  return op_username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonRequest::release_op_username() {
  // @@protoc_insertion_point(field_release:CommonRequest.op_username)
  if (!_internal_has_op_username()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000200u;
  auto* p = op_username_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (op_username_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    op_username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonRequest::set_allocated_op_username(std::string* op_username) {
  if (op_username != nullptr) {
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  op_username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), op_username,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (op_username_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    op_username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonRequest.op_username)
}

// optional string op_password = 11;
inline bool CommonRequest::_internal_has_op_password() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool CommonRequest::has_op_password() const {
  return _internal_has_op_password();
}
inline void CommonRequest::clear_op_password() {
  op_password_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000400u;
}
inline const std::string& CommonRequest::op_password() const {
  // @@protoc_insertion_point(field_get:CommonRequest.op_password)
  return _internal_op_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonRequest::set_op_password(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000400u;
 op_password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonRequest.op_password)
}
inline std::string* CommonRequest::mutable_op_password() {
  std::string* _s = _internal_mutable_op_password();
  // @@protoc_insertion_point(field_mutable:CommonRequest.op_password)
  return _s;
}
inline const std::string& CommonRequest::_internal_op_password() const {
  return op_password_.Get();
}
inline void CommonRequest::_internal_set_op_password(const std::string& value) {
  _has_bits_[0] |= 0x00000400u;
  op_password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonRequest::_internal_mutable_op_password() {
  _has_bits_[0] |= 0x00000400u;
  return op_password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonRequest::release_op_password() {
  // @@protoc_insertion_point(field_release:CommonRequest.op_password)
  if (!_internal_has_op_password()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000400u;
  auto* p = op_password_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (op_password_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    op_password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonRequest::set_allocated_op_password(std::string* op_password) {
  if (op_password != nullptr) {
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  op_password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), op_password,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (op_password_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    op_password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonRequest.op_password)
}

// optional string privileges = 12;
inline bool CommonRequest::_internal_has_privileges() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool CommonRequest::has_privileges() const {
  return _internal_has_privileges();
}
inline void CommonRequest::clear_privileges() {
  privileges_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000800u;
}
inline const std::string& CommonRequest::privileges() const {
  // @@protoc_insertion_point(field_get:CommonRequest.privileges)
  return _internal_privileges();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonRequest::set_privileges(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000800u;
 privileges_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonRequest.privileges)
}
inline std::string* CommonRequest::mutable_privileges() {
  std::string* _s = _internal_mutable_privileges();
  // @@protoc_insertion_point(field_mutable:CommonRequest.privileges)
  return _s;
}
inline const std::string& CommonRequest::_internal_privileges() const {
  return privileges_.Get();
}
inline void CommonRequest::_internal_set_privileges(const std::string& value) {
  _has_bits_[0] |= 0x00000800u;
  privileges_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonRequest::_internal_mutable_privileges() {
  _has_bits_[0] |= 0x00000800u;
  return privileges_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonRequest::release_privileges() {
  // @@protoc_insertion_point(field_release:CommonRequest.privileges)
  if (!_internal_has_privileges()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000800u;
  auto* p = privileges_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (privileges_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    privileges_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonRequest::set_allocated_privileges(std::string* privileges) {
  if (privileges != nullptr) {
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  privileges_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), privileges,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (privileges_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    privileges_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonRequest.privileges)
}

// optional string backup_path = 13;
inline bool CommonRequest::_internal_has_backup_path() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool CommonRequest::has_backup_path() const {
  return _internal_has_backup_path();
}
inline void CommonRequest::clear_backup_path() {
  backup_path_.ClearToEmpty();
  _has_bits_[0] &= ~0x00001000u;
}
inline const std::string& CommonRequest::backup_path() const {
  // @@protoc_insertion_point(field_get:CommonRequest.backup_path)
  return _internal_backup_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonRequest::set_backup_path(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00001000u;
 backup_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonRequest.backup_path)
}
inline std::string* CommonRequest::mutable_backup_path() {
  std::string* _s = _internal_mutable_backup_path();
  // @@protoc_insertion_point(field_mutable:CommonRequest.backup_path)
  return _s;
}
inline const std::string& CommonRequest::_internal_backup_path() const {
  return backup_path_.Get();
}
inline void CommonRequest::_internal_set_backup_path(const std::string& value) {
  _has_bits_[0] |= 0x00001000u;
  backup_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonRequest::_internal_mutable_backup_path() {
  _has_bits_[0] |= 0x00001000u;
  return backup_path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonRequest::release_backup_path() {
  // @@protoc_insertion_point(field_release:CommonRequest.backup_path)
  if (!_internal_has_backup_path()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00001000u;
  auto* p = backup_path_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (backup_path_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    backup_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonRequest::set_allocated_backup_path(std::string* backup_path) {
  if (backup_path != nullptr) {
    _has_bits_[0] |= 0x00001000u;
  } else {
    _has_bits_[0] &= ~0x00001000u;
  }
  backup_path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), backup_path,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (backup_path_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    backup_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonRequest.backup_path)
}

// optional string sparql = 14;
inline bool CommonRequest::_internal_has_sparql() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool CommonRequest::has_sparql() const {
  return _internal_has_sparql();
}
inline void CommonRequest::clear_sparql() {
  sparql_.ClearToEmpty();
  _has_bits_[0] &= ~0x00002000u;
}
inline const std::string& CommonRequest::sparql() const {
  // @@protoc_insertion_point(field_get:CommonRequest.sparql)
  return _internal_sparql();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonRequest::set_sparql(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00002000u;
 sparql_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonRequest.sparql)
}
inline std::string* CommonRequest::mutable_sparql() {
  std::string* _s = _internal_mutable_sparql();
  // @@protoc_insertion_point(field_mutable:CommonRequest.sparql)
  return _s;
}
inline const std::string& CommonRequest::_internal_sparql() const {
  return sparql_.Get();
}
inline void CommonRequest::_internal_set_sparql(const std::string& value) {
  _has_bits_[0] |= 0x00002000u;
  sparql_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonRequest::_internal_mutable_sparql() {
  _has_bits_[0] |= 0x00002000u;
  return sparql_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonRequest::release_sparql() {
  // @@protoc_insertion_point(field_release:CommonRequest.sparql)
  if (!_internal_has_sparql()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00002000u;
  auto* p = sparql_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sparql_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sparql_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonRequest::set_allocated_sparql(std::string* sparql) {
  if (sparql != nullptr) {
    _has_bits_[0] |= 0x00002000u;
  } else {
    _has_bits_[0] &= ~0x00002000u;
  }
  sparql_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sparql,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sparql_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sparql_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonRequest.sparql)
}

// optional string format = 15;
inline bool CommonRequest::_internal_has_format() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool CommonRequest::has_format() const {
  return _internal_has_format();
}
inline void CommonRequest::clear_format() {
  format_.ClearToEmpty();
  _has_bits_[0] &= ~0x00004000u;
}
inline const std::string& CommonRequest::format() const {
  // @@protoc_insertion_point(field_get:CommonRequest.format)
  return _internal_format();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonRequest::set_format(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00004000u;
 format_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonRequest.format)
}
inline std::string* CommonRequest::mutable_format() {
  std::string* _s = _internal_mutable_format();
  // @@protoc_insertion_point(field_mutable:CommonRequest.format)
  return _s;
}
inline const std::string& CommonRequest::_internal_format() const {
  return format_.Get();
}
inline void CommonRequest::_internal_set_format(const std::string& value) {
  _has_bits_[0] |= 0x00004000u;
  format_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonRequest::_internal_mutable_format() {
  _has_bits_[0] |= 0x00004000u;
  return format_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonRequest::release_format() {
  // @@protoc_insertion_point(field_release:CommonRequest.format)
  if (!_internal_has_format()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00004000u;
  auto* p = format_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (format_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    format_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonRequest::set_allocated_format(std::string* format) {
  if (format != nullptr) {
    _has_bits_[0] |= 0x00004000u;
  } else {
    _has_bits_[0] &= ~0x00004000u;
  }
  format_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), format,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (format_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    format_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonRequest.format)
}

// optional string isolevel = 16;
inline bool CommonRequest::_internal_has_isolevel() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool CommonRequest::has_isolevel() const {
  return _internal_has_isolevel();
}
inline void CommonRequest::clear_isolevel() {
  isolevel_.ClearToEmpty();
  _has_bits_[0] &= ~0x00008000u;
}
inline const std::string& CommonRequest::isolevel() const {
  // @@protoc_insertion_point(field_get:CommonRequest.isolevel)
  return _internal_isolevel();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonRequest::set_isolevel(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00008000u;
 isolevel_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonRequest.isolevel)
}
inline std::string* CommonRequest::mutable_isolevel() {
  std::string* _s = _internal_mutable_isolevel();
  // @@protoc_insertion_point(field_mutable:CommonRequest.isolevel)
  return _s;
}
inline const std::string& CommonRequest::_internal_isolevel() const {
  return isolevel_.Get();
}
inline void CommonRequest::_internal_set_isolevel(const std::string& value) {
  _has_bits_[0] |= 0x00008000u;
  isolevel_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonRequest::_internal_mutable_isolevel() {
  _has_bits_[0] |= 0x00008000u;
  return isolevel_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonRequest::release_isolevel() {
  // @@protoc_insertion_point(field_release:CommonRequest.isolevel)
  if (!_internal_has_isolevel()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00008000u;
  auto* p = isolevel_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (isolevel_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    isolevel_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonRequest::set_allocated_isolevel(std::string* isolevel) {
  if (isolevel != nullptr) {
    _has_bits_[0] |= 0x00008000u;
  } else {
    _has_bits_[0] &= ~0x00008000u;
  }
  isolevel_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), isolevel,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (isolevel_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    isolevel_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonRequest.isolevel)
}

// optional string tid = 17;
inline bool CommonRequest::_internal_has_tid() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool CommonRequest::has_tid() const {
  return _internal_has_tid();
}
inline void CommonRequest::clear_tid() {
  tid_.ClearToEmpty();
  _has_bits_[0] &= ~0x00010000u;
}
inline const std::string& CommonRequest::tid() const {
  // @@protoc_insertion_point(field_get:CommonRequest.tid)
  return _internal_tid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonRequest::set_tid(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00010000u;
 tid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonRequest.tid)
}
inline std::string* CommonRequest::mutable_tid() {
  std::string* _s = _internal_mutable_tid();
  // @@protoc_insertion_point(field_mutable:CommonRequest.tid)
  return _s;
}
inline const std::string& CommonRequest::_internal_tid() const {
  return tid_.Get();
}
inline void CommonRequest::_internal_set_tid(const std::string& value) {
  _has_bits_[0] |= 0x00010000u;
  tid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonRequest::_internal_mutable_tid() {
  _has_bits_[0] |= 0x00010000u;
  return tid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonRequest::release_tid() {
  // @@protoc_insertion_point(field_release:CommonRequest.tid)
  if (!_internal_has_tid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00010000u;
  auto* p = tid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    tid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonRequest::set_allocated_tid(std::string* tid) {
  if (tid != nullptr) {
    _has_bits_[0] |= 0x00010000u;
  } else {
    _has_bits_[0] &= ~0x00010000u;
  }
  tid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    tid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonRequest.tid)
}

// optional string file = 18;
inline bool CommonRequest::_internal_has_file() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool CommonRequest::has_file() const {
  return _internal_has_file();
}
inline void CommonRequest::clear_file() {
  file_.ClearToEmpty();
  _has_bits_[0] &= ~0x00020000u;
}
inline const std::string& CommonRequest::file() const {
  // @@protoc_insertion_point(field_get:CommonRequest.file)
  return _internal_file();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonRequest::set_file(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00020000u;
 file_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonRequest.file)
}
inline std::string* CommonRequest::mutable_file() {
  std::string* _s = _internal_mutable_file();
  // @@protoc_insertion_point(field_mutable:CommonRequest.file)
  return _s;
}
inline const std::string& CommonRequest::_internal_file() const {
  return file_.Get();
}
inline void CommonRequest::_internal_set_file(const std::string& value) {
  _has_bits_[0] |= 0x00020000u;
  file_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonRequest::_internal_mutable_file() {
  _has_bits_[0] |= 0x00020000u;
  return file_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonRequest::release_file() {
  // @@protoc_insertion_point(field_release:CommonRequest.file)
  if (!_internal_has_file()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00020000u;
  auto* p = file_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    file_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonRequest::set_allocated_file(std::string* file) {
  if (file != nullptr) {
    _has_bits_[0] |= 0x00020000u;
  } else {
    _has_bits_[0] &= ~0x00020000u;
  }
  file_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    file_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonRequest.file)
}

// optional string date = 19;
inline bool CommonRequest::_internal_has_date() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool CommonRequest::has_date() const {
  return _internal_has_date();
}
inline void CommonRequest::clear_date() {
  date_.ClearToEmpty();
  _has_bits_[0] &= ~0x00040000u;
}
inline const std::string& CommonRequest::date() const {
  // @@protoc_insertion_point(field_get:CommonRequest.date)
  return _internal_date();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonRequest::set_date(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00040000u;
 date_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonRequest.date)
}
inline std::string* CommonRequest::mutable_date() {
  std::string* _s = _internal_mutable_date();
  // @@protoc_insertion_point(field_mutable:CommonRequest.date)
  return _s;
}
inline const std::string& CommonRequest::_internal_date() const {
  return date_.Get();
}
inline void CommonRequest::_internal_set_date(const std::string& value) {
  _has_bits_[0] |= 0x00040000u;
  date_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonRequest::_internal_mutable_date() {
  _has_bits_[0] |= 0x00040000u;
  return date_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonRequest::release_date() {
  // @@protoc_insertion_point(field_release:CommonRequest.date)
  if (!_internal_has_date()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00040000u;
  auto* p = date_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (date_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    date_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonRequest::set_allocated_date(std::string* date) {
  if (date != nullptr) {
    _has_bits_[0] |= 0x00040000u;
  } else {
    _has_bits_[0] &= ~0x00040000u;
  }
  date_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), date,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (date_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    date_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonRequest.date)
}

// optional int32 pageNo = 20;
inline bool CommonRequest::_internal_has_pageno() const {
  bool value = (_has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool CommonRequest::has_pageno() const {
  return _internal_has_pageno();
}
inline void CommonRequest::clear_pageno() {
  pageno_ = 0;
  _has_bits_[0] &= ~0x00400000u;
}
inline int32_t CommonRequest::_internal_pageno() const {
  return pageno_;
}
inline int32_t CommonRequest::pageno() const {
  // @@protoc_insertion_point(field_get:CommonRequest.pageNo)
  return _internal_pageno();
}
inline void CommonRequest::_internal_set_pageno(int32_t value) {
  _has_bits_[0] |= 0x00400000u;
  pageno_ = value;
}
inline void CommonRequest::set_pageno(int32_t value) {
  _internal_set_pageno(value);
  // @@protoc_insertion_point(field_set:CommonRequest.pageNo)
}

// optional int32 pageSize = 21;
inline bool CommonRequest::_internal_has_pagesize() const {
  bool value = (_has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool CommonRequest::has_pagesize() const {
  return _internal_has_pagesize();
}
inline void CommonRequest::clear_pagesize() {
  pagesize_ = 0;
  _has_bits_[0] &= ~0x00800000u;
}
inline int32_t CommonRequest::_internal_pagesize() const {
  return pagesize_;
}
inline int32_t CommonRequest::pagesize() const {
  // @@protoc_insertion_point(field_get:CommonRequest.pageSize)
  return _internal_pagesize();
}
inline void CommonRequest::_internal_set_pagesize(int32_t value) {
  _has_bits_[0] |= 0x00800000u;
  pagesize_ = value;
}
inline void CommonRequest::set_pagesize(int32_t value) {
  _internal_set_pagesize(value);
  // @@protoc_insertion_point(field_set:CommonRequest.pageSize)
}

// optional string ip_type = 22;
inline bool CommonRequest::_internal_has_ip_type() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool CommonRequest::has_ip_type() const {
  return _internal_has_ip_type();
}
inline void CommonRequest::clear_ip_type() {
  ip_type_.ClearToEmpty();
  _has_bits_[0] &= ~0x00080000u;
}
inline const std::string& CommonRequest::ip_type() const {
  // @@protoc_insertion_point(field_get:CommonRequest.ip_type)
  return _internal_ip_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonRequest::set_ip_type(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00080000u;
 ip_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonRequest.ip_type)
}
inline std::string* CommonRequest::mutable_ip_type() {
  std::string* _s = _internal_mutable_ip_type();
  // @@protoc_insertion_point(field_mutable:CommonRequest.ip_type)
  return _s;
}
inline const std::string& CommonRequest::_internal_ip_type() const {
  return ip_type_.Get();
}
inline void CommonRequest::_internal_set_ip_type(const std::string& value) {
  _has_bits_[0] |= 0x00080000u;
  ip_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonRequest::_internal_mutable_ip_type() {
  _has_bits_[0] |= 0x00080000u;
  return ip_type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonRequest::release_ip_type() {
  // @@protoc_insertion_point(field_release:CommonRequest.ip_type)
  if (!_internal_has_ip_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00080000u;
  auto* p = ip_type_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ip_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ip_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonRequest::set_allocated_ip_type(std::string* ip_type) {
  if (ip_type != nullptr) {
    _has_bits_[0] |= 0x00080000u;
  } else {
    _has_bits_[0] &= ~0x00080000u;
  }
  ip_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip_type,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ip_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ip_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonRequest.ip_type)
}

// optional string ips = 23;
inline bool CommonRequest::_internal_has_ips() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool CommonRequest::has_ips() const {
  return _internal_has_ips();
}
inline void CommonRequest::clear_ips() {
  ips_.ClearToEmpty();
  _has_bits_[0] &= ~0x00100000u;
}
inline const std::string& CommonRequest::ips() const {
  // @@protoc_insertion_point(field_get:CommonRequest.ips)
  return _internal_ips();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonRequest::set_ips(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00100000u;
 ips_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonRequest.ips)
}
inline std::string* CommonRequest::mutable_ips() {
  std::string* _s = _internal_mutable_ips();
  // @@protoc_insertion_point(field_mutable:CommonRequest.ips)
  return _s;
}
inline const std::string& CommonRequest::_internal_ips() const {
  return ips_.Get();
}
inline void CommonRequest::_internal_set_ips(const std::string& value) {
  _has_bits_[0] |= 0x00100000u;
  ips_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonRequest::_internal_mutable_ips() {
  _has_bits_[0] |= 0x00100000u;
  return ips_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonRequest::release_ips() {
  // @@protoc_insertion_point(field_release:CommonRequest.ips)
  if (!_internal_has_ips()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00100000u;
  auto* p = ips_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ips_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ips_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonRequest::set_allocated_ips(std::string* ips) {
  if (ips != nullptr) {
    _has_bits_[0] |= 0x00100000u;
  } else {
    _has_bits_[0] &= ~0x00100000u;
  }
  ips_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ips,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ips_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ips_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonRequest.ips)
}

// optional .FunInfo fun_info = 24;
inline bool CommonRequest::_internal_has_fun_info() const {
  bool value = (_has_bits_[0] & 0x00200000u) != 0;
  PROTOBUF_ASSUME(!value || fun_info_ != nullptr);
  return value;
}
inline bool CommonRequest::has_fun_info() const {
  return _internal_has_fun_info();
}
inline void CommonRequest::clear_fun_info() {
  if (fun_info_ != nullptr) fun_info_->Clear();
  _has_bits_[0] &= ~0x00200000u;
}
inline const ::FunInfo& CommonRequest::_internal_fun_info() const {
  const ::FunInfo* p = fun_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::FunInfo&>(
      ::_FunInfo_default_instance_);
}
inline const ::FunInfo& CommonRequest::fun_info() const {
  // @@protoc_insertion_point(field_get:CommonRequest.fun_info)
  return _internal_fun_info();
}
inline void CommonRequest::unsafe_arena_set_allocated_fun_info(
    ::FunInfo* fun_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fun_info_);
  }
  fun_info_ = fun_info;
  if (fun_info) {
    _has_bits_[0] |= 0x00200000u;
  } else {
    _has_bits_[0] &= ~0x00200000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CommonRequest.fun_info)
}
inline ::FunInfo* CommonRequest::release_fun_info() {
  _has_bits_[0] &= ~0x00200000u;
  ::FunInfo* temp = fun_info_;
  fun_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::FunInfo* CommonRequest::unsafe_arena_release_fun_info() {
  // @@protoc_insertion_point(field_release:CommonRequest.fun_info)
  _has_bits_[0] &= ~0x00200000u;
  ::FunInfo* temp = fun_info_;
  fun_info_ = nullptr;
  return temp;
}
inline ::FunInfo* CommonRequest::_internal_mutable_fun_info() {
  _has_bits_[0] |= 0x00200000u;
  if (fun_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::FunInfo>(GetArenaForAllocation());
    fun_info_ = p;
  }
  return fun_info_;
}
inline ::FunInfo* CommonRequest::mutable_fun_info() {
  ::FunInfo* _msg = _internal_mutable_fun_info();
  // @@protoc_insertion_point(field_mutable:CommonRequest.fun_info)
  return _msg;
}
inline void CommonRequest::set_allocated_fun_info(::FunInfo* fun_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete fun_info_;
  }
  if (fun_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::FunInfo>::GetOwningArena(fun_info);
    if (message_arena != submessage_arena) {
      fun_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fun_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00200000u;
  } else {
    _has_bits_[0] &= ~0x00200000u;
  }
  fun_info_ = fun_info;
  // @@protoc_insertion_point(field_set_allocated:CommonRequest.fun_info)
}

// -------------------------------------------------------------------

// Monitor

// optional string database = 1;
inline bool Monitor::_internal_has_database() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Monitor::has_database() const {
  return _internal_has_database();
}
inline void Monitor::clear_database() {
  database_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Monitor::database() const {
  // @@protoc_insertion_point(field_get:Monitor.database)
  return _internal_database();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Monitor::set_database(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 database_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Monitor.database)
}
inline std::string* Monitor::mutable_database() {
  std::string* _s = _internal_mutable_database();
  // @@protoc_insertion_point(field_mutable:Monitor.database)
  return _s;
}
inline const std::string& Monitor::_internal_database() const {
  return database_.Get();
}
inline void Monitor::_internal_set_database(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  database_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Monitor::_internal_mutable_database() {
  _has_bits_[0] |= 0x00000001u;
  return database_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Monitor::release_database() {
  // @@protoc_insertion_point(field_release:Monitor.database)
  if (!_internal_has_database()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = database_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (database_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    database_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Monitor::set_allocated_database(std::string* database) {
  if (database != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  database_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), database,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (database_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    database_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Monitor.database)
}

// optional string creator = 2;
inline bool Monitor::_internal_has_creator() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Monitor::has_creator() const {
  return _internal_has_creator();
}
inline void Monitor::clear_creator() {
  creator_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Monitor::creator() const {
  // @@protoc_insertion_point(field_get:Monitor.creator)
  return _internal_creator();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Monitor::set_creator(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 creator_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Monitor.creator)
}
inline std::string* Monitor::mutable_creator() {
  std::string* _s = _internal_mutable_creator();
  // @@protoc_insertion_point(field_mutable:Monitor.creator)
  return _s;
}
inline const std::string& Monitor::_internal_creator() const {
  return creator_.Get();
}
inline void Monitor::_internal_set_creator(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  creator_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Monitor::_internal_mutable_creator() {
  _has_bits_[0] |= 0x00000002u;
  return creator_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Monitor::release_creator() {
  // @@protoc_insertion_point(field_release:Monitor.creator)
  if (!_internal_has_creator()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = creator_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (creator_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    creator_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Monitor::set_allocated_creator(std::string* creator) {
  if (creator != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  creator_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), creator,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (creator_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    creator_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Monitor.creator)
}

// optional string built_time = 3;
inline bool Monitor::_internal_has_built_time() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Monitor::has_built_time() const {
  return _internal_has_built_time();
}
inline void Monitor::clear_built_time() {
  built_time_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Monitor::built_time() const {
  // @@protoc_insertion_point(field_get:Monitor.built_time)
  return _internal_built_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Monitor::set_built_time(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 built_time_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Monitor.built_time)
}
inline std::string* Monitor::mutable_built_time() {
  std::string* _s = _internal_mutable_built_time();
  // @@protoc_insertion_point(field_mutable:Monitor.built_time)
  return _s;
}
inline const std::string& Monitor::_internal_built_time() const {
  return built_time_.Get();
}
inline void Monitor::_internal_set_built_time(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  built_time_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Monitor::_internal_mutable_built_time() {
  _has_bits_[0] |= 0x00000004u;
  return built_time_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Monitor::release_built_time() {
  // @@protoc_insertion_point(field_release:Monitor.built_time)
  if (!_internal_has_built_time()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = built_time_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (built_time_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    built_time_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Monitor::set_allocated_built_time(std::string* built_time) {
  if (built_time != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  built_time_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), built_time,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (built_time_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    built_time_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Monitor.built_time)
}

// optional string triple_num = 4;
inline bool Monitor::_internal_has_triple_num() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Monitor::has_triple_num() const {
  return _internal_has_triple_num();
}
inline void Monitor::clear_triple_num() {
  triple_num_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& Monitor::triple_num() const {
  // @@protoc_insertion_point(field_get:Monitor.triple_num)
  return _internal_triple_num();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Monitor::set_triple_num(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 triple_num_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Monitor.triple_num)
}
inline std::string* Monitor::mutable_triple_num() {
  std::string* _s = _internal_mutable_triple_num();
  // @@protoc_insertion_point(field_mutable:Monitor.triple_num)
  return _s;
}
inline const std::string& Monitor::_internal_triple_num() const {
  return triple_num_.Get();
}
inline void Monitor::_internal_set_triple_num(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  triple_num_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Monitor::_internal_mutable_triple_num() {
  _has_bits_[0] |= 0x00000008u;
  return triple_num_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Monitor::release_triple_num() {
  // @@protoc_insertion_point(field_release:Monitor.triple_num)
  if (!_internal_has_triple_num()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = triple_num_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (triple_num_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    triple_num_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Monitor::set_allocated_triple_num(std::string* triple_num) {
  if (triple_num != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  triple_num_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), triple_num,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (triple_num_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    triple_num_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Monitor.triple_num)
}

// optional int32 entity_num = 5;
inline bool Monitor::_internal_has_entity_num() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Monitor::has_entity_num() const {
  return _internal_has_entity_num();
}
inline void Monitor::clear_entity_num() {
  entity_num_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline int32_t Monitor::_internal_entity_num() const {
  return entity_num_;
}
inline int32_t Monitor::entity_num() const {
  // @@protoc_insertion_point(field_get:Monitor.entity_num)
  return _internal_entity_num();
}
inline void Monitor::_internal_set_entity_num(int32_t value) {
  _has_bits_[0] |= 0x00000010u;
  entity_num_ = value;
}
inline void Monitor::set_entity_num(int32_t value) {
  _internal_set_entity_num(value);
  // @@protoc_insertion_point(field_set:Monitor.entity_num)
}

// optional int32 literal_num = 6;
inline bool Monitor::_internal_has_literal_num() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Monitor::has_literal_num() const {
  return _internal_has_literal_num();
}
inline void Monitor::clear_literal_num() {
  literal_num_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline int32_t Monitor::_internal_literal_num() const {
  return literal_num_;
}
inline int32_t Monitor::literal_num() const {
  // @@protoc_insertion_point(field_get:Monitor.literal_num)
  return _internal_literal_num();
}
inline void Monitor::_internal_set_literal_num(int32_t value) {
  _has_bits_[0] |= 0x00000020u;
  literal_num_ = value;
}
inline void Monitor::set_literal_num(int32_t value) {
  _internal_set_literal_num(value);
  // @@protoc_insertion_point(field_set:Monitor.literal_num)
}

// optional int32 subject_num = 7;
inline bool Monitor::_internal_has_subject_num() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Monitor::has_subject_num() const {
  return _internal_has_subject_num();
}
inline void Monitor::clear_subject_num() {
  subject_num_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline int32_t Monitor::_internal_subject_num() const {
  return subject_num_;
}
inline int32_t Monitor::subject_num() const {
  // @@protoc_insertion_point(field_get:Monitor.subject_num)
  return _internal_subject_num();
}
inline void Monitor::_internal_set_subject_num(int32_t value) {
  _has_bits_[0] |= 0x00000040u;
  subject_num_ = value;
}
inline void Monitor::set_subject_num(int32_t value) {
  _internal_set_subject_num(value);
  // @@protoc_insertion_point(field_set:Monitor.subject_num)
}

// optional int32 predicate_num = 8;
inline bool Monitor::_internal_has_predicate_num() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Monitor::has_predicate_num() const {
  return _internal_has_predicate_num();
}
inline void Monitor::clear_predicate_num() {
  predicate_num_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline int32_t Monitor::_internal_predicate_num() const {
  return predicate_num_;
}
inline int32_t Monitor::predicate_num() const {
  // @@protoc_insertion_point(field_get:Monitor.predicate_num)
  return _internal_predicate_num();
}
inline void Monitor::_internal_set_predicate_num(int32_t value) {
  _has_bits_[0] |= 0x00000080u;
  predicate_num_ = value;
}
inline void Monitor::set_predicate_num(int32_t value) {
  _internal_set_predicate_num(value);
  // @@protoc_insertion_point(field_set:Monitor.predicate_num)
}

// optional int32 connection_num = 9;
inline bool Monitor::_internal_has_connection_num() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Monitor::has_connection_num() const {
  return _internal_has_connection_num();
}
inline void Monitor::clear_connection_num() {
  connection_num_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline int32_t Monitor::_internal_connection_num() const {
  return connection_num_;
}
inline int32_t Monitor::connection_num() const {
  // @@protoc_insertion_point(field_get:Monitor.connection_num)
  return _internal_connection_num();
}
inline void Monitor::_internal_set_connection_num(int32_t value) {
  _has_bits_[0] |= 0x00000100u;
  connection_num_ = value;
}
inline void Monitor::set_connection_num(int32_t value) {
  _internal_set_connection_num(value);
  // @@protoc_insertion_point(field_set:Monitor.connection_num)
}

// -------------------------------------------------------------------

// UserInfo

// optional string username = 1;
inline bool UserInfo::_internal_has_username() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UserInfo::has_username() const {
  return _internal_has_username();
}
inline void UserInfo::clear_username() {
  username_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UserInfo::username() const {
  // @@protoc_insertion_point(field_get:UserInfo.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfo::set_username(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserInfo.username)
}
inline std::string* UserInfo::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:UserInfo.username)
  return _s;
}
inline const std::string& UserInfo::_internal_username() const {
  return username_.Get();
}
inline void UserInfo::_internal_set_username(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UserInfo::_internal_mutable_username() {
  _has_bits_[0] |= 0x00000001u;
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UserInfo::release_username() {
  // @@protoc_insertion_point(field_release:UserInfo.username)
  if (!_internal_has_username()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = username_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (username_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserInfo::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (username_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserInfo.username)
}

// optional string password = 2;
inline bool UserInfo::_internal_has_password() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UserInfo::has_password() const {
  return _internal_has_password();
}
inline void UserInfo::clear_password() {
  password_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& UserInfo::password() const {
  // @@protoc_insertion_point(field_get:UserInfo.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfo::set_password(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserInfo.password)
}
inline std::string* UserInfo::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:UserInfo.password)
  return _s;
}
inline const std::string& UserInfo::_internal_password() const {
  return password_.Get();
}
inline void UserInfo::_internal_set_password(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UserInfo::_internal_mutable_password() {
  _has_bits_[0] |= 0x00000002u;
  return password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UserInfo::release_password() {
  // @@protoc_insertion_point(field_release:UserInfo.password)
  if (!_internal_has_password()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = password_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (password_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserInfo::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (password_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserInfo.password)
}

// optional string query_privilege = 3;
inline bool UserInfo::_internal_has_query_privilege() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool UserInfo::has_query_privilege() const {
  return _internal_has_query_privilege();
}
inline void UserInfo::clear_query_privilege() {
  query_privilege_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& UserInfo::query_privilege() const {
  // @@protoc_insertion_point(field_get:UserInfo.query_privilege)
  return _internal_query_privilege();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfo::set_query_privilege(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 query_privilege_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserInfo.query_privilege)
}
inline std::string* UserInfo::mutable_query_privilege() {
  std::string* _s = _internal_mutable_query_privilege();
  // @@protoc_insertion_point(field_mutable:UserInfo.query_privilege)
  return _s;
}
inline const std::string& UserInfo::_internal_query_privilege() const {
  return query_privilege_.Get();
}
inline void UserInfo::_internal_set_query_privilege(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  query_privilege_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UserInfo::_internal_mutable_query_privilege() {
  _has_bits_[0] |= 0x00000004u;
  return query_privilege_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UserInfo::release_query_privilege() {
  // @@protoc_insertion_point(field_release:UserInfo.query_privilege)
  if (!_internal_has_query_privilege()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = query_privilege_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (query_privilege_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    query_privilege_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserInfo::set_allocated_query_privilege(std::string* query_privilege) {
  if (query_privilege != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  query_privilege_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), query_privilege,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (query_privilege_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    query_privilege_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserInfo.query_privilege)
}

// optional string update_privilege = 4;
inline bool UserInfo::_internal_has_update_privilege() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool UserInfo::has_update_privilege() const {
  return _internal_has_update_privilege();
}
inline void UserInfo::clear_update_privilege() {
  update_privilege_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& UserInfo::update_privilege() const {
  // @@protoc_insertion_point(field_get:UserInfo.update_privilege)
  return _internal_update_privilege();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfo::set_update_privilege(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 update_privilege_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserInfo.update_privilege)
}
inline std::string* UserInfo::mutable_update_privilege() {
  std::string* _s = _internal_mutable_update_privilege();
  // @@protoc_insertion_point(field_mutable:UserInfo.update_privilege)
  return _s;
}
inline const std::string& UserInfo::_internal_update_privilege() const {
  return update_privilege_.Get();
}
inline void UserInfo::_internal_set_update_privilege(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  update_privilege_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UserInfo::_internal_mutable_update_privilege() {
  _has_bits_[0] |= 0x00000008u;
  return update_privilege_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UserInfo::release_update_privilege() {
  // @@protoc_insertion_point(field_release:UserInfo.update_privilege)
  if (!_internal_has_update_privilege()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = update_privilege_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (update_privilege_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    update_privilege_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserInfo::set_allocated_update_privilege(std::string* update_privilege) {
  if (update_privilege != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  update_privilege_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), update_privilege,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (update_privilege_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    update_privilege_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserInfo.update_privilege)
}

// optional string load_privilege = 5;
inline bool UserInfo::_internal_has_load_privilege() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool UserInfo::has_load_privilege() const {
  return _internal_has_load_privilege();
}
inline void UserInfo::clear_load_privilege() {
  load_privilege_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& UserInfo::load_privilege() const {
  // @@protoc_insertion_point(field_get:UserInfo.load_privilege)
  return _internal_load_privilege();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfo::set_load_privilege(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 load_privilege_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserInfo.load_privilege)
}
inline std::string* UserInfo::mutable_load_privilege() {
  std::string* _s = _internal_mutable_load_privilege();
  // @@protoc_insertion_point(field_mutable:UserInfo.load_privilege)
  return _s;
}
inline const std::string& UserInfo::_internal_load_privilege() const {
  return load_privilege_.Get();
}
inline void UserInfo::_internal_set_load_privilege(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  load_privilege_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UserInfo::_internal_mutable_load_privilege() {
  _has_bits_[0] |= 0x00000010u;
  return load_privilege_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UserInfo::release_load_privilege() {
  // @@protoc_insertion_point(field_release:UserInfo.load_privilege)
  if (!_internal_has_load_privilege()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = load_privilege_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (load_privilege_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    load_privilege_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserInfo::set_allocated_load_privilege(std::string* load_privilege) {
  if (load_privilege != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  load_privilege_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), load_privilege,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (load_privilege_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    load_privilege_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserInfo.load_privilege)
}

// optional string unload_privilege = 6;
inline bool UserInfo::_internal_has_unload_privilege() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool UserInfo::has_unload_privilege() const {
  return _internal_has_unload_privilege();
}
inline void UserInfo::clear_unload_privilege() {
  unload_privilege_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& UserInfo::unload_privilege() const {
  // @@protoc_insertion_point(field_get:UserInfo.unload_privilege)
  return _internal_unload_privilege();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfo::set_unload_privilege(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 unload_privilege_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserInfo.unload_privilege)
}
inline std::string* UserInfo::mutable_unload_privilege() {
  std::string* _s = _internal_mutable_unload_privilege();
  // @@protoc_insertion_point(field_mutable:UserInfo.unload_privilege)
  return _s;
}
inline const std::string& UserInfo::_internal_unload_privilege() const {
  return unload_privilege_.Get();
}
inline void UserInfo::_internal_set_unload_privilege(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  unload_privilege_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UserInfo::_internal_mutable_unload_privilege() {
  _has_bits_[0] |= 0x00000020u;
  return unload_privilege_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UserInfo::release_unload_privilege() {
  // @@protoc_insertion_point(field_release:UserInfo.unload_privilege)
  if (!_internal_has_unload_privilege()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  auto* p = unload_privilege_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (unload_privilege_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    unload_privilege_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserInfo::set_allocated_unload_privilege(std::string* unload_privilege) {
  if (unload_privilege != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  unload_privilege_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), unload_privilege,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (unload_privilege_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    unload_privilege_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserInfo.unload_privilege)
}

// optional string backup_privilege = 7;
inline bool UserInfo::_internal_has_backup_privilege() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool UserInfo::has_backup_privilege() const {
  return _internal_has_backup_privilege();
}
inline void UserInfo::clear_backup_privilege() {
  backup_privilege_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& UserInfo::backup_privilege() const {
  // @@protoc_insertion_point(field_get:UserInfo.backup_privilege)
  return _internal_backup_privilege();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfo::set_backup_privilege(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000040u;
 backup_privilege_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserInfo.backup_privilege)
}
inline std::string* UserInfo::mutable_backup_privilege() {
  std::string* _s = _internal_mutable_backup_privilege();
  // @@protoc_insertion_point(field_mutable:UserInfo.backup_privilege)
  return _s;
}
inline const std::string& UserInfo::_internal_backup_privilege() const {
  return backup_privilege_.Get();
}
inline void UserInfo::_internal_set_backup_privilege(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  backup_privilege_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UserInfo::_internal_mutable_backup_privilege() {
  _has_bits_[0] |= 0x00000040u;
  return backup_privilege_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UserInfo::release_backup_privilege() {
  // @@protoc_insertion_point(field_release:UserInfo.backup_privilege)
  if (!_internal_has_backup_privilege()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  auto* p = backup_privilege_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (backup_privilege_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    backup_privilege_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserInfo::set_allocated_backup_privilege(std::string* backup_privilege) {
  if (backup_privilege != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  backup_privilege_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), backup_privilege,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (backup_privilege_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    backup_privilege_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserInfo.backup_privilege)
}

// optional string restore_privilege = 8;
inline bool UserInfo::_internal_has_restore_privilege() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool UserInfo::has_restore_privilege() const {
  return _internal_has_restore_privilege();
}
inline void UserInfo::clear_restore_privilege() {
  restore_privilege_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000080u;
}
inline const std::string& UserInfo::restore_privilege() const {
  // @@protoc_insertion_point(field_get:UserInfo.restore_privilege)
  return _internal_restore_privilege();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfo::set_restore_privilege(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000080u;
 restore_privilege_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserInfo.restore_privilege)
}
inline std::string* UserInfo::mutable_restore_privilege() {
  std::string* _s = _internal_mutable_restore_privilege();
  // @@protoc_insertion_point(field_mutable:UserInfo.restore_privilege)
  return _s;
}
inline const std::string& UserInfo::_internal_restore_privilege() const {
  return restore_privilege_.Get();
}
inline void UserInfo::_internal_set_restore_privilege(const std::string& value) {
  _has_bits_[0] |= 0x00000080u;
  restore_privilege_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UserInfo::_internal_mutable_restore_privilege() {
  _has_bits_[0] |= 0x00000080u;
  return restore_privilege_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UserInfo::release_restore_privilege() {
  // @@protoc_insertion_point(field_release:UserInfo.restore_privilege)
  if (!_internal_has_restore_privilege()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000080u;
  auto* p = restore_privilege_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (restore_privilege_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    restore_privilege_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserInfo::set_allocated_restore_privilege(std::string* restore_privilege) {
  if (restore_privilege != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  restore_privilege_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), restore_privilege,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (restore_privilege_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    restore_privilege_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserInfo.restore_privilege)
}

// optional string export_privilege = 9;
inline bool UserInfo::_internal_has_export_privilege() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool UserInfo::has_export_privilege() const {
  return _internal_has_export_privilege();
}
inline void UserInfo::clear_export_privilege() {
  export_privilege_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000100u;
}
inline const std::string& UserInfo::export_privilege() const {
  // @@protoc_insertion_point(field_get:UserInfo.export_privilege)
  return _internal_export_privilege();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfo::set_export_privilege(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000100u;
 export_privilege_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserInfo.export_privilege)
}
inline std::string* UserInfo::mutable_export_privilege() {
  std::string* _s = _internal_mutable_export_privilege();
  // @@protoc_insertion_point(field_mutable:UserInfo.export_privilege)
  return _s;
}
inline const std::string& UserInfo::_internal_export_privilege() const {
  return export_privilege_.Get();
}
inline void UserInfo::_internal_set_export_privilege(const std::string& value) {
  _has_bits_[0] |= 0x00000100u;
  export_privilege_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UserInfo::_internal_mutable_export_privilege() {
  _has_bits_[0] |= 0x00000100u;
  return export_privilege_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UserInfo::release_export_privilege() {
  // @@protoc_insertion_point(field_release:UserInfo.export_privilege)
  if (!_internal_has_export_privilege()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000100u;
  auto* p = export_privilege_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (export_privilege_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    export_privilege_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserInfo::set_allocated_export_privilege(std::string* export_privilege) {
  if (export_privilege != nullptr) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  export_privilege_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), export_privilege,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (export_privilege_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    export_privilege_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserInfo.export_privilege)
}

// -------------------------------------------------------------------

// DBInfo

// optional string database = 1;
inline bool DBInfo::_internal_has_database() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DBInfo::has_database() const {
  return _internal_has_database();
}
inline void DBInfo::clear_database() {
  database_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DBInfo::database() const {
  // @@protoc_insertion_point(field_get:DBInfo.database)
  return _internal_database();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DBInfo::set_database(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 database_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DBInfo.database)
}
inline std::string* DBInfo::mutable_database() {
  std::string* _s = _internal_mutable_database();
  // @@protoc_insertion_point(field_mutable:DBInfo.database)
  return _s;
}
inline const std::string& DBInfo::_internal_database() const {
  return database_.Get();
}
inline void DBInfo::_internal_set_database(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  database_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DBInfo::_internal_mutable_database() {
  _has_bits_[0] |= 0x00000001u;
  return database_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DBInfo::release_database() {
  // @@protoc_insertion_point(field_release:DBInfo.database)
  if (!_internal_has_database()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = database_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (database_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    database_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DBInfo::set_allocated_database(std::string* database) {
  if (database != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  database_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), database,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (database_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    database_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DBInfo.database)
}

// optional string creator = 2;
inline bool DBInfo::_internal_has_creator() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DBInfo::has_creator() const {
  return _internal_has_creator();
}
inline void DBInfo::clear_creator() {
  creator_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DBInfo::creator() const {
  // @@protoc_insertion_point(field_get:DBInfo.creator)
  return _internal_creator();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DBInfo::set_creator(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 creator_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DBInfo.creator)
}
inline std::string* DBInfo::mutable_creator() {
  std::string* _s = _internal_mutable_creator();
  // @@protoc_insertion_point(field_mutable:DBInfo.creator)
  return _s;
}
inline const std::string& DBInfo::_internal_creator() const {
  return creator_.Get();
}
inline void DBInfo::_internal_set_creator(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  creator_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DBInfo::_internal_mutable_creator() {
  _has_bits_[0] |= 0x00000002u;
  return creator_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DBInfo::release_creator() {
  // @@protoc_insertion_point(field_release:DBInfo.creator)
  if (!_internal_has_creator()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = creator_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (creator_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    creator_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DBInfo::set_allocated_creator(std::string* creator) {
  if (creator != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  creator_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), creator,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (creator_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    creator_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DBInfo.creator)
}

// optional string built_time = 3;
inline bool DBInfo::_internal_has_built_time() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DBInfo::has_built_time() const {
  return _internal_has_built_time();
}
inline void DBInfo::clear_built_time() {
  built_time_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& DBInfo::built_time() const {
  // @@protoc_insertion_point(field_get:DBInfo.built_time)
  return _internal_built_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DBInfo::set_built_time(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 built_time_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DBInfo.built_time)
}
inline std::string* DBInfo::mutable_built_time() {
  std::string* _s = _internal_mutable_built_time();
  // @@protoc_insertion_point(field_mutable:DBInfo.built_time)
  return _s;
}
inline const std::string& DBInfo::_internal_built_time() const {
  return built_time_.Get();
}
inline void DBInfo::_internal_set_built_time(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  built_time_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DBInfo::_internal_mutable_built_time() {
  _has_bits_[0] |= 0x00000004u;
  return built_time_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DBInfo::release_built_time() {
  // @@protoc_insertion_point(field_release:DBInfo.built_time)
  if (!_internal_has_built_time()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = built_time_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (built_time_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    built_time_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DBInfo::set_allocated_built_time(std::string* built_time) {
  if (built_time != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  built_time_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), built_time,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (built_time_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    built_time_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DBInfo.built_time)
}

// optional string status = 4;
inline bool DBInfo::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DBInfo::has_status() const {
  return _internal_has_status();
}
inline void DBInfo::clear_status() {
  status_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& DBInfo::status() const {
  // @@protoc_insertion_point(field_get:DBInfo.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DBInfo::set_status(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DBInfo.status)
}
inline std::string* DBInfo::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:DBInfo.status)
  return _s;
}
inline const std::string& DBInfo::_internal_status() const {
  return status_.Get();
}
inline void DBInfo::_internal_set_status(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DBInfo::_internal_mutable_status() {
  _has_bits_[0] |= 0x00000008u;
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DBInfo::release_status() {
  // @@protoc_insertion_point(field_release:DBInfo.status)
  if (!_internal_has_status()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = status_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (status_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    status_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DBInfo::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (status_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    status_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DBInfo.status)
}

// -------------------------------------------------------------------

// QueryHeadInfo

// repeated string link = 1;
inline int QueryHeadInfo::_internal_link_size() const {
  return link_.size();
}
inline int QueryHeadInfo::link_size() const {
  return _internal_link_size();
}
inline void QueryHeadInfo::clear_link() {
  link_.Clear();
}
inline std::string* QueryHeadInfo::add_link() {
  std::string* _s = _internal_add_link();
  // @@protoc_insertion_point(field_add_mutable:QueryHeadInfo.link)
  return _s;
}
inline const std::string& QueryHeadInfo::_internal_link(int index) const {
  return link_.Get(index);
}
inline const std::string& QueryHeadInfo::link(int index) const {
  // @@protoc_insertion_point(field_get:QueryHeadInfo.link)
  return _internal_link(index);
}
inline std::string* QueryHeadInfo::mutable_link(int index) {
  // @@protoc_insertion_point(field_mutable:QueryHeadInfo.link)
  return link_.Mutable(index);
}
inline void QueryHeadInfo::set_link(int index, const std::string& value) {
  link_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:QueryHeadInfo.link)
}
inline void QueryHeadInfo::set_link(int index, std::string&& value) {
  link_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:QueryHeadInfo.link)
}
inline void QueryHeadInfo::set_link(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  link_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:QueryHeadInfo.link)
}
inline void QueryHeadInfo::set_link(int index, const char* value, size_t size) {
  link_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QueryHeadInfo.link)
}
inline std::string* QueryHeadInfo::_internal_add_link() {
  return link_.Add();
}
inline void QueryHeadInfo::add_link(const std::string& value) {
  link_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:QueryHeadInfo.link)
}
inline void QueryHeadInfo::add_link(std::string&& value) {
  link_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:QueryHeadInfo.link)
}
inline void QueryHeadInfo::add_link(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  link_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:QueryHeadInfo.link)
}
inline void QueryHeadInfo::add_link(const char* value, size_t size) {
  link_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:QueryHeadInfo.link)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
QueryHeadInfo::link() const {
  // @@protoc_insertion_point(field_list:QueryHeadInfo.link)
  return link_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
QueryHeadInfo::mutable_link() {
  // @@protoc_insertion_point(field_mutable_list:QueryHeadInfo.link)
  return &link_;
}

// repeated string vars = 2;
inline int QueryHeadInfo::_internal_vars_size() const {
  return vars_.size();
}
inline int QueryHeadInfo::vars_size() const {
  return _internal_vars_size();
}
inline void QueryHeadInfo::clear_vars() {
  vars_.Clear();
}
inline std::string* QueryHeadInfo::add_vars() {
  std::string* _s = _internal_add_vars();
  // @@protoc_insertion_point(field_add_mutable:QueryHeadInfo.vars)
  return _s;
}
inline const std::string& QueryHeadInfo::_internal_vars(int index) const {
  return vars_.Get(index);
}
inline const std::string& QueryHeadInfo::vars(int index) const {
  // @@protoc_insertion_point(field_get:QueryHeadInfo.vars)
  return _internal_vars(index);
}
inline std::string* QueryHeadInfo::mutable_vars(int index) {
  // @@protoc_insertion_point(field_mutable:QueryHeadInfo.vars)
  return vars_.Mutable(index);
}
inline void QueryHeadInfo::set_vars(int index, const std::string& value) {
  vars_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:QueryHeadInfo.vars)
}
inline void QueryHeadInfo::set_vars(int index, std::string&& value) {
  vars_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:QueryHeadInfo.vars)
}
inline void QueryHeadInfo::set_vars(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  vars_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:QueryHeadInfo.vars)
}
inline void QueryHeadInfo::set_vars(int index, const char* value, size_t size) {
  vars_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QueryHeadInfo.vars)
}
inline std::string* QueryHeadInfo::_internal_add_vars() {
  return vars_.Add();
}
inline void QueryHeadInfo::add_vars(const std::string& value) {
  vars_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:QueryHeadInfo.vars)
}
inline void QueryHeadInfo::add_vars(std::string&& value) {
  vars_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:QueryHeadInfo.vars)
}
inline void QueryHeadInfo::add_vars(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  vars_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:QueryHeadInfo.vars)
}
inline void QueryHeadInfo::add_vars(const char* value, size_t size) {
  vars_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:QueryHeadInfo.vars)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
QueryHeadInfo::vars() const {
  // @@protoc_insertion_point(field_list:QueryHeadInfo.vars)
  return vars_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
QueryHeadInfo::mutable_vars() {
  // @@protoc_insertion_point(field_mutable_list:QueryHeadInfo.vars)
  return &vars_;
}

// -------------------------------------------------------------------

// QueryResultInfo

// repeated string bindings = 1;
inline int QueryResultInfo::_internal_bindings_size() const {
  return bindings_.size();
}
inline int QueryResultInfo::bindings_size() const {
  return _internal_bindings_size();
}
inline void QueryResultInfo::clear_bindings() {
  bindings_.Clear();
}
inline std::string* QueryResultInfo::add_bindings() {
  std::string* _s = _internal_add_bindings();
  // @@protoc_insertion_point(field_add_mutable:QueryResultInfo.bindings)
  return _s;
}
inline const std::string& QueryResultInfo::_internal_bindings(int index) const {
  return bindings_.Get(index);
}
inline const std::string& QueryResultInfo::bindings(int index) const {
  // @@protoc_insertion_point(field_get:QueryResultInfo.bindings)
  return _internal_bindings(index);
}
inline std::string* QueryResultInfo::mutable_bindings(int index) {
  // @@protoc_insertion_point(field_mutable:QueryResultInfo.bindings)
  return bindings_.Mutable(index);
}
inline void QueryResultInfo::set_bindings(int index, const std::string& value) {
  bindings_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:QueryResultInfo.bindings)
}
inline void QueryResultInfo::set_bindings(int index, std::string&& value) {
  bindings_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:QueryResultInfo.bindings)
}
inline void QueryResultInfo::set_bindings(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  bindings_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:QueryResultInfo.bindings)
}
inline void QueryResultInfo::set_bindings(int index, const char* value, size_t size) {
  bindings_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QueryResultInfo.bindings)
}
inline std::string* QueryResultInfo::_internal_add_bindings() {
  return bindings_.Add();
}
inline void QueryResultInfo::add_bindings(const std::string& value) {
  bindings_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:QueryResultInfo.bindings)
}
inline void QueryResultInfo::add_bindings(std::string&& value) {
  bindings_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:QueryResultInfo.bindings)
}
inline void QueryResultInfo::add_bindings(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  bindings_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:QueryResultInfo.bindings)
}
inline void QueryResultInfo::add_bindings(const char* value, size_t size) {
  bindings_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:QueryResultInfo.bindings)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
QueryResultInfo::bindings() const {
  // @@protoc_insertion_point(field_list:QueryResultInfo.bindings)
  return bindings_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
QueryResultInfo::mutable_bindings() {
  // @@protoc_insertion_point(field_mutable_list:QueryResultInfo.bindings)
  return &bindings_;
}

// -------------------------------------------------------------------

// TxnLogInfo

// optional string db_name = 1;
inline bool TxnLogInfo::_internal_has_db_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TxnLogInfo::has_db_name() const {
  return _internal_has_db_name();
}
inline void TxnLogInfo::clear_db_name() {
  db_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TxnLogInfo::db_name() const {
  // @@protoc_insertion_point(field_get:TxnLogInfo.db_name)
  return _internal_db_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TxnLogInfo::set_db_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 db_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TxnLogInfo.db_name)
}
inline std::string* TxnLogInfo::mutable_db_name() {
  std::string* _s = _internal_mutable_db_name();
  // @@protoc_insertion_point(field_mutable:TxnLogInfo.db_name)
  return _s;
}
inline const std::string& TxnLogInfo::_internal_db_name() const {
  return db_name_.Get();
}
inline void TxnLogInfo::_internal_set_db_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  db_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TxnLogInfo::_internal_mutable_db_name() {
  _has_bits_[0] |= 0x00000001u;
  return db_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TxnLogInfo::release_db_name() {
  // @@protoc_insertion_point(field_release:TxnLogInfo.db_name)
  if (!_internal_has_db_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = db_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (db_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    db_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TxnLogInfo::set_allocated_db_name(std::string* db_name) {
  if (db_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  db_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), db_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (db_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    db_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TxnLogInfo.db_name)
}

// optional string TID = 2;
inline bool TxnLogInfo::_internal_has_tid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TxnLogInfo::has_tid() const {
  return _internal_has_tid();
}
inline void TxnLogInfo::clear_tid() {
  tid_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TxnLogInfo::tid() const {
  // @@protoc_insertion_point(field_get:TxnLogInfo.TID)
  return _internal_tid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TxnLogInfo::set_tid(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 tid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TxnLogInfo.TID)
}
inline std::string* TxnLogInfo::mutable_tid() {
  std::string* _s = _internal_mutable_tid();
  // @@protoc_insertion_point(field_mutable:TxnLogInfo.TID)
  return _s;
}
inline const std::string& TxnLogInfo::_internal_tid() const {
  return tid_.Get();
}
inline void TxnLogInfo::_internal_set_tid(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  tid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TxnLogInfo::_internal_mutable_tid() {
  _has_bits_[0] |= 0x00000002u;
  return tid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TxnLogInfo::release_tid() {
  // @@protoc_insertion_point(field_release:TxnLogInfo.TID)
  if (!_internal_has_tid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = tid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    tid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TxnLogInfo::set_allocated_tid(std::string* tid) {
  if (tid != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  tid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    tid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TxnLogInfo.TID)
}

// optional string user = 3;
inline bool TxnLogInfo::_internal_has_user() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TxnLogInfo::has_user() const {
  return _internal_has_user();
}
inline void TxnLogInfo::clear_user() {
  user_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& TxnLogInfo::user() const {
  // @@protoc_insertion_point(field_get:TxnLogInfo.user)
  return _internal_user();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TxnLogInfo::set_user(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 user_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TxnLogInfo.user)
}
inline std::string* TxnLogInfo::mutable_user() {
  std::string* _s = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:TxnLogInfo.user)
  return _s;
}
inline const std::string& TxnLogInfo::_internal_user() const {
  return user_.Get();
}
inline void TxnLogInfo::_internal_set_user(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  user_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TxnLogInfo::_internal_mutable_user() {
  _has_bits_[0] |= 0x00000004u;
  return user_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TxnLogInfo::release_user() {
  // @@protoc_insertion_point(field_release:TxnLogInfo.user)
  if (!_internal_has_user()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = user_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TxnLogInfo::set_allocated_user(std::string* user) {
  if (user != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  user_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TxnLogInfo.user)
}

// optional string begin_time = 4;
inline bool TxnLogInfo::_internal_has_begin_time() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TxnLogInfo::has_begin_time() const {
  return _internal_has_begin_time();
}
inline void TxnLogInfo::clear_begin_time() {
  begin_time_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& TxnLogInfo::begin_time() const {
  // @@protoc_insertion_point(field_get:TxnLogInfo.begin_time)
  return _internal_begin_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TxnLogInfo::set_begin_time(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 begin_time_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TxnLogInfo.begin_time)
}
inline std::string* TxnLogInfo::mutable_begin_time() {
  std::string* _s = _internal_mutable_begin_time();
  // @@protoc_insertion_point(field_mutable:TxnLogInfo.begin_time)
  return _s;
}
inline const std::string& TxnLogInfo::_internal_begin_time() const {
  return begin_time_.Get();
}
inline void TxnLogInfo::_internal_set_begin_time(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  begin_time_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TxnLogInfo::_internal_mutable_begin_time() {
  _has_bits_[0] |= 0x00000008u;
  return begin_time_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TxnLogInfo::release_begin_time() {
  // @@protoc_insertion_point(field_release:TxnLogInfo.begin_time)
  if (!_internal_has_begin_time()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = begin_time_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (begin_time_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    begin_time_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TxnLogInfo::set_allocated_begin_time(std::string* begin_time) {
  if (begin_time != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  begin_time_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), begin_time,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (begin_time_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    begin_time_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TxnLogInfo.begin_time)
}

// optional string state = 5;
inline bool TxnLogInfo::_internal_has_state() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TxnLogInfo::has_state() const {
  return _internal_has_state();
}
inline void TxnLogInfo::clear_state() {
  state_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& TxnLogInfo::state() const {
  // @@protoc_insertion_point(field_get:TxnLogInfo.state)
  return _internal_state();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TxnLogInfo::set_state(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 state_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TxnLogInfo.state)
}
inline std::string* TxnLogInfo::mutable_state() {
  std::string* _s = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:TxnLogInfo.state)
  return _s;
}
inline const std::string& TxnLogInfo::_internal_state() const {
  return state_.Get();
}
inline void TxnLogInfo::_internal_set_state(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  state_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TxnLogInfo::_internal_mutable_state() {
  _has_bits_[0] |= 0x00000010u;
  return state_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TxnLogInfo::release_state() {
  // @@protoc_insertion_point(field_release:TxnLogInfo.state)
  if (!_internal_has_state()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = state_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (state_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    state_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TxnLogInfo::set_allocated_state(std::string* state) {
  if (state != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  state_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), state,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (state_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    state_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TxnLogInfo.state)
}

// optional string end_time = 6;
inline bool TxnLogInfo::_internal_has_end_time() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TxnLogInfo::has_end_time() const {
  return _internal_has_end_time();
}
inline void TxnLogInfo::clear_end_time() {
  end_time_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& TxnLogInfo::end_time() const {
  // @@protoc_insertion_point(field_get:TxnLogInfo.end_time)
  return _internal_end_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TxnLogInfo::set_end_time(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 end_time_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TxnLogInfo.end_time)
}
inline std::string* TxnLogInfo::mutable_end_time() {
  std::string* _s = _internal_mutable_end_time();
  // @@protoc_insertion_point(field_mutable:TxnLogInfo.end_time)
  return _s;
}
inline const std::string& TxnLogInfo::_internal_end_time() const {
  return end_time_.Get();
}
inline void TxnLogInfo::_internal_set_end_time(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  end_time_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TxnLogInfo::_internal_mutable_end_time() {
  _has_bits_[0] |= 0x00000020u;
  return end_time_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TxnLogInfo::release_end_time() {
  // @@protoc_insertion_point(field_release:TxnLogInfo.end_time)
  if (!_internal_has_end_time()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  auto* p = end_time_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (end_time_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    end_time_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TxnLogInfo::set_allocated_end_time(std::string* end_time) {
  if (end_time != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  end_time_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), end_time,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (end_time_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    end_time_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TxnLogInfo.end_time)
}

// -------------------------------------------------------------------

// QueryLogInfo

// optional string QueryDateTime = 1;
inline bool QueryLogInfo::_internal_has_querydatetime() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool QueryLogInfo::has_querydatetime() const {
  return _internal_has_querydatetime();
}
inline void QueryLogInfo::clear_querydatetime() {
  querydatetime_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& QueryLogInfo::querydatetime() const {
  // @@protoc_insertion_point(field_get:QueryLogInfo.QueryDateTime)
  return _internal_querydatetime();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryLogInfo::set_querydatetime(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 querydatetime_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:QueryLogInfo.QueryDateTime)
}
inline std::string* QueryLogInfo::mutable_querydatetime() {
  std::string* _s = _internal_mutable_querydatetime();
  // @@protoc_insertion_point(field_mutable:QueryLogInfo.QueryDateTime)
  return _s;
}
inline const std::string& QueryLogInfo::_internal_querydatetime() const {
  return querydatetime_.Get();
}
inline void QueryLogInfo::_internal_set_querydatetime(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  querydatetime_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryLogInfo::_internal_mutable_querydatetime() {
  _has_bits_[0] |= 0x00000001u;
  return querydatetime_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryLogInfo::release_querydatetime() {
  // @@protoc_insertion_point(field_release:QueryLogInfo.QueryDateTime)
  if (!_internal_has_querydatetime()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = querydatetime_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (querydatetime_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    querydatetime_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void QueryLogInfo::set_allocated_querydatetime(std::string* querydatetime) {
  if (querydatetime != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  querydatetime_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), querydatetime,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (querydatetime_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    querydatetime_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:QueryLogInfo.QueryDateTime)
}

// optional string Sparql = 2;
inline bool QueryLogInfo::_internal_has_sparql() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool QueryLogInfo::has_sparql() const {
  return _internal_has_sparql();
}
inline void QueryLogInfo::clear_sparql() {
  sparql_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& QueryLogInfo::sparql() const {
  // @@protoc_insertion_point(field_get:QueryLogInfo.Sparql)
  return _internal_sparql();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryLogInfo::set_sparql(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 sparql_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:QueryLogInfo.Sparql)
}
inline std::string* QueryLogInfo::mutable_sparql() {
  std::string* _s = _internal_mutable_sparql();
  // @@protoc_insertion_point(field_mutable:QueryLogInfo.Sparql)
  return _s;
}
inline const std::string& QueryLogInfo::_internal_sparql() const {
  return sparql_.Get();
}
inline void QueryLogInfo::_internal_set_sparql(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  sparql_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryLogInfo::_internal_mutable_sparql() {
  _has_bits_[0] |= 0x00000002u;
  return sparql_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryLogInfo::release_sparql() {
  // @@protoc_insertion_point(field_release:QueryLogInfo.Sparql)
  if (!_internal_has_sparql()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = sparql_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sparql_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sparql_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void QueryLogInfo::set_allocated_sparql(std::string* sparql) {
  if (sparql != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  sparql_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sparql,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sparql_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sparql_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:QueryLogInfo.Sparql)
}

// optional string Format = 3;
inline bool QueryLogInfo::_internal_has_format() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool QueryLogInfo::has_format() const {
  return _internal_has_format();
}
inline void QueryLogInfo::clear_format() {
  format_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& QueryLogInfo::format() const {
  // @@protoc_insertion_point(field_get:QueryLogInfo.Format)
  return _internal_format();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryLogInfo::set_format(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 format_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:QueryLogInfo.Format)
}
inline std::string* QueryLogInfo::mutable_format() {
  std::string* _s = _internal_mutable_format();
  // @@protoc_insertion_point(field_mutable:QueryLogInfo.Format)
  return _s;
}
inline const std::string& QueryLogInfo::_internal_format() const {
  return format_.Get();
}
inline void QueryLogInfo::_internal_set_format(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  format_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryLogInfo::_internal_mutable_format() {
  _has_bits_[0] |= 0x00000004u;
  return format_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryLogInfo::release_format() {
  // @@protoc_insertion_point(field_release:QueryLogInfo.Format)
  if (!_internal_has_format()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = format_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (format_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    format_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void QueryLogInfo::set_allocated_format(std::string* format) {
  if (format != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  format_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), format,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (format_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    format_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:QueryLogInfo.Format)
}

// optional string RemoteIP = 4;
inline bool QueryLogInfo::_internal_has_remoteip() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool QueryLogInfo::has_remoteip() const {
  return _internal_has_remoteip();
}
inline void QueryLogInfo::clear_remoteip() {
  remoteip_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& QueryLogInfo::remoteip() const {
  // @@protoc_insertion_point(field_get:QueryLogInfo.RemoteIP)
  return _internal_remoteip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryLogInfo::set_remoteip(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 remoteip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:QueryLogInfo.RemoteIP)
}
inline std::string* QueryLogInfo::mutable_remoteip() {
  std::string* _s = _internal_mutable_remoteip();
  // @@protoc_insertion_point(field_mutable:QueryLogInfo.RemoteIP)
  return _s;
}
inline const std::string& QueryLogInfo::_internal_remoteip() const {
  return remoteip_.Get();
}
inline void QueryLogInfo::_internal_set_remoteip(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  remoteip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryLogInfo::_internal_mutable_remoteip() {
  _has_bits_[0] |= 0x00000008u;
  return remoteip_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryLogInfo::release_remoteip() {
  // @@protoc_insertion_point(field_release:QueryLogInfo.RemoteIP)
  if (!_internal_has_remoteip()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = remoteip_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (remoteip_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    remoteip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void QueryLogInfo::set_allocated_remoteip(std::string* remoteip) {
  if (remoteip != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  remoteip_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), remoteip,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (remoteip_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    remoteip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:QueryLogInfo.RemoteIP)
}

// optional string FileName = 5;
inline bool QueryLogInfo::_internal_has_filename() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool QueryLogInfo::has_filename() const {
  return _internal_has_filename();
}
inline void QueryLogInfo::clear_filename() {
  filename_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& QueryLogInfo::filename() const {
  // @@protoc_insertion_point(field_get:QueryLogInfo.FileName)
  return _internal_filename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryLogInfo::set_filename(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 filename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:QueryLogInfo.FileName)
}
inline std::string* QueryLogInfo::mutable_filename() {
  std::string* _s = _internal_mutable_filename();
  // @@protoc_insertion_point(field_mutable:QueryLogInfo.FileName)
  return _s;
}
inline const std::string& QueryLogInfo::_internal_filename() const {
  return filename_.Get();
}
inline void QueryLogInfo::_internal_set_filename(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  filename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryLogInfo::_internal_mutable_filename() {
  _has_bits_[0] |= 0x00000010u;
  return filename_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryLogInfo::release_filename() {
  // @@protoc_insertion_point(field_release:QueryLogInfo.FileName)
  if (!_internal_has_filename()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = filename_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (filename_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    filename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void QueryLogInfo::set_allocated_filename(std::string* filename) {
  if (filename != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  filename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), filename,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (filename_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    filename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:QueryLogInfo.FileName)
}

// optional int32 QueryTime = 6;
inline bool QueryLogInfo::_internal_has_querytime() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool QueryLogInfo::has_querytime() const {
  return _internal_has_querytime();
}
inline void QueryLogInfo::clear_querytime() {
  querytime_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline int32_t QueryLogInfo::_internal_querytime() const {
  return querytime_;
}
inline int32_t QueryLogInfo::querytime() const {
  // @@protoc_insertion_point(field_get:QueryLogInfo.QueryTime)
  return _internal_querytime();
}
inline void QueryLogInfo::_internal_set_querytime(int32_t value) {
  _has_bits_[0] |= 0x00000020u;
  querytime_ = value;
}
inline void QueryLogInfo::set_querytime(int32_t value) {
  _internal_set_querytime(value);
  // @@protoc_insertion_point(field_set:QueryLogInfo.QueryTime)
}

// optional int32 AnsNum = 7;
inline bool QueryLogInfo::_internal_has_ansnum() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool QueryLogInfo::has_ansnum() const {
  return _internal_has_ansnum();
}
inline void QueryLogInfo::clear_ansnum() {
  ansnum_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline int32_t QueryLogInfo::_internal_ansnum() const {
  return ansnum_;
}
inline int32_t QueryLogInfo::ansnum() const {
  // @@protoc_insertion_point(field_get:QueryLogInfo.AnsNum)
  return _internal_ansnum();
}
inline void QueryLogInfo::_internal_set_ansnum(int32_t value) {
  _has_bits_[0] |= 0x00000040u;
  ansnum_ = value;
}
inline void QueryLogInfo::set_ansnum(int32_t value) {
  _internal_set_ansnum(value);
  // @@protoc_insertion_point(field_set:QueryLogInfo.AnsNum)
}

// -------------------------------------------------------------------

// AccessLogInfo

// optional string ip = 1;
inline bool AccessLogInfo::_internal_has_ip() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AccessLogInfo::has_ip() const {
  return _internal_has_ip();
}
inline void AccessLogInfo::clear_ip() {
  ip_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AccessLogInfo::ip() const {
  // @@protoc_insertion_point(field_get:AccessLogInfo.ip)
  return _internal_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccessLogInfo::set_ip(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:AccessLogInfo.ip)
}
inline std::string* AccessLogInfo::mutable_ip() {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:AccessLogInfo.ip)
  return _s;
}
inline const std::string& AccessLogInfo::_internal_ip() const {
  return ip_.Get();
}
inline void AccessLogInfo::_internal_set_ip(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AccessLogInfo::_internal_mutable_ip() {
  _has_bits_[0] |= 0x00000001u;
  return ip_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AccessLogInfo::release_ip() {
  // @@protoc_insertion_point(field_release:AccessLogInfo.ip)
  if (!_internal_has_ip()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = ip_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ip_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AccessLogInfo::set_allocated_ip(std::string* ip) {
  if (ip != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  ip_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ip_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:AccessLogInfo.ip)
}

// optional string operation = 2;
inline bool AccessLogInfo::_internal_has_operation() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AccessLogInfo::has_operation() const {
  return _internal_has_operation();
}
inline void AccessLogInfo::clear_operation() {
  operation_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AccessLogInfo::operation() const {
  // @@protoc_insertion_point(field_get:AccessLogInfo.operation)
  return _internal_operation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccessLogInfo::set_operation(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 operation_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:AccessLogInfo.operation)
}
inline std::string* AccessLogInfo::mutable_operation() {
  std::string* _s = _internal_mutable_operation();
  // @@protoc_insertion_point(field_mutable:AccessLogInfo.operation)
  return _s;
}
inline const std::string& AccessLogInfo::_internal_operation() const {
  return operation_.Get();
}
inline void AccessLogInfo::_internal_set_operation(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  operation_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AccessLogInfo::_internal_mutable_operation() {
  _has_bits_[0] |= 0x00000002u;
  return operation_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AccessLogInfo::release_operation() {
  // @@protoc_insertion_point(field_release:AccessLogInfo.operation)
  if (!_internal_has_operation()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = operation_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (operation_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    operation_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AccessLogInfo::set_allocated_operation(std::string* operation) {
  if (operation != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  operation_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), operation,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (operation_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    operation_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:AccessLogInfo.operation)
}

// optional string createtime = 3;
inline bool AccessLogInfo::_internal_has_createtime() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AccessLogInfo::has_createtime() const {
  return _internal_has_createtime();
}
inline void AccessLogInfo::clear_createtime() {
  createtime_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& AccessLogInfo::createtime() const {
  // @@protoc_insertion_point(field_get:AccessLogInfo.createtime)
  return _internal_createtime();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccessLogInfo::set_createtime(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 createtime_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:AccessLogInfo.createtime)
}
inline std::string* AccessLogInfo::mutable_createtime() {
  std::string* _s = _internal_mutable_createtime();
  // @@protoc_insertion_point(field_mutable:AccessLogInfo.createtime)
  return _s;
}
inline const std::string& AccessLogInfo::_internal_createtime() const {
  return createtime_.Get();
}
inline void AccessLogInfo::_internal_set_createtime(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  createtime_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AccessLogInfo::_internal_mutable_createtime() {
  _has_bits_[0] |= 0x00000004u;
  return createtime_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AccessLogInfo::release_createtime() {
  // @@protoc_insertion_point(field_release:AccessLogInfo.createtime)
  if (!_internal_has_createtime()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = createtime_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (createtime_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    createtime_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AccessLogInfo::set_allocated_createtime(std::string* createtime) {
  if (createtime != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  createtime_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), createtime,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (createtime_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    createtime_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:AccessLogInfo.createtime)
}

// optional int32 code = 4;
inline bool AccessLogInfo::_internal_has_code() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool AccessLogInfo::has_code() const {
  return _internal_has_code();
}
inline void AccessLogInfo::clear_code() {
  code_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline int32_t AccessLogInfo::_internal_code() const {
  return code_;
}
inline int32_t AccessLogInfo::code() const {
  // @@protoc_insertion_point(field_get:AccessLogInfo.code)
  return _internal_code();
}
inline void AccessLogInfo::_internal_set_code(int32_t value) {
  _has_bits_[0] |= 0x00000010u;
  code_ = value;
}
inline void AccessLogInfo::set_code(int32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:AccessLogInfo.code)
}

// optional string msg = 5;
inline bool AccessLogInfo::_internal_has_msg() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool AccessLogInfo::has_msg() const {
  return _internal_has_msg();
}
inline void AccessLogInfo::clear_msg() {
  msg_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& AccessLogInfo::msg() const {
  // @@protoc_insertion_point(field_get:AccessLogInfo.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccessLogInfo::set_msg(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:AccessLogInfo.msg)
}
inline std::string* AccessLogInfo::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:AccessLogInfo.msg)
  return _s;
}
inline const std::string& AccessLogInfo::_internal_msg() const {
  return msg_.Get();
}
inline void AccessLogInfo::_internal_set_msg(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AccessLogInfo::_internal_mutable_msg() {
  _has_bits_[0] |= 0x00000008u;
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AccessLogInfo::release_msg() {
  // @@protoc_insertion_point(field_release:AccessLogInfo.msg)
  if (!_internal_has_msg()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = msg_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (msg_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    msg_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AccessLogInfo::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (msg_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    msg_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:AccessLogInfo.msg)
}

// -------------------------------------------------------------------

// IPManageInfo

// optional string ip_type = 1;
inline bool IPManageInfo::_internal_has_ip_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool IPManageInfo::has_ip_type() const {
  return _internal_has_ip_type();
}
inline void IPManageInfo::clear_ip_type() {
  ip_type_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& IPManageInfo::ip_type() const {
  // @@protoc_insertion_point(field_get:IPManageInfo.ip_type)
  return _internal_ip_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IPManageInfo::set_ip_type(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 ip_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IPManageInfo.ip_type)
}
inline std::string* IPManageInfo::mutable_ip_type() {
  std::string* _s = _internal_mutable_ip_type();
  // @@protoc_insertion_point(field_mutable:IPManageInfo.ip_type)
  return _s;
}
inline const std::string& IPManageInfo::_internal_ip_type() const {
  return ip_type_.Get();
}
inline void IPManageInfo::_internal_set_ip_type(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  ip_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* IPManageInfo::_internal_mutable_ip_type() {
  _has_bits_[0] |= 0x00000001u;
  return ip_type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* IPManageInfo::release_ip_type() {
  // @@protoc_insertion_point(field_release:IPManageInfo.ip_type)
  if (!_internal_has_ip_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = ip_type_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ip_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ip_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void IPManageInfo::set_allocated_ip_type(std::string* ip_type) {
  if (ip_type != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  ip_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip_type,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ip_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ip_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IPManageInfo.ip_type)
}

// repeated string ips = 2;
inline int IPManageInfo::_internal_ips_size() const {
  return ips_.size();
}
inline int IPManageInfo::ips_size() const {
  return _internal_ips_size();
}
inline void IPManageInfo::clear_ips() {
  ips_.Clear();
}
inline std::string* IPManageInfo::add_ips() {
  std::string* _s = _internal_add_ips();
  // @@protoc_insertion_point(field_add_mutable:IPManageInfo.ips)
  return _s;
}
inline const std::string& IPManageInfo::_internal_ips(int index) const {
  return ips_.Get(index);
}
inline const std::string& IPManageInfo::ips(int index) const {
  // @@protoc_insertion_point(field_get:IPManageInfo.ips)
  return _internal_ips(index);
}
inline std::string* IPManageInfo::mutable_ips(int index) {
  // @@protoc_insertion_point(field_mutable:IPManageInfo.ips)
  return ips_.Mutable(index);
}
inline void IPManageInfo::set_ips(int index, const std::string& value) {
  ips_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:IPManageInfo.ips)
}
inline void IPManageInfo::set_ips(int index, std::string&& value) {
  ips_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:IPManageInfo.ips)
}
inline void IPManageInfo::set_ips(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  ips_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:IPManageInfo.ips)
}
inline void IPManageInfo::set_ips(int index, const char* value, size_t size) {
  ips_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IPManageInfo.ips)
}
inline std::string* IPManageInfo::_internal_add_ips() {
  return ips_.Add();
}
inline void IPManageInfo::add_ips(const std::string& value) {
  ips_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:IPManageInfo.ips)
}
inline void IPManageInfo::add_ips(std::string&& value) {
  ips_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:IPManageInfo.ips)
}
inline void IPManageInfo::add_ips(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  ips_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:IPManageInfo.ips)
}
inline void IPManageInfo::add_ips(const char* value, size_t size) {
  ips_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:IPManageInfo.ips)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
IPManageInfo::ips() const {
  // @@protoc_insertion_point(field_list:IPManageInfo.ips)
  return ips_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
IPManageInfo::mutable_ips() {
  // @@protoc_insertion_point(field_mutable_list:IPManageInfo.ips)
  return &ips_;
}

// -------------------------------------------------------------------

// FunInfo

// optional string fun_name = 1;
inline bool FunInfo::_internal_has_fun_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FunInfo::has_fun_name() const {
  return _internal_has_fun_name();
}
inline void FunInfo::clear_fun_name() {
  fun_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FunInfo::fun_name() const {
  // @@protoc_insertion_point(field_get:FunInfo.fun_name)
  return _internal_fun_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FunInfo::set_fun_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 fun_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FunInfo.fun_name)
}
inline std::string* FunInfo::mutable_fun_name() {
  std::string* _s = _internal_mutable_fun_name();
  // @@protoc_insertion_point(field_mutable:FunInfo.fun_name)
  return _s;
}
inline const std::string& FunInfo::_internal_fun_name() const {
  return fun_name_.Get();
}
inline void FunInfo::_internal_set_fun_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  fun_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FunInfo::_internal_mutable_fun_name() {
  _has_bits_[0] |= 0x00000001u;
  return fun_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FunInfo::release_fun_name() {
  // @@protoc_insertion_point(field_release:FunInfo.fun_name)
  if (!_internal_has_fun_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = fun_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (fun_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    fun_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FunInfo::set_allocated_fun_name(std::string* fun_name) {
  if (fun_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  fun_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fun_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (fun_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    fun_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:FunInfo.fun_name)
}

// optional string fun_desc = 2;
inline bool FunInfo::_internal_has_fun_desc() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FunInfo::has_fun_desc() const {
  return _internal_has_fun_desc();
}
inline void FunInfo::clear_fun_desc() {
  fun_desc_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& FunInfo::fun_desc() const {
  // @@protoc_insertion_point(field_get:FunInfo.fun_desc)
  return _internal_fun_desc();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FunInfo::set_fun_desc(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 fun_desc_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FunInfo.fun_desc)
}
inline std::string* FunInfo::mutable_fun_desc() {
  std::string* _s = _internal_mutable_fun_desc();
  // @@protoc_insertion_point(field_mutable:FunInfo.fun_desc)
  return _s;
}
inline const std::string& FunInfo::_internal_fun_desc() const {
  return fun_desc_.Get();
}
inline void FunInfo::_internal_set_fun_desc(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  fun_desc_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FunInfo::_internal_mutable_fun_desc() {
  _has_bits_[0] |= 0x00000002u;
  return fun_desc_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FunInfo::release_fun_desc() {
  // @@protoc_insertion_point(field_release:FunInfo.fun_desc)
  if (!_internal_has_fun_desc()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = fun_desc_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (fun_desc_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    fun_desc_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FunInfo::set_allocated_fun_desc(std::string* fun_desc) {
  if (fun_desc != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  fun_desc_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fun_desc,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (fun_desc_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    fun_desc_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:FunInfo.fun_desc)
}

// optional string fun_args = 3;
inline bool FunInfo::_internal_has_fun_args() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool FunInfo::has_fun_args() const {
  return _internal_has_fun_args();
}
inline void FunInfo::clear_fun_args() {
  fun_args_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& FunInfo::fun_args() const {
  // @@protoc_insertion_point(field_get:FunInfo.fun_args)
  return _internal_fun_args();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FunInfo::set_fun_args(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 fun_args_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FunInfo.fun_args)
}
inline std::string* FunInfo::mutable_fun_args() {
  std::string* _s = _internal_mutable_fun_args();
  // @@protoc_insertion_point(field_mutable:FunInfo.fun_args)
  return _s;
}
inline const std::string& FunInfo::_internal_fun_args() const {
  return fun_args_.Get();
}
inline void FunInfo::_internal_set_fun_args(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  fun_args_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FunInfo::_internal_mutable_fun_args() {
  _has_bits_[0] |= 0x00000004u;
  return fun_args_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FunInfo::release_fun_args() {
  // @@protoc_insertion_point(field_release:FunInfo.fun_args)
  if (!_internal_has_fun_args()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = fun_args_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (fun_args_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    fun_args_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FunInfo::set_allocated_fun_args(std::string* fun_args) {
  if (fun_args != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  fun_args_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fun_args,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (fun_args_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    fun_args_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:FunInfo.fun_args)
}

// optional string fun_body = 4;
inline bool FunInfo::_internal_has_fun_body() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool FunInfo::has_fun_body() const {
  return _internal_has_fun_body();
}
inline void FunInfo::clear_fun_body() {
  fun_body_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& FunInfo::fun_body() const {
  // @@protoc_insertion_point(field_get:FunInfo.fun_body)
  return _internal_fun_body();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FunInfo::set_fun_body(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 fun_body_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FunInfo.fun_body)
}
inline std::string* FunInfo::mutable_fun_body() {
  std::string* _s = _internal_mutable_fun_body();
  // @@protoc_insertion_point(field_mutable:FunInfo.fun_body)
  return _s;
}
inline const std::string& FunInfo::_internal_fun_body() const {
  return fun_body_.Get();
}
inline void FunInfo::_internal_set_fun_body(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  fun_body_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FunInfo::_internal_mutable_fun_body() {
  _has_bits_[0] |= 0x00000008u;
  return fun_body_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FunInfo::release_fun_body() {
  // @@protoc_insertion_point(field_release:FunInfo.fun_body)
  if (!_internal_has_fun_body()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = fun_body_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (fun_body_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    fun_body_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FunInfo::set_allocated_fun_body(std::string* fun_body) {
  if (fun_body != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  fun_body_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fun_body,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (fun_body_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    fun_body_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:FunInfo.fun_body)
}

// optional string fun_subs = 5;
inline bool FunInfo::_internal_has_fun_subs() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool FunInfo::has_fun_subs() const {
  return _internal_has_fun_subs();
}
inline void FunInfo::clear_fun_subs() {
  fun_subs_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& FunInfo::fun_subs() const {
  // @@protoc_insertion_point(field_get:FunInfo.fun_subs)
  return _internal_fun_subs();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FunInfo::set_fun_subs(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 fun_subs_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FunInfo.fun_subs)
}
inline std::string* FunInfo::mutable_fun_subs() {
  std::string* _s = _internal_mutable_fun_subs();
  // @@protoc_insertion_point(field_mutable:FunInfo.fun_subs)
  return _s;
}
inline const std::string& FunInfo::_internal_fun_subs() const {
  return fun_subs_.Get();
}
inline void FunInfo::_internal_set_fun_subs(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  fun_subs_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FunInfo::_internal_mutable_fun_subs() {
  _has_bits_[0] |= 0x00000010u;
  return fun_subs_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FunInfo::release_fun_subs() {
  // @@protoc_insertion_point(field_release:FunInfo.fun_subs)
  if (!_internal_has_fun_subs()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = fun_subs_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (fun_subs_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    fun_subs_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FunInfo::set_allocated_fun_subs(std::string* fun_subs) {
  if (fun_subs != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  fun_subs_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fun_subs,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (fun_subs_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    fun_subs_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:FunInfo.fun_subs)
}

// optional string fun_status = 6;
inline bool FunInfo::_internal_has_fun_status() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool FunInfo::has_fun_status() const {
  return _internal_has_fun_status();
}
inline void FunInfo::clear_fun_status() {
  fun_status_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& FunInfo::fun_status() const {
  // @@protoc_insertion_point(field_get:FunInfo.fun_status)
  return _internal_fun_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FunInfo::set_fun_status(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 fun_status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FunInfo.fun_status)
}
inline std::string* FunInfo::mutable_fun_status() {
  std::string* _s = _internal_mutable_fun_status();
  // @@protoc_insertion_point(field_mutable:FunInfo.fun_status)
  return _s;
}
inline const std::string& FunInfo::_internal_fun_status() const {
  return fun_status_.Get();
}
inline void FunInfo::_internal_set_fun_status(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  fun_status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FunInfo::_internal_mutable_fun_status() {
  _has_bits_[0] |= 0x00000020u;
  return fun_status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FunInfo::release_fun_status() {
  // @@protoc_insertion_point(field_release:FunInfo.fun_status)
  if (!_internal_has_fun_status()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  auto* p = fun_status_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (fun_status_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    fun_status_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FunInfo::set_allocated_fun_status(std::string* fun_status) {
  if (fun_status != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  fun_status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fun_status,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (fun_status_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    fun_status_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:FunInfo.fun_status)
}

// optional string fun_return = 7;
inline bool FunInfo::_internal_has_fun_return() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool FunInfo::has_fun_return() const {
  return _internal_has_fun_return();
}
inline void FunInfo::clear_fun_return() {
  fun_return_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& FunInfo::fun_return() const {
  // @@protoc_insertion_point(field_get:FunInfo.fun_return)
  return _internal_fun_return();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FunInfo::set_fun_return(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000040u;
 fun_return_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FunInfo.fun_return)
}
inline std::string* FunInfo::mutable_fun_return() {
  std::string* _s = _internal_mutable_fun_return();
  // @@protoc_insertion_point(field_mutable:FunInfo.fun_return)
  return _s;
}
inline const std::string& FunInfo::_internal_fun_return() const {
  return fun_return_.Get();
}
inline void FunInfo::_internal_set_fun_return(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  fun_return_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FunInfo::_internal_mutable_fun_return() {
  _has_bits_[0] |= 0x00000040u;
  return fun_return_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FunInfo::release_fun_return() {
  // @@protoc_insertion_point(field_release:FunInfo.fun_return)
  if (!_internal_has_fun_return()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  auto* p = fun_return_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (fun_return_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    fun_return_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FunInfo::set_allocated_fun_return(std::string* fun_return) {
  if (fun_return != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  fun_return_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fun_return,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (fun_return_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    fun_return_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:FunInfo.fun_return)
}

// optional string last_time = 8;
inline bool FunInfo::_internal_has_last_time() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool FunInfo::has_last_time() const {
  return _internal_has_last_time();
}
inline void FunInfo::clear_last_time() {
  last_time_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000080u;
}
inline const std::string& FunInfo::last_time() const {
  // @@protoc_insertion_point(field_get:FunInfo.last_time)
  return _internal_last_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FunInfo::set_last_time(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000080u;
 last_time_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FunInfo.last_time)
}
inline std::string* FunInfo::mutable_last_time() {
  std::string* _s = _internal_mutable_last_time();
  // @@protoc_insertion_point(field_mutable:FunInfo.last_time)
  return _s;
}
inline const std::string& FunInfo::_internal_last_time() const {
  return last_time_.Get();
}
inline void FunInfo::_internal_set_last_time(const std::string& value) {
  _has_bits_[0] |= 0x00000080u;
  last_time_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FunInfo::_internal_mutable_last_time() {
  _has_bits_[0] |= 0x00000080u;
  return last_time_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FunInfo::release_last_time() {
  // @@protoc_insertion_point(field_release:FunInfo.last_time)
  if (!_internal_has_last_time()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000080u;
  auto* p = last_time_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (last_time_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    last_time_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FunInfo::set_allocated_last_time(std::string* last_time) {
  if (last_time != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  last_time_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), last_time,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (last_time_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    last_time_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:FunInfo.last_time)
}

// optional string fun_review = 9;
inline bool FunInfo::_internal_has_fun_review() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool FunInfo::has_fun_review() const {
  return _internal_has_fun_review();
}
inline void FunInfo::clear_fun_review() {
  fun_review_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000100u;
}
inline const std::string& FunInfo::fun_review() const {
  // @@protoc_insertion_point(field_get:FunInfo.fun_review)
  return _internal_fun_review();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FunInfo::set_fun_review(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000100u;
 fun_review_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FunInfo.fun_review)
}
inline std::string* FunInfo::mutable_fun_review() {
  std::string* _s = _internal_mutable_fun_review();
  // @@protoc_insertion_point(field_mutable:FunInfo.fun_review)
  return _s;
}
inline const std::string& FunInfo::_internal_fun_review() const {
  return fun_review_.Get();
}
inline void FunInfo::_internal_set_fun_review(const std::string& value) {
  _has_bits_[0] |= 0x00000100u;
  fun_review_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FunInfo::_internal_mutable_fun_review() {
  _has_bits_[0] |= 0x00000100u;
  return fun_review_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FunInfo::release_fun_review() {
  // @@protoc_insertion_point(field_release:FunInfo.fun_review)
  if (!_internal_has_fun_review()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000100u;
  auto* p = fun_review_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (fun_review_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    fun_review_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FunInfo::set_allocated_fun_review(std::string* fun_review) {
  if (fun_review != nullptr) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  fun_review_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fun_review,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (fun_review_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    fun_review_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:FunInfo.fun_review)
}

// -------------------------------------------------------------------

// CommonResponse

// optional int32 StatusCode = 1;
inline bool CommonResponse::_internal_has_statuscode() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool CommonResponse::has_statuscode() const {
  return _internal_has_statuscode();
}
inline void CommonResponse::clear_statuscode() {
  statuscode_ = 0;
  _has_bits_[0] &= ~0x00002000u;
}
inline int32_t CommonResponse::_internal_statuscode() const {
  return statuscode_;
}
inline int32_t CommonResponse::statuscode() const {
  // @@protoc_insertion_point(field_get:CommonResponse.StatusCode)
  return _internal_statuscode();
}
inline void CommonResponse::_internal_set_statuscode(int32_t value) {
  _has_bits_[0] |= 0x00002000u;
  statuscode_ = value;
}
inline void CommonResponse::set_statuscode(int32_t value) {
  _internal_set_statuscode(value);
  // @@protoc_insertion_point(field_set:CommonResponse.StatusCode)
}

// optional string StatusMsg = 2;
inline bool CommonResponse::_internal_has_statusmsg() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommonResponse::has_statusmsg() const {
  return _internal_has_statusmsg();
}
inline void CommonResponse::clear_statusmsg() {
  statusmsg_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommonResponse::statusmsg() const {
  // @@protoc_insertion_point(field_get:CommonResponse.StatusMsg)
  return _internal_statusmsg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonResponse::set_statusmsg(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 statusmsg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonResponse.StatusMsg)
}
inline std::string* CommonResponse::mutable_statusmsg() {
  std::string* _s = _internal_mutable_statusmsg();
  // @@protoc_insertion_point(field_mutable:CommonResponse.StatusMsg)
  return _s;
}
inline const std::string& CommonResponse::_internal_statusmsg() const {
  return statusmsg_.Get();
}
inline void CommonResponse::_internal_set_statusmsg(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  statusmsg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonResponse::_internal_mutable_statusmsg() {
  _has_bits_[0] |= 0x00000001u;
  return statusmsg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonResponse::release_statusmsg() {
  // @@protoc_insertion_point(field_release:CommonResponse.StatusMsg)
  if (!_internal_has_statusmsg()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = statusmsg_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (statusmsg_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    statusmsg_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonResponse::set_allocated_statusmsg(std::string* statusmsg) {
  if (statusmsg != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  statusmsg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), statusmsg,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (statusmsg_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    statusmsg_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonResponse.StatusMsg)
}

// repeated .google.protobuf.Any ResponseBody = 3;
inline int CommonResponse::_internal_responsebody_size() const {
  return responsebody_.size();
}
inline int CommonResponse::responsebody_size() const {
  return _internal_responsebody_size();
}
inline ::PROTOBUF_NAMESPACE_ID::Any* CommonResponse::mutable_responsebody(int index) {
  // @@protoc_insertion_point(field_mutable:CommonResponse.ResponseBody)
  return responsebody_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any >*
CommonResponse::mutable_responsebody() {
  // @@protoc_insertion_point(field_mutable_list:CommonResponse.ResponseBody)
  return &responsebody_;
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& CommonResponse::_internal_responsebody(int index) const {
  return responsebody_.Get(index);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& CommonResponse::responsebody(int index) const {
  // @@protoc_insertion_point(field_get:CommonResponse.ResponseBody)
  return _internal_responsebody(index);
}
inline ::PROTOBUF_NAMESPACE_ID::Any* CommonResponse::_internal_add_responsebody() {
  return responsebody_.Add();
}
inline ::PROTOBUF_NAMESPACE_ID::Any* CommonResponse::add_responsebody() {
  ::PROTOBUF_NAMESPACE_ID::Any* _add = _internal_add_responsebody();
  // @@protoc_insertion_point(field_add:CommonResponse.ResponseBody)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any >&
CommonResponse::responsebody() const {
  // @@protoc_insertion_point(field_list:CommonResponse.ResponseBody)
  return responsebody_;
}

// optional .QueryHeadInfo head = 4;
inline bool CommonResponse::_internal_has_head() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || head_ != nullptr);
  return value;
}
inline bool CommonResponse::has_head() const {
  return _internal_has_head();
}
inline void CommonResponse::clear_head() {
  if (head_ != nullptr) head_->Clear();
  _has_bits_[0] &= ~0x00000800u;
}
inline const ::QueryHeadInfo& CommonResponse::_internal_head() const {
  const ::QueryHeadInfo* p = head_;
  return p != nullptr ? *p : reinterpret_cast<const ::QueryHeadInfo&>(
      ::_QueryHeadInfo_default_instance_);
}
inline const ::QueryHeadInfo& CommonResponse::head() const {
  // @@protoc_insertion_point(field_get:CommonResponse.head)
  return _internal_head();
}
inline void CommonResponse::unsafe_arena_set_allocated_head(
    ::QueryHeadInfo* head) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(head_);
  }
  head_ = head;
  if (head) {
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CommonResponse.head)
}
inline ::QueryHeadInfo* CommonResponse::release_head() {
  _has_bits_[0] &= ~0x00000800u;
  ::QueryHeadInfo* temp = head_;
  head_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::QueryHeadInfo* CommonResponse::unsafe_arena_release_head() {
  // @@protoc_insertion_point(field_release:CommonResponse.head)
  _has_bits_[0] &= ~0x00000800u;
  ::QueryHeadInfo* temp = head_;
  head_ = nullptr;
  return temp;
}
inline ::QueryHeadInfo* CommonResponse::_internal_mutable_head() {
  _has_bits_[0] |= 0x00000800u;
  if (head_ == nullptr) {
    auto* p = CreateMaybeMessage<::QueryHeadInfo>(GetArenaForAllocation());
    head_ = p;
  }
  return head_;
}
inline ::QueryHeadInfo* CommonResponse::mutable_head() {
  ::QueryHeadInfo* _msg = _internal_mutable_head();
  // @@protoc_insertion_point(field_mutable:CommonResponse.head)
  return _msg;
}
inline void CommonResponse::set_allocated_head(::QueryHeadInfo* head) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete head_;
  }
  if (head) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::QueryHeadInfo>::GetOwningArena(head);
    if (message_arena != submessage_arena) {
      head = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, head, submessage_arena);
    }
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  head_ = head;
  // @@protoc_insertion_point(field_set_allocated:CommonResponse.head)
}

// optional .QueryResultInfo results = 5;
inline bool CommonResponse::_internal_has_results() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || results_ != nullptr);
  return value;
}
inline bool CommonResponse::has_results() const {
  return _internal_has_results();
}
inline void CommonResponse::clear_results() {
  if (results_ != nullptr) results_->Clear();
  _has_bits_[0] &= ~0x00001000u;
}
inline const ::QueryResultInfo& CommonResponse::_internal_results() const {
  const ::QueryResultInfo* p = results_;
  return p != nullptr ? *p : reinterpret_cast<const ::QueryResultInfo&>(
      ::_QueryResultInfo_default_instance_);
}
inline const ::QueryResultInfo& CommonResponse::results() const {
  // @@protoc_insertion_point(field_get:CommonResponse.results)
  return _internal_results();
}
inline void CommonResponse::unsafe_arena_set_allocated_results(
    ::QueryResultInfo* results) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(results_);
  }
  results_ = results;
  if (results) {
    _has_bits_[0] |= 0x00001000u;
  } else {
    _has_bits_[0] &= ~0x00001000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CommonResponse.results)
}
inline ::QueryResultInfo* CommonResponse::release_results() {
  _has_bits_[0] &= ~0x00001000u;
  ::QueryResultInfo* temp = results_;
  results_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::QueryResultInfo* CommonResponse::unsafe_arena_release_results() {
  // @@protoc_insertion_point(field_release:CommonResponse.results)
  _has_bits_[0] &= ~0x00001000u;
  ::QueryResultInfo* temp = results_;
  results_ = nullptr;
  return temp;
}
inline ::QueryResultInfo* CommonResponse::_internal_mutable_results() {
  _has_bits_[0] |= 0x00001000u;
  if (results_ == nullptr) {
    auto* p = CreateMaybeMessage<::QueryResultInfo>(GetArenaForAllocation());
    results_ = p;
  }
  return results_;
}
inline ::QueryResultInfo* CommonResponse::mutable_results() {
  ::QueryResultInfo* _msg = _internal_mutable_results();
  // @@protoc_insertion_point(field_mutable:CommonResponse.results)
  return _msg;
}
inline void CommonResponse::set_allocated_results(::QueryResultInfo* results) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete results_;
  }
  if (results) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::QueryResultInfo>::GetOwningArena(results);
    if (message_arena != submessage_arena) {
      results = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, results, submessage_arena);
    }
    _has_bits_[0] |= 0x00001000u;
  } else {
    _has_bits_[0] &= ~0x00001000u;
  }
  results_ = results;
  // @@protoc_insertion_point(field_set_allocated:CommonResponse.results)
}

// optional int32 AnsNum = 6;
inline bool CommonResponse::_internal_has_ansnum() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool CommonResponse::has_ansnum() const {
  return _internal_has_ansnum();
}
inline void CommonResponse::clear_ansnum() {
  ansnum_ = 0;
  _has_bits_[0] &= ~0x00004000u;
}
inline int32_t CommonResponse::_internal_ansnum() const {
  return ansnum_;
}
inline int32_t CommonResponse::ansnum() const {
  // @@protoc_insertion_point(field_get:CommonResponse.AnsNum)
  return _internal_ansnum();
}
inline void CommonResponse::_internal_set_ansnum(int32_t value) {
  _has_bits_[0] |= 0x00004000u;
  ansnum_ = value;
}
inline void CommonResponse::set_ansnum(int32_t value) {
  _internal_set_ansnum(value);
  // @@protoc_insertion_point(field_set:CommonResponse.AnsNum)
}

// optional int32 OutputLimit = 7;
inline bool CommonResponse::_internal_has_outputlimit() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool CommonResponse::has_outputlimit() const {
  return _internal_has_outputlimit();
}
inline void CommonResponse::clear_outputlimit() {
  outputlimit_ = 0;
  _has_bits_[0] &= ~0x00008000u;
}
inline int32_t CommonResponse::_internal_outputlimit() const {
  return outputlimit_;
}
inline int32_t CommonResponse::outputlimit() const {
  // @@protoc_insertion_point(field_get:CommonResponse.OutputLimit)
  return _internal_outputlimit();
}
inline void CommonResponse::_internal_set_outputlimit(int32_t value) {
  _has_bits_[0] |= 0x00008000u;
  outputlimit_ = value;
}
inline void CommonResponse::set_outputlimit(int32_t value) {
  _internal_set_outputlimit(value);
  // @@protoc_insertion_point(field_set:CommonResponse.OutputLimit)
}

// optional string ThreadId = 8;
inline bool CommonResponse::_internal_has_threadid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommonResponse::has_threadid() const {
  return _internal_has_threadid();
}
inline void CommonResponse::clear_threadid() {
  threadid_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CommonResponse::threadid() const {
  // @@protoc_insertion_point(field_get:CommonResponse.ThreadId)
  return _internal_threadid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonResponse::set_threadid(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 threadid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonResponse.ThreadId)
}
inline std::string* CommonResponse::mutable_threadid() {
  std::string* _s = _internal_mutable_threadid();
  // @@protoc_insertion_point(field_mutable:CommonResponse.ThreadId)
  return _s;
}
inline const std::string& CommonResponse::_internal_threadid() const {
  return threadid_.Get();
}
inline void CommonResponse::_internal_set_threadid(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  threadid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonResponse::_internal_mutable_threadid() {
  _has_bits_[0] |= 0x00000002u;
  return threadid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonResponse::release_threadid() {
  // @@protoc_insertion_point(field_release:CommonResponse.ThreadId)
  if (!_internal_has_threadid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = threadid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (threadid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    threadid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonResponse::set_allocated_threadid(std::string* threadid) {
  if (threadid != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  threadid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), threadid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (threadid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    threadid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonResponse.ThreadId)
}

// optional string QueryTime = 9;
inline bool CommonResponse::_internal_has_querytime() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CommonResponse::has_querytime() const {
  return _internal_has_querytime();
}
inline void CommonResponse::clear_querytime() {
  querytime_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CommonResponse::querytime() const {
  // @@protoc_insertion_point(field_get:CommonResponse.QueryTime)
  return _internal_querytime();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonResponse::set_querytime(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 querytime_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonResponse.QueryTime)
}
inline std::string* CommonResponse::mutable_querytime() {
  std::string* _s = _internal_mutable_querytime();
  // @@protoc_insertion_point(field_mutable:CommonResponse.QueryTime)
  return _s;
}
inline const std::string& CommonResponse::_internal_querytime() const {
  return querytime_.Get();
}
inline void CommonResponse::_internal_set_querytime(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  querytime_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonResponse::_internal_mutable_querytime() {
  _has_bits_[0] |= 0x00000004u;
  return querytime_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonResponse::release_querytime() {
  // @@protoc_insertion_point(field_release:CommonResponse.QueryTime)
  if (!_internal_has_querytime()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = querytime_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (querytime_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    querytime_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonResponse::set_allocated_querytime(std::string* querytime) {
  if (querytime != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  querytime_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), querytime,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (querytime_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    querytime_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonResponse.QueryTime)
}

// optional string FileName = 10;
inline bool CommonResponse::_internal_has_filename() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CommonResponse::has_filename() const {
  return _internal_has_filename();
}
inline void CommonResponse::clear_filename() {
  filename_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CommonResponse::filename() const {
  // @@protoc_insertion_point(field_get:CommonResponse.FileName)
  return _internal_filename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonResponse::set_filename(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 filename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonResponse.FileName)
}
inline std::string* CommonResponse::mutable_filename() {
  std::string* _s = _internal_mutable_filename();
  // @@protoc_insertion_point(field_mutable:CommonResponse.FileName)
  return _s;
}
inline const std::string& CommonResponse::_internal_filename() const {
  return filename_.Get();
}
inline void CommonResponse::_internal_set_filename(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  filename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonResponse::_internal_mutable_filename() {
  _has_bits_[0] |= 0x00000008u;
  return filename_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonResponse::release_filename() {
  // @@protoc_insertion_point(field_release:CommonResponse.FileName)
  if (!_internal_has_filename()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = filename_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (filename_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    filename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonResponse::set_allocated_filename(std::string* filename) {
  if (filename != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  filename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), filename,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (filename_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    filename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonResponse.FileName)
}

// optional string filepath = 11;
inline bool CommonResponse::_internal_has_filepath() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CommonResponse::has_filepath() const {
  return _internal_has_filepath();
}
inline void CommonResponse::clear_filepath() {
  filepath_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& CommonResponse::filepath() const {
  // @@protoc_insertion_point(field_get:CommonResponse.filepath)
  return _internal_filepath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonResponse::set_filepath(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 filepath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonResponse.filepath)
}
inline std::string* CommonResponse::mutable_filepath() {
  std::string* _s = _internal_mutable_filepath();
  // @@protoc_insertion_point(field_mutable:CommonResponse.filepath)
  return _s;
}
inline const std::string& CommonResponse::_internal_filepath() const {
  return filepath_.Get();
}
inline void CommonResponse::_internal_set_filepath(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  filepath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonResponse::_internal_mutable_filepath() {
  _has_bits_[0] |= 0x00000010u;
  return filepath_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonResponse::release_filepath() {
  // @@protoc_insertion_point(field_release:CommonResponse.filepath)
  if (!_internal_has_filepath()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = filepath_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (filepath_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    filepath_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonResponse::set_allocated_filepath(std::string* filepath) {
  if (filepath != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  filepath_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), filepath,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (filepath_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    filepath_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonResponse.filepath)
}

// optional string TID = 12;
inline bool CommonResponse::_internal_has_tid() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CommonResponse::has_tid() const {
  return _internal_has_tid();
}
inline void CommonResponse::clear_tid() {
  tid_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& CommonResponse::tid() const {
  // @@protoc_insertion_point(field_get:CommonResponse.TID)
  return _internal_tid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonResponse::set_tid(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 tid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonResponse.TID)
}
inline std::string* CommonResponse::mutable_tid() {
  std::string* _s = _internal_mutable_tid();
  // @@protoc_insertion_point(field_mutable:CommonResponse.TID)
  return _s;
}
inline const std::string& CommonResponse::_internal_tid() const {
  return tid_.Get();
}
inline void CommonResponse::_internal_set_tid(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  tid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonResponse::_internal_mutable_tid() {
  _has_bits_[0] |= 0x00000020u;
  return tid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonResponse::release_tid() {
  // @@protoc_insertion_point(field_release:CommonResponse.TID)
  if (!_internal_has_tid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  auto* p = tid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    tid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonResponse::set_allocated_tid(std::string* tid) {
  if (tid != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  tid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    tid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonResponse.TID)
}

// repeated .google.protobuf.Any list = 13;
inline int CommonResponse::_internal_list_size() const {
  return list_.size();
}
inline int CommonResponse::list_size() const {
  return _internal_list_size();
}
inline ::PROTOBUF_NAMESPACE_ID::Any* CommonResponse::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:CommonResponse.list)
  return list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any >*
CommonResponse::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:CommonResponse.list)
  return &list_;
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& CommonResponse::_internal_list(int index) const {
  return list_.Get(index);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& CommonResponse::list(int index) const {
  // @@protoc_insertion_point(field_get:CommonResponse.list)
  return _internal_list(index);
}
inline ::PROTOBUF_NAMESPACE_ID::Any* CommonResponse::_internal_add_list() {
  return list_.Add();
}
inline ::PROTOBUF_NAMESPACE_ID::Any* CommonResponse::add_list() {
  ::PROTOBUF_NAMESPACE_ID::Any* _add = _internal_add_list();
  // @@protoc_insertion_point(field_add:CommonResponse.list)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any >&
CommonResponse::list() const {
  // @@protoc_insertion_point(field_list:CommonResponse.list)
  return list_;
}

// optional string CoreVersion = 14;
inline bool CommonResponse::_internal_has_coreversion() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CommonResponse::has_coreversion() const {
  return _internal_has_coreversion();
}
inline void CommonResponse::clear_coreversion() {
  coreversion_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& CommonResponse::coreversion() const {
  // @@protoc_insertion_point(field_get:CommonResponse.CoreVersion)
  return _internal_coreversion();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonResponse::set_coreversion(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000040u;
 coreversion_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonResponse.CoreVersion)
}
inline std::string* CommonResponse::mutable_coreversion() {
  std::string* _s = _internal_mutable_coreversion();
  // @@protoc_insertion_point(field_mutable:CommonResponse.CoreVersion)
  return _s;
}
inline const std::string& CommonResponse::_internal_coreversion() const {
  return coreversion_.Get();
}
inline void CommonResponse::_internal_set_coreversion(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  coreversion_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonResponse::_internal_mutable_coreversion() {
  _has_bits_[0] |= 0x00000040u;
  return coreversion_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonResponse::release_coreversion() {
  // @@protoc_insertion_point(field_release:CommonResponse.CoreVersion)
  if (!_internal_has_coreversion()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  auto* p = coreversion_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (coreversion_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    coreversion_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonResponse::set_allocated_coreversion(std::string* coreversion) {
  if (coreversion != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  coreversion_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), coreversion,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (coreversion_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    coreversion_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonResponse.CoreVersion)
}

// optional string licensetype = 15;
inline bool CommonResponse::_internal_has_licensetype() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CommonResponse::has_licensetype() const {
  return _internal_has_licensetype();
}
inline void CommonResponse::clear_licensetype() {
  licensetype_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000080u;
}
inline const std::string& CommonResponse::licensetype() const {
  // @@protoc_insertion_point(field_get:CommonResponse.licensetype)
  return _internal_licensetype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonResponse::set_licensetype(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000080u;
 licensetype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonResponse.licensetype)
}
inline std::string* CommonResponse::mutable_licensetype() {
  std::string* _s = _internal_mutable_licensetype();
  // @@protoc_insertion_point(field_mutable:CommonResponse.licensetype)
  return _s;
}
inline const std::string& CommonResponse::_internal_licensetype() const {
  return licensetype_.Get();
}
inline void CommonResponse::_internal_set_licensetype(const std::string& value) {
  _has_bits_[0] |= 0x00000080u;
  licensetype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonResponse::_internal_mutable_licensetype() {
  _has_bits_[0] |= 0x00000080u;
  return licensetype_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonResponse::release_licensetype() {
  // @@protoc_insertion_point(field_release:CommonResponse.licensetype)
  if (!_internal_has_licensetype()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000080u;
  auto* p = licensetype_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (licensetype_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    licensetype_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonResponse::set_allocated_licensetype(std::string* licensetype) {
  if (licensetype != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  licensetype_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), licensetype,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (licensetype_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    licensetype_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonResponse.licensetype)
}

// optional string success_num = 16;
inline bool CommonResponse::_internal_has_success_num() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CommonResponse::has_success_num() const {
  return _internal_has_success_num();
}
inline void CommonResponse::clear_success_num() {
  success_num_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000100u;
}
inline const std::string& CommonResponse::success_num() const {
  // @@protoc_insertion_point(field_get:CommonResponse.success_num)
  return _internal_success_num();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonResponse::set_success_num(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000100u;
 success_num_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonResponse.success_num)
}
inline std::string* CommonResponse::mutable_success_num() {
  std::string* _s = _internal_mutable_success_num();
  // @@protoc_insertion_point(field_mutable:CommonResponse.success_num)
  return _s;
}
inline const std::string& CommonResponse::_internal_success_num() const {
  return success_num_.Get();
}
inline void CommonResponse::_internal_set_success_num(const std::string& value) {
  _has_bits_[0] |= 0x00000100u;
  success_num_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonResponse::_internal_mutable_success_num() {
  _has_bits_[0] |= 0x00000100u;
  return success_num_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonResponse::release_success_num() {
  // @@protoc_insertion_point(field_release:CommonResponse.success_num)
  if (!_internal_has_success_num()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000100u;
  auto* p = success_num_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (success_num_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    success_num_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonResponse::set_allocated_success_num(std::string* success_num) {
  if (success_num != nullptr) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  success_num_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), success_num,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (success_num_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    success_num_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonResponse.success_num)
}

// optional int32 totalSize = 17;
inline bool CommonResponse::_internal_has_totalsize() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool CommonResponse::has_totalsize() const {
  return _internal_has_totalsize();
}
inline void CommonResponse::clear_totalsize() {
  totalsize_ = 0;
  _has_bits_[0] &= ~0x00010000u;
}
inline int32_t CommonResponse::_internal_totalsize() const {
  return totalsize_;
}
inline int32_t CommonResponse::totalsize() const {
  // @@protoc_insertion_point(field_get:CommonResponse.totalSize)
  return _internal_totalsize();
}
inline void CommonResponse::_internal_set_totalsize(int32_t value) {
  _has_bits_[0] |= 0x00010000u;
  totalsize_ = value;
}
inline void CommonResponse::set_totalsize(int32_t value) {
  _internal_set_totalsize(value);
  // @@protoc_insertion_point(field_set:CommonResponse.totalSize)
}

// optional int32 totalPage = 18;
inline bool CommonResponse::_internal_has_totalpage() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool CommonResponse::has_totalpage() const {
  return _internal_has_totalpage();
}
inline void CommonResponse::clear_totalpage() {
  totalpage_ = 0;
  _has_bits_[0] &= ~0x00020000u;
}
inline int32_t CommonResponse::_internal_totalpage() const {
  return totalpage_;
}
inline int32_t CommonResponse::totalpage() const {
  // @@protoc_insertion_point(field_get:CommonResponse.totalPage)
  return _internal_totalpage();
}
inline void CommonResponse::_internal_set_totalpage(int32_t value) {
  _has_bits_[0] |= 0x00020000u;
  totalpage_ = value;
}
inline void CommonResponse::set_totalpage(int32_t value) {
  _internal_set_totalpage(value);
  // @@protoc_insertion_point(field_set:CommonResponse.totalPage)
}

// optional int32 pageNo = 19;
inline bool CommonResponse::_internal_has_pageno() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool CommonResponse::has_pageno() const {
  return _internal_has_pageno();
}
inline void CommonResponse::clear_pageno() {
  pageno_ = 0;
  _has_bits_[0] &= ~0x00040000u;
}
inline int32_t CommonResponse::_internal_pageno() const {
  return pageno_;
}
inline int32_t CommonResponse::pageno() const {
  // @@protoc_insertion_point(field_get:CommonResponse.pageNo)
  return _internal_pageno();
}
inline void CommonResponse::_internal_set_pageno(int32_t value) {
  _has_bits_[0] |= 0x00040000u;
  pageno_ = value;
}
inline void CommonResponse::set_pageno(int32_t value) {
  _internal_set_pageno(value);
  // @@protoc_insertion_point(field_set:CommonResponse.pageNo)
}

// optional int32 pageSize = 20;
inline bool CommonResponse::_internal_has_pagesize() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool CommonResponse::has_pagesize() const {
  return _internal_has_pagesize();
}
inline void CommonResponse::clear_pagesize() {
  pagesize_ = 0;
  _has_bits_[0] &= ~0x00080000u;
}
inline int32_t CommonResponse::_internal_pagesize() const {
  return pagesize_;
}
inline int32_t CommonResponse::pagesize() const {
  // @@protoc_insertion_point(field_get:CommonResponse.pageSize)
  return _internal_pagesize();
}
inline void CommonResponse::_internal_set_pagesize(int32_t value) {
  _has_bits_[0] |= 0x00080000u;
  pagesize_ = value;
}
inline void CommonResponse::set_pagesize(int32_t value) {
  _internal_set_pagesize(value);
  // @@protoc_insertion_point(field_set:CommonResponse.pageSize)
}

// optional string backupfilepath = 21;
inline bool CommonResponse::_internal_has_backupfilepath() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool CommonResponse::has_backupfilepath() const {
  return _internal_has_backupfilepath();
}
inline void CommonResponse::clear_backupfilepath() {
  backupfilepath_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000200u;
}
inline const std::string& CommonResponse::backupfilepath() const {
  // @@protoc_insertion_point(field_get:CommonResponse.backupfilepath)
  return _internal_backupfilepath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonResponse::set_backupfilepath(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000200u;
 backupfilepath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonResponse.backupfilepath)
}
inline std::string* CommonResponse::mutable_backupfilepath() {
  std::string* _s = _internal_mutable_backupfilepath();
  // @@protoc_insertion_point(field_mutable:CommonResponse.backupfilepath)
  return _s;
}
inline const std::string& CommonResponse::_internal_backupfilepath() const {
  return backupfilepath_.Get();
}
inline void CommonResponse::_internal_set_backupfilepath(const std::string& value) {
  _has_bits_[0] |= 0x00000200u;
  backupfilepath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonResponse::_internal_mutable_backupfilepath() {
  _has_bits_[0] |= 0x00000200u;
  return backupfilepath_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonResponse::release_backupfilepath() {
  // @@protoc_insertion_point(field_release:CommonResponse.backupfilepath)
  if (!_internal_has_backupfilepath()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000200u;
  auto* p = backupfilepath_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (backupfilepath_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    backupfilepath_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonResponse::set_allocated_backupfilepath(std::string* backupfilepath) {
  if (backupfilepath != nullptr) {
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  backupfilepath_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), backupfilepath,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (backupfilepath_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    backupfilepath_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonResponse.backupfilepath)
}

// optional string Result = 22;
inline bool CommonResponse::_internal_has_result() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool CommonResponse::has_result() const {
  return _internal_has_result();
}
inline void CommonResponse::clear_result() {
  result_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000400u;
}
inline const std::string& CommonResponse::result() const {
  // @@protoc_insertion_point(field_get:CommonResponse.Result)
  return _internal_result();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonResponse::set_result(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000400u;
 result_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonResponse.Result)
}
inline std::string* CommonResponse::mutable_result() {
  std::string* _s = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:CommonResponse.Result)
  return _s;
}
inline const std::string& CommonResponse::_internal_result() const {
  return result_.Get();
}
inline void CommonResponse::_internal_set_result(const std::string& value) {
  _has_bits_[0] |= 0x00000400u;
  result_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonResponse::_internal_mutable_result() {
  _has_bits_[0] |= 0x00000400u;
  return result_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonResponse::release_result() {
  // @@protoc_insertion_point(field_release:CommonResponse.Result)
  if (!_internal_has_result()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000400u;
  auto* p = result_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (result_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    result_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonResponse::set_allocated_result(std::string* result) {
  if (result != nullptr) {
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  result_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), result,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (result_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    result_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonResponse.Result)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_grpc_2eproto
