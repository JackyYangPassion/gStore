// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: grpc.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_grpc_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_grpc_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/any.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_grpc_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_grpc_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[11]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_grpc_2eproto;
class AccessLogInfo;
struct AccessLogInfoDefaultTypeInternal;
extern AccessLogInfoDefaultTypeInternal _AccessLogInfo_default_instance_;
class CommonRequest;
struct CommonRequestDefaultTypeInternal;
extern CommonRequestDefaultTypeInternal _CommonRequest_default_instance_;
class CommonResponse;
struct CommonResponseDefaultTypeInternal;
extern CommonResponseDefaultTypeInternal _CommonResponse_default_instance_;
class DBInfo;
struct DBInfoDefaultTypeInternal;
extern DBInfoDefaultTypeInternal _DBInfo_default_instance_;
class FunInfo;
struct FunInfoDefaultTypeInternal;
extern FunInfoDefaultTypeInternal _FunInfo_default_instance_;
class IPManageInfo;
struct IPManageInfoDefaultTypeInternal;
extern IPManageInfoDefaultTypeInternal _IPManageInfo_default_instance_;
class QueryHeadInfo;
struct QueryHeadInfoDefaultTypeInternal;
extern QueryHeadInfoDefaultTypeInternal _QueryHeadInfo_default_instance_;
class QueryLogInfo;
struct QueryLogInfoDefaultTypeInternal;
extern QueryLogInfoDefaultTypeInternal _QueryLogInfo_default_instance_;
class QueryResultInfo;
struct QueryResultInfoDefaultTypeInternal;
extern QueryResultInfoDefaultTypeInternal _QueryResultInfo_default_instance_;
class TxnLogInfo;
struct TxnLogInfoDefaultTypeInternal;
extern TxnLogInfoDefaultTypeInternal _TxnLogInfo_default_instance_;
class UserInfo;
struct UserInfoDefaultTypeInternal;
extern UserInfoDefaultTypeInternal _UserInfo_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::AccessLogInfo* Arena::CreateMaybeMessage<::AccessLogInfo>(Arena*);
template<> ::CommonRequest* Arena::CreateMaybeMessage<::CommonRequest>(Arena*);
template<> ::CommonResponse* Arena::CreateMaybeMessage<::CommonResponse>(Arena*);
template<> ::DBInfo* Arena::CreateMaybeMessage<::DBInfo>(Arena*);
template<> ::FunInfo* Arena::CreateMaybeMessage<::FunInfo>(Arena*);
template<> ::IPManageInfo* Arena::CreateMaybeMessage<::IPManageInfo>(Arena*);
template<> ::QueryHeadInfo* Arena::CreateMaybeMessage<::QueryHeadInfo>(Arena*);
template<> ::QueryLogInfo* Arena::CreateMaybeMessage<::QueryLogInfo>(Arena*);
template<> ::QueryResultInfo* Arena::CreateMaybeMessage<::QueryResultInfo>(Arena*);
template<> ::TxnLogInfo* Arena::CreateMaybeMessage<::TxnLogInfo>(Arena*);
template<> ::UserInfo* Arena::CreateMaybeMessage<::UserInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class CommonRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CommonRequest) */ {
 public:
  inline CommonRequest() : CommonRequest(nullptr) {}
  ~CommonRequest() override;
  explicit constexpr CommonRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommonRequest(const CommonRequest& from);
  CommonRequest(CommonRequest&& from) noexcept
    : CommonRequest() {
    *this = ::std::move(from);
  }

  inline CommonRequest& operator=(const CommonRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommonRequest& operator=(CommonRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommonRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommonRequest* internal_default_instance() {
    return reinterpret_cast<const CommonRequest*>(
               &_CommonRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CommonRequest& a, CommonRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CommonRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommonRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommonRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommonRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CommonRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CommonRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommonRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CommonRequest";
  }
  protected:
  explicit CommonRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kPasswordFieldNumber = 2,
    kOperationFieldNumber = 3,
    kEncryptionFieldNumber = 4,
    kDbNameFieldNumber = 5,
    kDbPathFieldNumber = 6,
    kLoadCsrFieldNumber = 7,
    kIsBackupFieldNumber = 8,
    kTypeFieldNumber = 9,
    kOpUsernameFieldNumber = 10,
    kOpPasswordFieldNumber = 11,
    kPrivilegesFieldNumber = 12,
    kBackupPathFieldNumber = 13,
    kSparqlFieldNumber = 14,
    kFormatFieldNumber = 15,
    kIsolevelFieldNumber = 16,
    kTidFieldNumber = 17,
    kFileFieldNumber = 18,
    kDateFieldNumber = 19,
    kIpTypeFieldNumber = 22,
    kIpsFieldNumber = 23,
    kFunInfoFieldNumber = 24,
    kPageNoFieldNumber = 20,
    kPageSizeFieldNumber = 21,
  };
  // required string username = 1;
  bool has_username() const;
  private:
  bool _internal_has_username() const;
  public:
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // required string password = 2;
  bool has_password() const;
  private:
  bool _internal_has_password() const;
  public:
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // optional string operation = 3;
  bool has_operation() const;
  private:
  bool _internal_has_operation() const;
  public:
  void clear_operation();
  const std::string& operation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_operation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_operation();
  PROTOBUF_NODISCARD std::string* release_operation();
  void set_allocated_operation(std::string* operation);
  private:
  const std::string& _internal_operation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operation(const std::string& value);
  std::string* _internal_mutable_operation();
  public:

  // optional string encryption = 4;
  bool has_encryption() const;
  private:
  bool _internal_has_encryption() const;
  public:
  void clear_encryption();
  const std::string& encryption() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_encryption(ArgT0&& arg0, ArgT... args);
  std::string* mutable_encryption();
  PROTOBUF_NODISCARD std::string* release_encryption();
  void set_allocated_encryption(std::string* encryption);
  private:
  const std::string& _internal_encryption() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_encryption(const std::string& value);
  std::string* _internal_mutable_encryption();
  public:

  // optional string db_name = 5;
  bool has_db_name() const;
  private:
  bool _internal_has_db_name() const;
  public:
  void clear_db_name();
  const std::string& db_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_db_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_db_name();
  PROTOBUF_NODISCARD std::string* release_db_name();
  void set_allocated_db_name(std::string* db_name);
  private:
  const std::string& _internal_db_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_db_name(const std::string& value);
  std::string* _internal_mutable_db_name();
  public:

  // optional string db_path = 6;
  bool has_db_path() const;
  private:
  bool _internal_has_db_path() const;
  public:
  void clear_db_path();
  const std::string& db_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_db_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_db_path();
  PROTOBUF_NODISCARD std::string* release_db_path();
  void set_allocated_db_path(std::string* db_path);
  private:
  const std::string& _internal_db_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_db_path(const std::string& value);
  std::string* _internal_mutable_db_path();
  public:

  // optional string load_csr = 7;
  bool has_load_csr() const;
  private:
  bool _internal_has_load_csr() const;
  public:
  void clear_load_csr();
  const std::string& load_csr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_load_csr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_load_csr();
  PROTOBUF_NODISCARD std::string* release_load_csr();
  void set_allocated_load_csr(std::string* load_csr);
  private:
  const std::string& _internal_load_csr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_load_csr(const std::string& value);
  std::string* _internal_mutable_load_csr();
  public:

  // optional string is_backup = 8;
  bool has_is_backup() const;
  private:
  bool _internal_has_is_backup() const;
  public:
  void clear_is_backup();
  const std::string& is_backup() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_is_backup(ArgT0&& arg0, ArgT... args);
  std::string* mutable_is_backup();
  PROTOBUF_NODISCARD std::string* release_is_backup();
  void set_allocated_is_backup(std::string* is_backup);
  private:
  const std::string& _internal_is_backup() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_is_backup(const std::string& value);
  std::string* _internal_mutable_is_backup();
  public:

  // optional string type = 9;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // optional string op_username = 10;
  bool has_op_username() const;
  private:
  bool _internal_has_op_username() const;
  public:
  void clear_op_username();
  const std::string& op_username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_op_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_op_username();
  PROTOBUF_NODISCARD std::string* release_op_username();
  void set_allocated_op_username(std::string* op_username);
  private:
  const std::string& _internal_op_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_op_username(const std::string& value);
  std::string* _internal_mutable_op_username();
  public:

  // optional string op_password = 11;
  bool has_op_password() const;
  private:
  bool _internal_has_op_password() const;
  public:
  void clear_op_password();
  const std::string& op_password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_op_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_op_password();
  PROTOBUF_NODISCARD std::string* release_op_password();
  void set_allocated_op_password(std::string* op_password);
  private:
  const std::string& _internal_op_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_op_password(const std::string& value);
  std::string* _internal_mutable_op_password();
  public:

  // optional string privileges = 12;
  bool has_privileges() const;
  private:
  bool _internal_has_privileges() const;
  public:
  void clear_privileges();
  const std::string& privileges() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_privileges(ArgT0&& arg0, ArgT... args);
  std::string* mutable_privileges();
  PROTOBUF_NODISCARD std::string* release_privileges();
  void set_allocated_privileges(std::string* privileges);
  private:
  const std::string& _internal_privileges() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_privileges(const std::string& value);
  std::string* _internal_mutable_privileges();
  public:

  // optional string backup_path = 13;
  bool has_backup_path() const;
  private:
  bool _internal_has_backup_path() const;
  public:
  void clear_backup_path();
  const std::string& backup_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_backup_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_backup_path();
  PROTOBUF_NODISCARD std::string* release_backup_path();
  void set_allocated_backup_path(std::string* backup_path);
  private:
  const std::string& _internal_backup_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_backup_path(const std::string& value);
  std::string* _internal_mutable_backup_path();
  public:

  // optional string sparql = 14;
  bool has_sparql() const;
  private:
  bool _internal_has_sparql() const;
  public:
  void clear_sparql();
  const std::string& sparql() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sparql(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sparql();
  PROTOBUF_NODISCARD std::string* release_sparql();
  void set_allocated_sparql(std::string* sparql);
  private:
  const std::string& _internal_sparql() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sparql(const std::string& value);
  std::string* _internal_mutable_sparql();
  public:

  // optional string format = 15;
  bool has_format() const;
  private:
  bool _internal_has_format() const;
  public:
  void clear_format();
  const std::string& format() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_format(ArgT0&& arg0, ArgT... args);
  std::string* mutable_format();
  PROTOBUF_NODISCARD std::string* release_format();
  void set_allocated_format(std::string* format);
  private:
  const std::string& _internal_format() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_format(const std::string& value);
  std::string* _internal_mutable_format();
  public:

  // optional string isolevel = 16;
  bool has_isolevel() const;
  private:
  bool _internal_has_isolevel() const;
  public:
  void clear_isolevel();
  const std::string& isolevel() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_isolevel(ArgT0&& arg0, ArgT... args);
  std::string* mutable_isolevel();
  PROTOBUF_NODISCARD std::string* release_isolevel();
  void set_allocated_isolevel(std::string* isolevel);
  private:
  const std::string& _internal_isolevel() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_isolevel(const std::string& value);
  std::string* _internal_mutable_isolevel();
  public:

  // optional string tid = 17;
  bool has_tid() const;
  private:
  bool _internal_has_tid() const;
  public:
  void clear_tid();
  const std::string& tid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tid();
  PROTOBUF_NODISCARD std::string* release_tid();
  void set_allocated_tid(std::string* tid);
  private:
  const std::string& _internal_tid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tid(const std::string& value);
  std::string* _internal_mutable_tid();
  public:

  // optional string file = 18;
  bool has_file() const;
  private:
  bool _internal_has_file() const;
  public:
  void clear_file();
  const std::string& file() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file();
  PROTOBUF_NODISCARD std::string* release_file();
  void set_allocated_file(std::string* file);
  private:
  const std::string& _internal_file() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file(const std::string& value);
  std::string* _internal_mutable_file();
  public:

  // optional string date = 19;
  bool has_date() const;
  private:
  bool _internal_has_date() const;
  public:
  void clear_date();
  const std::string& date() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_date(ArgT0&& arg0, ArgT... args);
  std::string* mutable_date();
  PROTOBUF_NODISCARD std::string* release_date();
  void set_allocated_date(std::string* date);
  private:
  const std::string& _internal_date() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_date(const std::string& value);
  std::string* _internal_mutable_date();
  public:

  // optional string ip_type = 22;
  bool has_ip_type() const;
  private:
  bool _internal_has_ip_type() const;
  public:
  void clear_ip_type();
  const std::string& ip_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip_type();
  PROTOBUF_NODISCARD std::string* release_ip_type();
  void set_allocated_ip_type(std::string* ip_type);
  private:
  const std::string& _internal_ip_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip_type(const std::string& value);
  std::string* _internal_mutable_ip_type();
  public:

  // optional string ips = 23;
  bool has_ips() const;
  private:
  bool _internal_has_ips() const;
  public:
  void clear_ips();
  const std::string& ips() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ips(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ips();
  PROTOBUF_NODISCARD std::string* release_ips();
  void set_allocated_ips(std::string* ips);
  private:
  const std::string& _internal_ips() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ips(const std::string& value);
  std::string* _internal_mutable_ips();
  public:

  // optional .FunInfo funInfo = 24;
  bool has_funinfo() const;
  private:
  bool _internal_has_funinfo() const;
  public:
  void clear_funinfo();
  const ::FunInfo& funinfo() const;
  PROTOBUF_NODISCARD ::FunInfo* release_funinfo();
  ::FunInfo* mutable_funinfo();
  void set_allocated_funinfo(::FunInfo* funinfo);
  private:
  const ::FunInfo& _internal_funinfo() const;
  ::FunInfo* _internal_mutable_funinfo();
  public:
  void unsafe_arena_set_allocated_funinfo(
      ::FunInfo* funinfo);
  ::FunInfo* unsafe_arena_release_funinfo();

  // optional int32 pageNo = 20;
  bool has_pageno() const;
  private:
  bool _internal_has_pageno() const;
  public:
  void clear_pageno();
  int32_t pageno() const;
  void set_pageno(int32_t value);
  private:
  int32_t _internal_pageno() const;
  void _internal_set_pageno(int32_t value);
  public:

  // optional int32 pageSize = 21;
  bool has_pagesize() const;
  private:
  bool _internal_has_pagesize() const;
  public:
  void clear_pagesize();
  int32_t pagesize() const;
  void set_pagesize(int32_t value);
  private:
  int32_t _internal_pagesize() const;
  void _internal_set_pagesize(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CommonRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr operation_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encryption_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr db_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr db_path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr load_csr_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr is_backup_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr op_username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr op_password_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr privileges_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr backup_path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sparql_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr format_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr isolevel_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr date_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ips_;
  ::FunInfo* funinfo_;
  int32_t pageno_;
  int32_t pagesize_;
  friend struct ::TableStruct_grpc_2eproto;
};
// -------------------------------------------------------------------

class UserInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UserInfo) */ {
 public:
  inline UserInfo() : UserInfo(nullptr) {}
  ~UserInfo() override;
  explicit constexpr UserInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserInfo(const UserInfo& from);
  UserInfo(UserInfo&& from) noexcept
    : UserInfo() {
    *this = ::std::move(from);
  }

  inline UserInfo& operator=(const UserInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserInfo& operator=(UserInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserInfo* internal_default_instance() {
    return reinterpret_cast<const UserInfo*>(
               &_UserInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(UserInfo& a, UserInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(UserInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UserInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UserInfo";
  }
  protected:
  explicit UserInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kPasswordFieldNumber = 2,
    kQueryPrivilegeFieldNumber = 3,
    kUpdatePrivilegeFieldNumber = 4,
    kLoadPrivilegeFieldNumber = 5,
    kUnloadPrivilegeFieldNumber = 6,
    kBackupPrivilegeFieldNumber = 7,
    kRestorePrivilegeFieldNumber = 8,
    kExportPrivilegeFieldNumber = 9,
  };
  // optional string username = 1;
  bool has_username() const;
  private:
  bool _internal_has_username() const;
  public:
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // optional string password = 2;
  bool has_password() const;
  private:
  bool _internal_has_password() const;
  public:
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // optional string queryPrivilege = 3;
  bool has_queryprivilege() const;
  private:
  bool _internal_has_queryprivilege() const;
  public:
  void clear_queryprivilege();
  const std::string& queryprivilege() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_queryprivilege(ArgT0&& arg0, ArgT... args);
  std::string* mutable_queryprivilege();
  PROTOBUF_NODISCARD std::string* release_queryprivilege();
  void set_allocated_queryprivilege(std::string* queryprivilege);
  private:
  const std::string& _internal_queryprivilege() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_queryprivilege(const std::string& value);
  std::string* _internal_mutable_queryprivilege();
  public:

  // optional string updatePrivilege = 4;
  bool has_updateprivilege() const;
  private:
  bool _internal_has_updateprivilege() const;
  public:
  void clear_updateprivilege();
  const std::string& updateprivilege() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_updateprivilege(ArgT0&& arg0, ArgT... args);
  std::string* mutable_updateprivilege();
  PROTOBUF_NODISCARD std::string* release_updateprivilege();
  void set_allocated_updateprivilege(std::string* updateprivilege);
  private:
  const std::string& _internal_updateprivilege() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_updateprivilege(const std::string& value);
  std::string* _internal_mutable_updateprivilege();
  public:

  // optional string loadPrivilege = 5;
  bool has_loadprivilege() const;
  private:
  bool _internal_has_loadprivilege() const;
  public:
  void clear_loadprivilege();
  const std::string& loadprivilege() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_loadprivilege(ArgT0&& arg0, ArgT... args);
  std::string* mutable_loadprivilege();
  PROTOBUF_NODISCARD std::string* release_loadprivilege();
  void set_allocated_loadprivilege(std::string* loadprivilege);
  private:
  const std::string& _internal_loadprivilege() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_loadprivilege(const std::string& value);
  std::string* _internal_mutable_loadprivilege();
  public:

  // optional string unloadPrivilege = 6;
  bool has_unloadprivilege() const;
  private:
  bool _internal_has_unloadprivilege() const;
  public:
  void clear_unloadprivilege();
  const std::string& unloadprivilege() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_unloadprivilege(ArgT0&& arg0, ArgT... args);
  std::string* mutable_unloadprivilege();
  PROTOBUF_NODISCARD std::string* release_unloadprivilege();
  void set_allocated_unloadprivilege(std::string* unloadprivilege);
  private:
  const std::string& _internal_unloadprivilege() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_unloadprivilege(const std::string& value);
  std::string* _internal_mutable_unloadprivilege();
  public:

  // optional string backupPrivilege = 7;
  bool has_backupprivilege() const;
  private:
  bool _internal_has_backupprivilege() const;
  public:
  void clear_backupprivilege();
  const std::string& backupprivilege() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_backupprivilege(ArgT0&& arg0, ArgT... args);
  std::string* mutable_backupprivilege();
  PROTOBUF_NODISCARD std::string* release_backupprivilege();
  void set_allocated_backupprivilege(std::string* backupprivilege);
  private:
  const std::string& _internal_backupprivilege() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_backupprivilege(const std::string& value);
  std::string* _internal_mutable_backupprivilege();
  public:

  // optional string restorePrivilege = 8;
  bool has_restoreprivilege() const;
  private:
  bool _internal_has_restoreprivilege() const;
  public:
  void clear_restoreprivilege();
  const std::string& restoreprivilege() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_restoreprivilege(ArgT0&& arg0, ArgT... args);
  std::string* mutable_restoreprivilege();
  PROTOBUF_NODISCARD std::string* release_restoreprivilege();
  void set_allocated_restoreprivilege(std::string* restoreprivilege);
  private:
  const std::string& _internal_restoreprivilege() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_restoreprivilege(const std::string& value);
  std::string* _internal_mutable_restoreprivilege();
  public:

  // optional string exportPrivilege = 9;
  bool has_exportprivilege() const;
  private:
  bool _internal_has_exportprivilege() const;
  public:
  void clear_exportprivilege();
  const std::string& exportprivilege() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_exportprivilege(ArgT0&& arg0, ArgT... args);
  std::string* mutable_exportprivilege();
  PROTOBUF_NODISCARD std::string* release_exportprivilege();
  void set_allocated_exportprivilege(std::string* exportprivilege);
  private:
  const std::string& _internal_exportprivilege() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_exportprivilege(const std::string& value);
  std::string* _internal_mutable_exportprivilege();
  public:

  // @@protoc_insertion_point(class_scope:UserInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr queryprivilege_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr updateprivilege_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr loadprivilege_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr unloadprivilege_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr backupprivilege_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr restoreprivilege_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr exportprivilege_;
  friend struct ::TableStruct_grpc_2eproto;
};
// -------------------------------------------------------------------

class DBInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DBInfo) */ {
 public:
  inline DBInfo() : DBInfo(nullptr) {}
  ~DBInfo() override;
  explicit constexpr DBInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DBInfo(const DBInfo& from);
  DBInfo(DBInfo&& from) noexcept
    : DBInfo() {
    *this = ::std::move(from);
  }

  inline DBInfo& operator=(const DBInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DBInfo& operator=(DBInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DBInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const DBInfo* internal_default_instance() {
    return reinterpret_cast<const DBInfo*>(
               &_DBInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DBInfo& a, DBInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(DBInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DBInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DBInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DBInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DBInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DBInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DBInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DBInfo";
  }
  protected:
  explicit DBInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDatabaseFieldNumber = 1,
    kCreatorFieldNumber = 2,
    kBuiltTimeFieldNumber = 3,
    kStatusFieldNumber = 4,
  };
  // optional string database = 1;
  bool has_database() const;
  private:
  bool _internal_has_database() const;
  public:
  void clear_database();
  const std::string& database() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_database(ArgT0&& arg0, ArgT... args);
  std::string* mutable_database();
  PROTOBUF_NODISCARD std::string* release_database();
  void set_allocated_database(std::string* database);
  private:
  const std::string& _internal_database() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_database(const std::string& value);
  std::string* _internal_mutable_database();
  public:

  // optional string creator = 2;
  bool has_creator() const;
  private:
  bool _internal_has_creator() const;
  public:
  void clear_creator();
  const std::string& creator() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_creator(ArgT0&& arg0, ArgT... args);
  std::string* mutable_creator();
  PROTOBUF_NODISCARD std::string* release_creator();
  void set_allocated_creator(std::string* creator);
  private:
  const std::string& _internal_creator() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_creator(const std::string& value);
  std::string* _internal_mutable_creator();
  public:

  // optional string builtTime = 3;
  bool has_builttime() const;
  private:
  bool _internal_has_builttime() const;
  public:
  void clear_builttime();
  const std::string& builttime() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_builttime(ArgT0&& arg0, ArgT... args);
  std::string* mutable_builttime();
  PROTOBUF_NODISCARD std::string* release_builttime();
  void set_allocated_builttime(std::string* builttime);
  private:
  const std::string& _internal_builttime() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_builttime(const std::string& value);
  std::string* _internal_mutable_builttime();
  public:

  // optional string status = 4;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // @@protoc_insertion_point(class_scope:DBInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr database_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr creator_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr builttime_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  friend struct ::TableStruct_grpc_2eproto;
};
// -------------------------------------------------------------------

class QueryHeadInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:QueryHeadInfo) */ {
 public:
  inline QueryHeadInfo() : QueryHeadInfo(nullptr) {}
  ~QueryHeadInfo() override;
  explicit constexpr QueryHeadInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryHeadInfo(const QueryHeadInfo& from);
  QueryHeadInfo(QueryHeadInfo&& from) noexcept
    : QueryHeadInfo() {
    *this = ::std::move(from);
  }

  inline QueryHeadInfo& operator=(const QueryHeadInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryHeadInfo& operator=(QueryHeadInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryHeadInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryHeadInfo* internal_default_instance() {
    return reinterpret_cast<const QueryHeadInfo*>(
               &_QueryHeadInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(QueryHeadInfo& a, QueryHeadInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryHeadInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryHeadInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryHeadInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryHeadInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryHeadInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const QueryHeadInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryHeadInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "QueryHeadInfo";
  }
  protected:
  explicit QueryHeadInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLinkFieldNumber = 1,
    kVarsFieldNumber = 2,
  };
  // repeated string link = 1;
  int link_size() const;
  private:
  int _internal_link_size() const;
  public:
  void clear_link();
  const std::string& link(int index) const;
  std::string* mutable_link(int index);
  void set_link(int index, const std::string& value);
  void set_link(int index, std::string&& value);
  void set_link(int index, const char* value);
  void set_link(int index, const char* value, size_t size);
  std::string* add_link();
  void add_link(const std::string& value);
  void add_link(std::string&& value);
  void add_link(const char* value);
  void add_link(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& link() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_link();
  private:
  const std::string& _internal_link(int index) const;
  std::string* _internal_add_link();
  public:

  // repeated string vars = 2;
  int vars_size() const;
  private:
  int _internal_vars_size() const;
  public:
  void clear_vars();
  const std::string& vars(int index) const;
  std::string* mutable_vars(int index);
  void set_vars(int index, const std::string& value);
  void set_vars(int index, std::string&& value);
  void set_vars(int index, const char* value);
  void set_vars(int index, const char* value, size_t size);
  std::string* add_vars();
  void add_vars(const std::string& value);
  void add_vars(std::string&& value);
  void add_vars(const char* value);
  void add_vars(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& vars() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_vars();
  private:
  const std::string& _internal_vars(int index) const;
  std::string* _internal_add_vars();
  public:

  // @@protoc_insertion_point(class_scope:QueryHeadInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> link_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> vars_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_grpc_2eproto;
};
// -------------------------------------------------------------------

class QueryResultInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:QueryResultInfo) */ {
 public:
  inline QueryResultInfo() : QueryResultInfo(nullptr) {}
  ~QueryResultInfo() override;
  explicit constexpr QueryResultInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryResultInfo(const QueryResultInfo& from);
  QueryResultInfo(QueryResultInfo&& from) noexcept
    : QueryResultInfo() {
    *this = ::std::move(from);
  }

  inline QueryResultInfo& operator=(const QueryResultInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryResultInfo& operator=(QueryResultInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryResultInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryResultInfo* internal_default_instance() {
    return reinterpret_cast<const QueryResultInfo*>(
               &_QueryResultInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(QueryResultInfo& a, QueryResultInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryResultInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryResultInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryResultInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryResultInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryResultInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const QueryResultInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryResultInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "QueryResultInfo";
  }
  protected:
  explicit QueryResultInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBindingsFieldNumber = 1,
  };
  // repeated string bindings = 1;
  int bindings_size() const;
  private:
  int _internal_bindings_size() const;
  public:
  void clear_bindings();
  const std::string& bindings(int index) const;
  std::string* mutable_bindings(int index);
  void set_bindings(int index, const std::string& value);
  void set_bindings(int index, std::string&& value);
  void set_bindings(int index, const char* value);
  void set_bindings(int index, const char* value, size_t size);
  std::string* add_bindings();
  void add_bindings(const std::string& value);
  void add_bindings(std::string&& value);
  void add_bindings(const char* value);
  void add_bindings(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& bindings() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_bindings();
  private:
  const std::string& _internal_bindings(int index) const;
  std::string* _internal_add_bindings();
  public:

  // @@protoc_insertion_point(class_scope:QueryResultInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> bindings_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_grpc_2eproto;
};
// -------------------------------------------------------------------

class TxnLogInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TxnLogInfo) */ {
 public:
  inline TxnLogInfo() : TxnLogInfo(nullptr) {}
  ~TxnLogInfo() override;
  explicit constexpr TxnLogInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TxnLogInfo(const TxnLogInfo& from);
  TxnLogInfo(TxnLogInfo&& from) noexcept
    : TxnLogInfo() {
    *this = ::std::move(from);
  }

  inline TxnLogInfo& operator=(const TxnLogInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TxnLogInfo& operator=(TxnLogInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TxnLogInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TxnLogInfo* internal_default_instance() {
    return reinterpret_cast<const TxnLogInfo*>(
               &_TxnLogInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(TxnLogInfo& a, TxnLogInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TxnLogInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TxnLogInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TxnLogInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TxnLogInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TxnLogInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TxnLogInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TxnLogInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TxnLogInfo";
  }
  protected:
  explicit TxnLogInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDbNameFieldNumber = 1,
    kTIDFieldNumber = 2,
    kUserFieldNumber = 3,
    kBeginTimeFieldNumber = 4,
    kStateFieldNumber = 5,
    kEndTimeFieldNumber = 6,
  };
  // optional string dbName = 1;
  bool has_dbname() const;
  private:
  bool _internal_has_dbname() const;
  public:
  void clear_dbname();
  const std::string& dbname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dbname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dbname();
  PROTOBUF_NODISCARD std::string* release_dbname();
  void set_allocated_dbname(std::string* dbname);
  private:
  const std::string& _internal_dbname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dbname(const std::string& value);
  std::string* _internal_mutable_dbname();
  public:

  // optional string TID = 2;
  bool has_tid() const;
  private:
  bool _internal_has_tid() const;
  public:
  void clear_tid();
  const std::string& tid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tid();
  PROTOBUF_NODISCARD std::string* release_tid();
  void set_allocated_tid(std::string* tid);
  private:
  const std::string& _internal_tid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tid(const std::string& value);
  std::string* _internal_mutable_tid();
  public:

  // optional string user = 3;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const std::string& user() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user();
  PROTOBUF_NODISCARD std::string* release_user();
  void set_allocated_user(std::string* user);
  private:
  const std::string& _internal_user() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user(const std::string& value);
  std::string* _internal_mutable_user();
  public:

  // optional string beginTime = 4;
  bool has_begintime() const;
  private:
  bool _internal_has_begintime() const;
  public:
  void clear_begintime();
  const std::string& begintime() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_begintime(ArgT0&& arg0, ArgT... args);
  std::string* mutable_begintime();
  PROTOBUF_NODISCARD std::string* release_begintime();
  void set_allocated_begintime(std::string* begintime);
  private:
  const std::string& _internal_begintime() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_begintime(const std::string& value);
  std::string* _internal_mutable_begintime();
  public:

  // optional string state = 5;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  const std::string& state() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_state(ArgT0&& arg0, ArgT... args);
  std::string* mutable_state();
  PROTOBUF_NODISCARD std::string* release_state();
  void set_allocated_state(std::string* state);
  private:
  const std::string& _internal_state() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_state(const std::string& value);
  std::string* _internal_mutable_state();
  public:

  // optional string endTime = 6;
  bool has_endtime() const;
  private:
  bool _internal_has_endtime() const;
  public:
  void clear_endtime();
  const std::string& endtime() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_endtime(ArgT0&& arg0, ArgT... args);
  std::string* mutable_endtime();
  PROTOBUF_NODISCARD std::string* release_endtime();
  void set_allocated_endtime(std::string* endtime);
  private:
  const std::string& _internal_endtime() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_endtime(const std::string& value);
  std::string* _internal_mutable_endtime();
  public:

  // @@protoc_insertion_point(class_scope:TxnLogInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dbname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr begintime_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr state_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr endtime_;
  friend struct ::TableStruct_grpc_2eproto;
};
// -------------------------------------------------------------------

class QueryLogInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:QueryLogInfo) */ {
 public:
  inline QueryLogInfo() : QueryLogInfo(nullptr) {}
  ~QueryLogInfo() override;
  explicit constexpr QueryLogInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryLogInfo(const QueryLogInfo& from);
  QueryLogInfo(QueryLogInfo&& from) noexcept
    : QueryLogInfo() {
    *this = ::std::move(from);
  }

  inline QueryLogInfo& operator=(const QueryLogInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryLogInfo& operator=(QueryLogInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryLogInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryLogInfo* internal_default_instance() {
    return reinterpret_cast<const QueryLogInfo*>(
               &_QueryLogInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(QueryLogInfo& a, QueryLogInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryLogInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryLogInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryLogInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryLogInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryLogInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const QueryLogInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryLogInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "QueryLogInfo";
  }
  protected:
  explicit QueryLogInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQueryDateTimeFieldNumber = 1,
    kSparqlFieldNumber = 2,
    kFormatFieldNumber = 3,
    kRemoteIPFieldNumber = 4,
    kFileNameFieldNumber = 5,
    kQueryTimeFieldNumber = 6,
    kAnsNumFieldNumber = 7,
  };
  // optional string QueryDateTime = 1;
  bool has_querydatetime() const;
  private:
  bool _internal_has_querydatetime() const;
  public:
  void clear_querydatetime();
  const std::string& querydatetime() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_querydatetime(ArgT0&& arg0, ArgT... args);
  std::string* mutable_querydatetime();
  PROTOBUF_NODISCARD std::string* release_querydatetime();
  void set_allocated_querydatetime(std::string* querydatetime);
  private:
  const std::string& _internal_querydatetime() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_querydatetime(const std::string& value);
  std::string* _internal_mutable_querydatetime();
  public:

  // optional string Sparql = 2;
  bool has_sparql() const;
  private:
  bool _internal_has_sparql() const;
  public:
  void clear_sparql();
  const std::string& sparql() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sparql(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sparql();
  PROTOBUF_NODISCARD std::string* release_sparql();
  void set_allocated_sparql(std::string* sparql);
  private:
  const std::string& _internal_sparql() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sparql(const std::string& value);
  std::string* _internal_mutable_sparql();
  public:

  // optional string Format = 3;
  bool has_format() const;
  private:
  bool _internal_has_format() const;
  public:
  void clear_format();
  const std::string& format() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_format(ArgT0&& arg0, ArgT... args);
  std::string* mutable_format();
  PROTOBUF_NODISCARD std::string* release_format();
  void set_allocated_format(std::string* format);
  private:
  const std::string& _internal_format() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_format(const std::string& value);
  std::string* _internal_mutable_format();
  public:

  // optional string RemoteIP = 4;
  bool has_remoteip() const;
  private:
  bool _internal_has_remoteip() const;
  public:
  void clear_remoteip();
  const std::string& remoteip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_remoteip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_remoteip();
  PROTOBUF_NODISCARD std::string* release_remoteip();
  void set_allocated_remoteip(std::string* remoteip);
  private:
  const std::string& _internal_remoteip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_remoteip(const std::string& value);
  std::string* _internal_mutable_remoteip();
  public:

  // optional string FileName = 5;
  bool has_filename() const;
  private:
  bool _internal_has_filename() const;
  public:
  void clear_filename();
  const std::string& filename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filename();
  PROTOBUF_NODISCARD std::string* release_filename();
  void set_allocated_filename(std::string* filename);
  private:
  const std::string& _internal_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filename(const std::string& value);
  std::string* _internal_mutable_filename();
  public:

  // optional int32 QueryTime = 6;
  bool has_querytime() const;
  private:
  bool _internal_has_querytime() const;
  public:
  void clear_querytime();
  int32_t querytime() const;
  void set_querytime(int32_t value);
  private:
  int32_t _internal_querytime() const;
  void _internal_set_querytime(int32_t value);
  public:

  // optional int32 AnsNum = 7;
  bool has_ansnum() const;
  private:
  bool _internal_has_ansnum() const;
  public:
  void clear_ansnum();
  int32_t ansnum() const;
  void set_ansnum(int32_t value);
  private:
  int32_t _internal_ansnum() const;
  void _internal_set_ansnum(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:QueryLogInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr querydatetime_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sparql_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr format_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr remoteip_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
  int32_t querytime_;
  int32_t ansnum_;
  friend struct ::TableStruct_grpc_2eproto;
};
// -------------------------------------------------------------------

class AccessLogInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AccessLogInfo) */ {
 public:
  inline AccessLogInfo() : AccessLogInfo(nullptr) {}
  ~AccessLogInfo() override;
  explicit constexpr AccessLogInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AccessLogInfo(const AccessLogInfo& from);
  AccessLogInfo(AccessLogInfo&& from) noexcept
    : AccessLogInfo() {
    *this = ::std::move(from);
  }

  inline AccessLogInfo& operator=(const AccessLogInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccessLogInfo& operator=(AccessLogInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AccessLogInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccessLogInfo* internal_default_instance() {
    return reinterpret_cast<const AccessLogInfo*>(
               &_AccessLogInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(AccessLogInfo& a, AccessLogInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(AccessLogInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccessLogInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AccessLogInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AccessLogInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AccessLogInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AccessLogInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccessLogInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AccessLogInfo";
  }
  protected:
  explicit AccessLogInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpFieldNumber = 1,
    kOperationFieldNumber = 2,
    kCreatetimeFieldNumber = 3,
    kMsgFieldNumber = 5,
    kCodeFieldNumber = 4,
  };
  // optional string ip = 1;
  bool has_ip() const;
  private:
  bool _internal_has_ip() const;
  public:
  void clear_ip();
  const std::string& ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip();
  PROTOBUF_NODISCARD std::string* release_ip();
  void set_allocated_ip(std::string* ip);
  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(const std::string& value);
  std::string* _internal_mutable_ip();
  public:

  // optional string operation = 2;
  bool has_operation() const;
  private:
  bool _internal_has_operation() const;
  public:
  void clear_operation();
  const std::string& operation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_operation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_operation();
  PROTOBUF_NODISCARD std::string* release_operation();
  void set_allocated_operation(std::string* operation);
  private:
  const std::string& _internal_operation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operation(const std::string& value);
  std::string* _internal_mutable_operation();
  public:

  // optional string createtime = 3;
  bool has_createtime() const;
  private:
  bool _internal_has_createtime() const;
  public:
  void clear_createtime();
  const std::string& createtime() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_createtime(ArgT0&& arg0, ArgT... args);
  std::string* mutable_createtime();
  PROTOBUF_NODISCARD std::string* release_createtime();
  void set_allocated_createtime(std::string* createtime);
  private:
  const std::string& _internal_createtime() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_createtime(const std::string& value);
  std::string* _internal_mutable_createtime();
  public:

  // optional string msg = 5;
  bool has_msg() const;
  private:
  bool _internal_has_msg() const;
  public:
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // optional int32 code = 4;
  bool has_code() const;
  private:
  bool _internal_has_code() const;
  public:
  void clear_code();
  int32_t code() const;
  void set_code(int32_t value);
  private:
  int32_t _internal_code() const;
  void _internal_set_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:AccessLogInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr operation_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr createtime_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  int32_t code_;
  friend struct ::TableStruct_grpc_2eproto;
};
// -------------------------------------------------------------------

class IPManageInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IPManageInfo) */ {
 public:
  inline IPManageInfo() : IPManageInfo(nullptr) {}
  ~IPManageInfo() override;
  explicit constexpr IPManageInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IPManageInfo(const IPManageInfo& from);
  IPManageInfo(IPManageInfo&& from) noexcept
    : IPManageInfo() {
    *this = ::std::move(from);
  }

  inline IPManageInfo& operator=(const IPManageInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline IPManageInfo& operator=(IPManageInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IPManageInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const IPManageInfo* internal_default_instance() {
    return reinterpret_cast<const IPManageInfo*>(
               &_IPManageInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(IPManageInfo& a, IPManageInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(IPManageInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IPManageInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IPManageInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IPManageInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IPManageInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IPManageInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IPManageInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IPManageInfo";
  }
  protected:
  explicit IPManageInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpsFieldNumber = 2,
    kIpTypeFieldNumber = 1,
  };
  // repeated string ips = 2;
  int ips_size() const;
  private:
  int _internal_ips_size() const;
  public:
  void clear_ips();
  const std::string& ips(int index) const;
  std::string* mutable_ips(int index);
  void set_ips(int index, const std::string& value);
  void set_ips(int index, std::string&& value);
  void set_ips(int index, const char* value);
  void set_ips(int index, const char* value, size_t size);
  std::string* add_ips();
  void add_ips(const std::string& value);
  void add_ips(std::string&& value);
  void add_ips(const char* value);
  void add_ips(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& ips() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_ips();
  private:
  const std::string& _internal_ips(int index) const;
  std::string* _internal_add_ips();
  public:

  // optional string ipType = 1;
  bool has_iptype() const;
  private:
  bool _internal_has_iptype() const;
  public:
  void clear_iptype();
  const std::string& iptype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_iptype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_iptype();
  PROTOBUF_NODISCARD std::string* release_iptype();
  void set_allocated_iptype(std::string* iptype);
  private:
  const std::string& _internal_iptype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_iptype(const std::string& value);
  std::string* _internal_mutable_iptype();
  public:

  // @@protoc_insertion_point(class_scope:IPManageInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> ips_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr iptype_;
  friend struct ::TableStruct_grpc_2eproto;
};
// -------------------------------------------------------------------

class FunInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:FunInfo) */ {
 public:
  inline FunInfo() : FunInfo(nullptr) {}
  ~FunInfo() override;
  explicit constexpr FunInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FunInfo(const FunInfo& from);
  FunInfo(FunInfo&& from) noexcept
    : FunInfo() {
    *this = ::std::move(from);
  }

  inline FunInfo& operator=(const FunInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline FunInfo& operator=(FunInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FunInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const FunInfo* internal_default_instance() {
    return reinterpret_cast<const FunInfo*>(
               &_FunInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(FunInfo& a, FunInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(FunInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FunInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FunInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FunInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FunInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FunInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FunInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "FunInfo";
  }
  protected:
  explicit FunInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFunNameFieldNumber = 1,
    kFunDescFieldNumber = 2,
    kFunArgsFieldNumber = 3,
    kFunBodyFieldNumber = 4,
    kFunSubsFieldNumber = 5,
    kFunStatusFieldNumber = 6,
    kFunReturnFieldNumber = 7,
    kLastTimeFieldNumber = 8,
  };
  // optional string funName = 1;
  bool has_funname() const;
  private:
  bool _internal_has_funname() const;
  public:
  void clear_funname();
  const std::string& funname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_funname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_funname();
  PROTOBUF_NODISCARD std::string* release_funname();
  void set_allocated_funname(std::string* funname);
  private:
  const std::string& _internal_funname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_funname(const std::string& value);
  std::string* _internal_mutable_funname();
  public:

  // optional string funDesc = 2;
  bool has_fundesc() const;
  private:
  bool _internal_has_fundesc() const;
  public:
  void clear_fundesc();
  const std::string& fundesc() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fundesc(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fundesc();
  PROTOBUF_NODISCARD std::string* release_fundesc();
  void set_allocated_fundesc(std::string* fundesc);
  private:
  const std::string& _internal_fundesc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fundesc(const std::string& value);
  std::string* _internal_mutable_fundesc();
  public:

  // optional string funArgs = 3;
  bool has_funargs() const;
  private:
  bool _internal_has_funargs() const;
  public:
  void clear_funargs();
  const std::string& funargs() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_funargs(ArgT0&& arg0, ArgT... args);
  std::string* mutable_funargs();
  PROTOBUF_NODISCARD std::string* release_funargs();
  void set_allocated_funargs(std::string* funargs);
  private:
  const std::string& _internal_funargs() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_funargs(const std::string& value);
  std::string* _internal_mutable_funargs();
  public:

  // optional string funBody = 4;
  bool has_funbody() const;
  private:
  bool _internal_has_funbody() const;
  public:
  void clear_funbody();
  const std::string& funbody() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_funbody(ArgT0&& arg0, ArgT... args);
  std::string* mutable_funbody();
  PROTOBUF_NODISCARD std::string* release_funbody();
  void set_allocated_funbody(std::string* funbody);
  private:
  const std::string& _internal_funbody() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_funbody(const std::string& value);
  std::string* _internal_mutable_funbody();
  public:

  // optional string funSubs = 5;
  bool has_funsubs() const;
  private:
  bool _internal_has_funsubs() const;
  public:
  void clear_funsubs();
  const std::string& funsubs() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_funsubs(ArgT0&& arg0, ArgT... args);
  std::string* mutable_funsubs();
  PROTOBUF_NODISCARD std::string* release_funsubs();
  void set_allocated_funsubs(std::string* funsubs);
  private:
  const std::string& _internal_funsubs() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_funsubs(const std::string& value);
  std::string* _internal_mutable_funsubs();
  public:

  // optional string funStatus = 6;
  bool has_funstatus() const;
  private:
  bool _internal_has_funstatus() const;
  public:
  void clear_funstatus();
  const std::string& funstatus() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_funstatus(ArgT0&& arg0, ArgT... args);
  std::string* mutable_funstatus();
  PROTOBUF_NODISCARD std::string* release_funstatus();
  void set_allocated_funstatus(std::string* funstatus);
  private:
  const std::string& _internal_funstatus() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_funstatus(const std::string& value);
  std::string* _internal_mutable_funstatus();
  public:

  // optional string funReturn = 7;
  bool has_funreturn() const;
  private:
  bool _internal_has_funreturn() const;
  public:
  void clear_funreturn();
  const std::string& funreturn() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_funreturn(ArgT0&& arg0, ArgT... args);
  std::string* mutable_funreturn();
  PROTOBUF_NODISCARD std::string* release_funreturn();
  void set_allocated_funreturn(std::string* funreturn);
  private:
  const std::string& _internal_funreturn() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_funreturn(const std::string& value);
  std::string* _internal_mutable_funreturn();
  public:

  // optional string lastTime = 8;
  bool has_lasttime() const;
  private:
  bool _internal_has_lasttime() const;
  public:
  void clear_lasttime();
  const std::string& lasttime() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_lasttime(ArgT0&& arg0, ArgT... args);
  std::string* mutable_lasttime();
  PROTOBUF_NODISCARD std::string* release_lasttime();
  void set_allocated_lasttime(std::string* lasttime);
  private:
  const std::string& _internal_lasttime() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lasttime(const std::string& value);
  std::string* _internal_mutable_lasttime();
  public:

  // @@protoc_insertion_point(class_scope:FunInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr funname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fundesc_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr funargs_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr funbody_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr funsubs_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr funstatus_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr funreturn_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr lasttime_;
  friend struct ::TableStruct_grpc_2eproto;
};
// -------------------------------------------------------------------

class CommonResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CommonResponse) */ {
 public:
  inline CommonResponse() : CommonResponse(nullptr) {}
  ~CommonResponse() override;
  explicit constexpr CommonResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommonResponse(const CommonResponse& from);
  CommonResponse(CommonResponse&& from) noexcept
    : CommonResponse() {
    *this = ::std::move(from);
  }

  inline CommonResponse& operator=(const CommonResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommonResponse& operator=(CommonResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommonResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommonResponse* internal_default_instance() {
    return reinterpret_cast<const CommonResponse*>(
               &_CommonResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CommonResponse& a, CommonResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CommonResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommonResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommonResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommonResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CommonResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CommonResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommonResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CommonResponse";
  }
  protected:
  explicit CommonResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseBodyFieldNumber = 3,
    kListFieldNumber = 13,
    kStatusMsgFieldNumber = 2,
    kThreadIdFieldNumber = 8,
    kQueryTimeFieldNumber = 9,
    kFileNameFieldNumber = 10,
    kFilepathFieldNumber = 11,
    kTIDFieldNumber = 12,
    kCoreVersionFieldNumber = 14,
    kLicensetypeFieldNumber = 15,
    kRootPathFieldNumber = 16,
    kSuccessNumFieldNumber = 17,
    kBackupfilepathFieldNumber = 22,
    kResultFieldNumber = 23,
    kDatabaseFieldNumber = 24,
    kCreatorFieldNumber = 25,
    kBuiltTimeFieldNumber = 26,
    kTripleNumFieldNumber = 27,
    kHeadFieldNumber = 4,
    kResultsFieldNumber = 5,
    kStatusCodeFieldNumber = 1,
    kAnsNumFieldNumber = 6,
    kOutputLimitFieldNumber = 7,
    kTotalSizeFieldNumber = 18,
    kTotalPageFieldNumber = 19,
    kPageNoFieldNumber = 20,
    kPageSizeFieldNumber = 21,
    kEntityNumFieldNumber = 28,
    kLiteralNumFieldNumber = 29,
    kSubjectNumFieldNumber = 30,
    kPredicateNumFieldNumber = 31,
    kConnectionNumFieldNumber = 32,
  };
  // repeated .google.protobuf.Any ResponseBody = 3;
  int responsebody_size() const;
  private:
  int _internal_responsebody_size() const;
  public:
  void clear_responsebody();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_responsebody(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any >*
      mutable_responsebody();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_responsebody(int index) const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_add_responsebody();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Any& responsebody(int index) const;
  ::PROTOBUF_NAMESPACE_ID::Any* add_responsebody();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any >&
      responsebody() const;

  // repeated .google.protobuf.Any list = 13;
  int list_size() const;
  private:
  int _internal_list_size() const;
  public:
  void clear_list();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any >*
      mutable_list();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_list(int index) const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_add_list();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Any& list(int index) const;
  ::PROTOBUF_NAMESPACE_ID::Any* add_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any >&
      list() const;

  // optional string StatusMsg = 2;
  bool has_statusmsg() const;
  private:
  bool _internal_has_statusmsg() const;
  public:
  void clear_statusmsg();
  const std::string& statusmsg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_statusmsg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_statusmsg();
  PROTOBUF_NODISCARD std::string* release_statusmsg();
  void set_allocated_statusmsg(std::string* statusmsg);
  private:
  const std::string& _internal_statusmsg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_statusmsg(const std::string& value);
  std::string* _internal_mutable_statusmsg();
  public:

  // optional string ThreadId = 8;
  bool has_threadid() const;
  private:
  bool _internal_has_threadid() const;
  public:
  void clear_threadid();
  const std::string& threadid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_threadid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_threadid();
  PROTOBUF_NODISCARD std::string* release_threadid();
  void set_allocated_threadid(std::string* threadid);
  private:
  const std::string& _internal_threadid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_threadid(const std::string& value);
  std::string* _internal_mutable_threadid();
  public:

  // optional string QueryTime = 9;
  bool has_querytime() const;
  private:
  bool _internal_has_querytime() const;
  public:
  void clear_querytime();
  const std::string& querytime() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_querytime(ArgT0&& arg0, ArgT... args);
  std::string* mutable_querytime();
  PROTOBUF_NODISCARD std::string* release_querytime();
  void set_allocated_querytime(std::string* querytime);
  private:
  const std::string& _internal_querytime() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_querytime(const std::string& value);
  std::string* _internal_mutable_querytime();
  public:

  // optional string FileName = 10;
  bool has_filename() const;
  private:
  bool _internal_has_filename() const;
  public:
  void clear_filename();
  const std::string& filename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filename();
  PROTOBUF_NODISCARD std::string* release_filename();
  void set_allocated_filename(std::string* filename);
  private:
  const std::string& _internal_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filename(const std::string& value);
  std::string* _internal_mutable_filename();
  public:

  // optional string filepath = 11;
  bool has_filepath() const;
  private:
  bool _internal_has_filepath() const;
  public:
  void clear_filepath();
  const std::string& filepath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filepath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filepath();
  PROTOBUF_NODISCARD std::string* release_filepath();
  void set_allocated_filepath(std::string* filepath);
  private:
  const std::string& _internal_filepath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filepath(const std::string& value);
  std::string* _internal_mutable_filepath();
  public:

  // optional string TID = 12;
  bool has_tid() const;
  private:
  bool _internal_has_tid() const;
  public:
  void clear_tid();
  const std::string& tid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tid();
  PROTOBUF_NODISCARD std::string* release_tid();
  void set_allocated_tid(std::string* tid);
  private:
  const std::string& _internal_tid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tid(const std::string& value);
  std::string* _internal_mutable_tid();
  public:

  // optional string CoreVersion = 14;
  bool has_coreversion() const;
  private:
  bool _internal_has_coreversion() const;
  public:
  void clear_coreversion();
  const std::string& coreversion() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_coreversion(ArgT0&& arg0, ArgT... args);
  std::string* mutable_coreversion();
  PROTOBUF_NODISCARD std::string* release_coreversion();
  void set_allocated_coreversion(std::string* coreversion);
  private:
  const std::string& _internal_coreversion() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_coreversion(const std::string& value);
  std::string* _internal_mutable_coreversion();
  public:

  // optional string licensetype = 15;
  bool has_licensetype() const;
  private:
  bool _internal_has_licensetype() const;
  public:
  void clear_licensetype();
  const std::string& licensetype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_licensetype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_licensetype();
  PROTOBUF_NODISCARD std::string* release_licensetype();
  void set_allocated_licensetype(std::string* licensetype);
  private:
  const std::string& _internal_licensetype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_licensetype(const std::string& value);
  std::string* _internal_mutable_licensetype();
  public:

  // optional string RootPath = 16;
  bool has_rootpath() const;
  private:
  bool _internal_has_rootpath() const;
  public:
  void clear_rootpath();
  const std::string& rootpath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rootpath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rootpath();
  PROTOBUF_NODISCARD std::string* release_rootpath();
  void set_allocated_rootpath(std::string* rootpath);
  private:
  const std::string& _internal_rootpath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rootpath(const std::string& value);
  std::string* _internal_mutable_rootpath();
  public:

  // optional string successNum = 17;
  bool has_successnum() const;
  private:
  bool _internal_has_successnum() const;
  public:
  void clear_successnum();
  const std::string& successnum() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_successnum(ArgT0&& arg0, ArgT... args);
  std::string* mutable_successnum();
  PROTOBUF_NODISCARD std::string* release_successnum();
  void set_allocated_successnum(std::string* successnum);
  private:
  const std::string& _internal_successnum() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_successnum(const std::string& value);
  std::string* _internal_mutable_successnum();
  public:

  // optional string backupfilepath = 22;
  bool has_backupfilepath() const;
  private:
  bool _internal_has_backupfilepath() const;
  public:
  void clear_backupfilepath();
  const std::string& backupfilepath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_backupfilepath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_backupfilepath();
  PROTOBUF_NODISCARD std::string* release_backupfilepath();
  void set_allocated_backupfilepath(std::string* backupfilepath);
  private:
  const std::string& _internal_backupfilepath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_backupfilepath(const std::string& value);
  std::string* _internal_mutable_backupfilepath();
  public:

  // optional string Result = 23;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const std::string& result() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_result(ArgT0&& arg0, ArgT... args);
  std::string* mutable_result();
  PROTOBUF_NODISCARD std::string* release_result();
  void set_allocated_result(std::string* result);
  private:
  const std::string& _internal_result() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_result(const std::string& value);
  std::string* _internal_mutable_result();
  public:

  // optional string database = 24;
  bool has_database() const;
  private:
  bool _internal_has_database() const;
  public:
  void clear_database();
  const std::string& database() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_database(ArgT0&& arg0, ArgT... args);
  std::string* mutable_database();
  PROTOBUF_NODISCARD std::string* release_database();
  void set_allocated_database(std::string* database);
  private:
  const std::string& _internal_database() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_database(const std::string& value);
  std::string* _internal_mutable_database();
  public:

  // optional string creator = 25;
  bool has_creator() const;
  private:
  bool _internal_has_creator() const;
  public:
  void clear_creator();
  const std::string& creator() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_creator(ArgT0&& arg0, ArgT... args);
  std::string* mutable_creator();
  PROTOBUF_NODISCARD std::string* release_creator();
  void set_allocated_creator(std::string* creator);
  private:
  const std::string& _internal_creator() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_creator(const std::string& value);
  std::string* _internal_mutable_creator();
  public:

  // optional string builtTime = 26;
  bool has_builttime() const;
  private:
  bool _internal_has_builttime() const;
  public:
  void clear_builttime();
  const std::string& builttime() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_builttime(ArgT0&& arg0, ArgT... args);
  std::string* mutable_builttime();
  PROTOBUF_NODISCARD std::string* release_builttime();
  void set_allocated_builttime(std::string* builttime);
  private:
  const std::string& _internal_builttime() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_builttime(const std::string& value);
  std::string* _internal_mutable_builttime();
  public:

  // optional string tripleNum = 27;
  bool has_triplenum() const;
  private:
  bool _internal_has_triplenum() const;
  public:
  void clear_triplenum();
  const std::string& triplenum() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_triplenum(ArgT0&& arg0, ArgT... args);
  std::string* mutable_triplenum();
  PROTOBUF_NODISCARD std::string* release_triplenum();
  void set_allocated_triplenum(std::string* triplenum);
  private:
  const std::string& _internal_triplenum() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_triplenum(const std::string& value);
  std::string* _internal_mutable_triplenum();
  public:

  // optional .QueryHeadInfo head = 4;
  bool has_head() const;
  private:
  bool _internal_has_head() const;
  public:
  void clear_head();
  const ::QueryHeadInfo& head() const;
  PROTOBUF_NODISCARD ::QueryHeadInfo* release_head();
  ::QueryHeadInfo* mutable_head();
  void set_allocated_head(::QueryHeadInfo* head);
  private:
  const ::QueryHeadInfo& _internal_head() const;
  ::QueryHeadInfo* _internal_mutable_head();
  public:
  void unsafe_arena_set_allocated_head(
      ::QueryHeadInfo* head);
  ::QueryHeadInfo* unsafe_arena_release_head();

  // optional .QueryResultInfo results = 5;
  bool has_results() const;
  private:
  bool _internal_has_results() const;
  public:
  void clear_results();
  const ::QueryResultInfo& results() const;
  PROTOBUF_NODISCARD ::QueryResultInfo* release_results();
  ::QueryResultInfo* mutable_results();
  void set_allocated_results(::QueryResultInfo* results);
  private:
  const ::QueryResultInfo& _internal_results() const;
  ::QueryResultInfo* _internal_mutable_results();
  public:
  void unsafe_arena_set_allocated_results(
      ::QueryResultInfo* results);
  ::QueryResultInfo* unsafe_arena_release_results();

  // optional int32 StatusCode = 1;
  bool has_statuscode() const;
  private:
  bool _internal_has_statuscode() const;
  public:
  void clear_statuscode();
  int32_t statuscode() const;
  void set_statuscode(int32_t value);
  private:
  int32_t _internal_statuscode() const;
  void _internal_set_statuscode(int32_t value);
  public:

  // optional int32 AnsNum = 6;
  bool has_ansnum() const;
  private:
  bool _internal_has_ansnum() const;
  public:
  void clear_ansnum();
  int32_t ansnum() const;
  void set_ansnum(int32_t value);
  private:
  int32_t _internal_ansnum() const;
  void _internal_set_ansnum(int32_t value);
  public:

  // optional int32 OutputLimit = 7;
  bool has_outputlimit() const;
  private:
  bool _internal_has_outputlimit() const;
  public:
  void clear_outputlimit();
  int32_t outputlimit() const;
  void set_outputlimit(int32_t value);
  private:
  int32_t _internal_outputlimit() const;
  void _internal_set_outputlimit(int32_t value);
  public:

  // optional int32 totalSize = 18;
  bool has_totalsize() const;
  private:
  bool _internal_has_totalsize() const;
  public:
  void clear_totalsize();
  int32_t totalsize() const;
  void set_totalsize(int32_t value);
  private:
  int32_t _internal_totalsize() const;
  void _internal_set_totalsize(int32_t value);
  public:

  // optional int32 totalPage = 19;
  bool has_totalpage() const;
  private:
  bool _internal_has_totalpage() const;
  public:
  void clear_totalpage();
  int32_t totalpage() const;
  void set_totalpage(int32_t value);
  private:
  int32_t _internal_totalpage() const;
  void _internal_set_totalpage(int32_t value);
  public:

  // optional int32 pageNo = 20;
  bool has_pageno() const;
  private:
  bool _internal_has_pageno() const;
  public:
  void clear_pageno();
  int32_t pageno() const;
  void set_pageno(int32_t value);
  private:
  int32_t _internal_pageno() const;
  void _internal_set_pageno(int32_t value);
  public:

  // optional int32 pageSize = 21;
  bool has_pagesize() const;
  private:
  bool _internal_has_pagesize() const;
  public:
  void clear_pagesize();
  int32_t pagesize() const;
  void set_pagesize(int32_t value);
  private:
  int32_t _internal_pagesize() const;
  void _internal_set_pagesize(int32_t value);
  public:

  // optional int32 entityNum = 28;
  bool has_entitynum() const;
  private:
  bool _internal_has_entitynum() const;
  public:
  void clear_entitynum();
  int32_t entitynum() const;
  void set_entitynum(int32_t value);
  private:
  int32_t _internal_entitynum() const;
  void _internal_set_entitynum(int32_t value);
  public:

  // optional int32 literalNum = 29;
  bool has_literalnum() const;
  private:
  bool _internal_has_literalnum() const;
  public:
  void clear_literalnum();
  int32_t literalnum() const;
  void set_literalnum(int32_t value);
  private:
  int32_t _internal_literalnum() const;
  void _internal_set_literalnum(int32_t value);
  public:

  // optional int32 subjectNum = 30;
  bool has_subjectnum() const;
  private:
  bool _internal_has_subjectnum() const;
  public:
  void clear_subjectnum();
  int32_t subjectnum() const;
  void set_subjectnum(int32_t value);
  private:
  int32_t _internal_subjectnum() const;
  void _internal_set_subjectnum(int32_t value);
  public:

  // optional int32 predicateNum = 31;
  bool has_predicatenum() const;
  private:
  bool _internal_has_predicatenum() const;
  public:
  void clear_predicatenum();
  int32_t predicatenum() const;
  void set_predicatenum(int32_t value);
  private:
  int32_t _internal_predicatenum() const;
  void _internal_set_predicatenum(int32_t value);
  public:

  // optional int32 connectionNum = 32;
  bool has_connectionnum() const;
  private:
  bool _internal_has_connectionnum() const;
  public:
  void clear_connectionnum();
  int32_t connectionnum() const;
  void set_connectionnum(int32_t value);
  private:
  int32_t _internal_connectionnum() const;
  void _internal_set_connectionnum(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CommonResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any > responsebody_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any > list_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr statusmsg_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr threadid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr querytime_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filepath_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr coreversion_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr licensetype_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rootpath_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr successnum_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr backupfilepath_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr result_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr database_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr creator_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr builttime_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr triplenum_;
  ::QueryHeadInfo* head_;
  ::QueryResultInfo* results_;
  int32_t statuscode_;
  int32_t ansnum_;
  int32_t outputlimit_;
  int32_t totalsize_;
  int32_t totalpage_;
  int32_t pageno_;
  int32_t pagesize_;
  int32_t entitynum_;
  int32_t literalnum_;
  int32_t subjectnum_;
  int32_t predicatenum_;
  int32_t connectionnum_;
  friend struct ::TableStruct_grpc_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CommonRequest

// required string username = 1;
inline bool CommonRequest::_internal_has_username() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommonRequest::has_username() const {
  return _internal_has_username();
}
inline void CommonRequest::clear_username() {
  username_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommonRequest::username() const {
  // @@protoc_insertion_point(field_get:CommonRequest.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonRequest::set_username(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonRequest.username)
}
inline std::string* CommonRequest::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:CommonRequest.username)
  return _s;
}
inline const std::string& CommonRequest::_internal_username() const {
  return username_.Get();
}
inline void CommonRequest::_internal_set_username(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonRequest::_internal_mutable_username() {
  _has_bits_[0] |= 0x00000001u;
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonRequest::release_username() {
  // @@protoc_insertion_point(field_release:CommonRequest.username)
  if (!_internal_has_username()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = username_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (username_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonRequest::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (username_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonRequest.username)
}

// required string password = 2;
inline bool CommonRequest::_internal_has_password() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommonRequest::has_password() const {
  return _internal_has_password();
}
inline void CommonRequest::clear_password() {
  password_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CommonRequest::password() const {
  // @@protoc_insertion_point(field_get:CommonRequest.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonRequest::set_password(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonRequest.password)
}
inline std::string* CommonRequest::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:CommonRequest.password)
  return _s;
}
inline const std::string& CommonRequest::_internal_password() const {
  return password_.Get();
}
inline void CommonRequest::_internal_set_password(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonRequest::_internal_mutable_password() {
  _has_bits_[0] |= 0x00000002u;
  return password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonRequest::release_password() {
  // @@protoc_insertion_point(field_release:CommonRequest.password)
  if (!_internal_has_password()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = password_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (password_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonRequest::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (password_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonRequest.password)
}

// optional string operation = 3;
inline bool CommonRequest::_internal_has_operation() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CommonRequest::has_operation() const {
  return _internal_has_operation();
}
inline void CommonRequest::clear_operation() {
  operation_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CommonRequest::operation() const {
  // @@protoc_insertion_point(field_get:CommonRequest.operation)
  return _internal_operation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonRequest::set_operation(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 operation_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonRequest.operation)
}
inline std::string* CommonRequest::mutable_operation() {
  std::string* _s = _internal_mutable_operation();
  // @@protoc_insertion_point(field_mutable:CommonRequest.operation)
  return _s;
}
inline const std::string& CommonRequest::_internal_operation() const {
  return operation_.Get();
}
inline void CommonRequest::_internal_set_operation(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  operation_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonRequest::_internal_mutable_operation() {
  _has_bits_[0] |= 0x00000004u;
  return operation_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonRequest::release_operation() {
  // @@protoc_insertion_point(field_release:CommonRequest.operation)
  if (!_internal_has_operation()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = operation_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (operation_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    operation_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonRequest::set_allocated_operation(std::string* operation) {
  if (operation != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  operation_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), operation,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (operation_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    operation_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonRequest.operation)
}

// optional string encryption = 4;
inline bool CommonRequest::_internal_has_encryption() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CommonRequest::has_encryption() const {
  return _internal_has_encryption();
}
inline void CommonRequest::clear_encryption() {
  encryption_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CommonRequest::encryption() const {
  // @@protoc_insertion_point(field_get:CommonRequest.encryption)
  return _internal_encryption();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonRequest::set_encryption(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 encryption_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonRequest.encryption)
}
inline std::string* CommonRequest::mutable_encryption() {
  std::string* _s = _internal_mutable_encryption();
  // @@protoc_insertion_point(field_mutable:CommonRequest.encryption)
  return _s;
}
inline const std::string& CommonRequest::_internal_encryption() const {
  return encryption_.Get();
}
inline void CommonRequest::_internal_set_encryption(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  encryption_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonRequest::_internal_mutable_encryption() {
  _has_bits_[0] |= 0x00000008u;
  return encryption_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonRequest::release_encryption() {
  // @@protoc_insertion_point(field_release:CommonRequest.encryption)
  if (!_internal_has_encryption()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = encryption_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (encryption_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    encryption_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonRequest::set_allocated_encryption(std::string* encryption) {
  if (encryption != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  encryption_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), encryption,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (encryption_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    encryption_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonRequest.encryption)
}

// optional string db_name = 5;
inline bool CommonRequest::_internal_has_db_name() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CommonRequest::has_db_name() const {
  return _internal_has_db_name();
}
inline void CommonRequest::clear_db_name() {
  db_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& CommonRequest::db_name() const {
  // @@protoc_insertion_point(field_get:CommonRequest.db_name)
  return _internal_db_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonRequest::set_db_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 db_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonRequest.db_name)
}
inline std::string* CommonRequest::mutable_db_name() {
  std::string* _s = _internal_mutable_db_name();
  // @@protoc_insertion_point(field_mutable:CommonRequest.db_name)
  return _s;
}
inline const std::string& CommonRequest::_internal_db_name() const {
  return db_name_.Get();
}
inline void CommonRequest::_internal_set_db_name(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  db_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonRequest::_internal_mutable_db_name() {
  _has_bits_[0] |= 0x00000010u;
  return db_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonRequest::release_db_name() {
  // @@protoc_insertion_point(field_release:CommonRequest.db_name)
  if (!_internal_has_db_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = db_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (db_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    db_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonRequest::set_allocated_db_name(std::string* db_name) {
  if (db_name != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  db_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), db_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (db_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    db_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonRequest.db_name)
}

// optional string db_path = 6;
inline bool CommonRequest::_internal_has_db_path() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CommonRequest::has_db_path() const {
  return _internal_has_db_path();
}
inline void CommonRequest::clear_db_path() {
  db_path_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& CommonRequest::db_path() const {
  // @@protoc_insertion_point(field_get:CommonRequest.db_path)
  return _internal_db_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonRequest::set_db_path(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 db_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonRequest.db_path)
}
inline std::string* CommonRequest::mutable_db_path() {
  std::string* _s = _internal_mutable_db_path();
  // @@protoc_insertion_point(field_mutable:CommonRequest.db_path)
  return _s;
}
inline const std::string& CommonRequest::_internal_db_path() const {
  return db_path_.Get();
}
inline void CommonRequest::_internal_set_db_path(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  db_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonRequest::_internal_mutable_db_path() {
  _has_bits_[0] |= 0x00000020u;
  return db_path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonRequest::release_db_path() {
  // @@protoc_insertion_point(field_release:CommonRequest.db_path)
  if (!_internal_has_db_path()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  auto* p = db_path_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (db_path_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    db_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonRequest::set_allocated_db_path(std::string* db_path) {
  if (db_path != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  db_path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), db_path,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (db_path_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    db_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonRequest.db_path)
}

// optional string load_csr = 7;
inline bool CommonRequest::_internal_has_load_csr() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CommonRequest::has_load_csr() const {
  return _internal_has_load_csr();
}
inline void CommonRequest::clear_load_csr() {
  load_csr_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& CommonRequest::load_csr() const {
  // @@protoc_insertion_point(field_get:CommonRequest.load_csr)
  return _internal_load_csr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonRequest::set_load_csr(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000040u;
 load_csr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonRequest.load_csr)
}
inline std::string* CommonRequest::mutable_load_csr() {
  std::string* _s = _internal_mutable_load_csr();
  // @@protoc_insertion_point(field_mutable:CommonRequest.load_csr)
  return _s;
}
inline const std::string& CommonRequest::_internal_load_csr() const {
  return load_csr_.Get();
}
inline void CommonRequest::_internal_set_load_csr(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  load_csr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonRequest::_internal_mutable_load_csr() {
  _has_bits_[0] |= 0x00000040u;
  return load_csr_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonRequest::release_load_csr() {
  // @@protoc_insertion_point(field_release:CommonRequest.load_csr)
  if (!_internal_has_load_csr()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  auto* p = load_csr_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (load_csr_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    load_csr_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonRequest::set_allocated_load_csr(std::string* load_csr) {
  if (load_csr != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  load_csr_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), load_csr,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (load_csr_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    load_csr_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonRequest.load_csr)
}

// optional string is_backup = 8;
inline bool CommonRequest::_internal_has_is_backup() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CommonRequest::has_is_backup() const {
  return _internal_has_is_backup();
}
inline void CommonRequest::clear_is_backup() {
  is_backup_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000080u;
}
inline const std::string& CommonRequest::is_backup() const {
  // @@protoc_insertion_point(field_get:CommonRequest.is_backup)
  return _internal_is_backup();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonRequest::set_is_backup(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000080u;
 is_backup_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonRequest.is_backup)
}
inline std::string* CommonRequest::mutable_is_backup() {
  std::string* _s = _internal_mutable_is_backup();
  // @@protoc_insertion_point(field_mutable:CommonRequest.is_backup)
  return _s;
}
inline const std::string& CommonRequest::_internal_is_backup() const {
  return is_backup_.Get();
}
inline void CommonRequest::_internal_set_is_backup(const std::string& value) {
  _has_bits_[0] |= 0x00000080u;
  is_backup_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonRequest::_internal_mutable_is_backup() {
  _has_bits_[0] |= 0x00000080u;
  return is_backup_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonRequest::release_is_backup() {
  // @@protoc_insertion_point(field_release:CommonRequest.is_backup)
  if (!_internal_has_is_backup()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000080u;
  auto* p = is_backup_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (is_backup_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    is_backup_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonRequest::set_allocated_is_backup(std::string* is_backup) {
  if (is_backup != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  is_backup_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), is_backup,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (is_backup_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    is_backup_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonRequest.is_backup)
}

// optional string type = 9;
inline bool CommonRequest::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CommonRequest::has_type() const {
  return _internal_has_type();
}
inline void CommonRequest::clear_type() {
  type_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000100u;
}
inline const std::string& CommonRequest::type() const {
  // @@protoc_insertion_point(field_get:CommonRequest.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonRequest::set_type(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000100u;
 type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonRequest.type)
}
inline std::string* CommonRequest::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:CommonRequest.type)
  return _s;
}
inline const std::string& CommonRequest::_internal_type() const {
  return type_.Get();
}
inline void CommonRequest::_internal_set_type(const std::string& value) {
  _has_bits_[0] |= 0x00000100u;
  type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonRequest::_internal_mutable_type() {
  _has_bits_[0] |= 0x00000100u;
  return type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonRequest::release_type() {
  // @@protoc_insertion_point(field_release:CommonRequest.type)
  if (!_internal_has_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000100u;
  auto* p = type_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonRequest::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonRequest.type)
}

// optional string op_username = 10;
inline bool CommonRequest::_internal_has_op_username() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool CommonRequest::has_op_username() const {
  return _internal_has_op_username();
}
inline void CommonRequest::clear_op_username() {
  op_username_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000200u;
}
inline const std::string& CommonRequest::op_username() const {
  // @@protoc_insertion_point(field_get:CommonRequest.op_username)
  return _internal_op_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonRequest::set_op_username(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000200u;
 op_username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonRequest.op_username)
}
inline std::string* CommonRequest::mutable_op_username() {
  std::string* _s = _internal_mutable_op_username();
  // @@protoc_insertion_point(field_mutable:CommonRequest.op_username)
  return _s;
}
inline const std::string& CommonRequest::_internal_op_username() const {
  return op_username_.Get();
}
inline void CommonRequest::_internal_set_op_username(const std::string& value) {
  _has_bits_[0] |= 0x00000200u;
  op_username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonRequest::_internal_mutable_op_username() {
  _has_bits_[0] |= 0x00000200u;
  return op_username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonRequest::release_op_username() {
  // @@protoc_insertion_point(field_release:CommonRequest.op_username)
  if (!_internal_has_op_username()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000200u;
  auto* p = op_username_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (op_username_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    op_username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonRequest::set_allocated_op_username(std::string* op_username) {
  if (op_username != nullptr) {
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  op_username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), op_username,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (op_username_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    op_username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonRequest.op_username)
}

// optional string op_password = 11;
inline bool CommonRequest::_internal_has_op_password() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool CommonRequest::has_op_password() const {
  return _internal_has_op_password();
}
inline void CommonRequest::clear_op_password() {
  op_password_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000400u;
}
inline const std::string& CommonRequest::op_password() const {
  // @@protoc_insertion_point(field_get:CommonRequest.op_password)
  return _internal_op_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonRequest::set_op_password(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000400u;
 op_password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonRequest.op_password)
}
inline std::string* CommonRequest::mutable_op_password() {
  std::string* _s = _internal_mutable_op_password();
  // @@protoc_insertion_point(field_mutable:CommonRequest.op_password)
  return _s;
}
inline const std::string& CommonRequest::_internal_op_password() const {
  return op_password_.Get();
}
inline void CommonRequest::_internal_set_op_password(const std::string& value) {
  _has_bits_[0] |= 0x00000400u;
  op_password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonRequest::_internal_mutable_op_password() {
  _has_bits_[0] |= 0x00000400u;
  return op_password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonRequest::release_op_password() {
  // @@protoc_insertion_point(field_release:CommonRequest.op_password)
  if (!_internal_has_op_password()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000400u;
  auto* p = op_password_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (op_password_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    op_password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonRequest::set_allocated_op_password(std::string* op_password) {
  if (op_password != nullptr) {
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  op_password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), op_password,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (op_password_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    op_password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonRequest.op_password)
}

// optional string privileges = 12;
inline bool CommonRequest::_internal_has_privileges() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool CommonRequest::has_privileges() const {
  return _internal_has_privileges();
}
inline void CommonRequest::clear_privileges() {
  privileges_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000800u;
}
inline const std::string& CommonRequest::privileges() const {
  // @@protoc_insertion_point(field_get:CommonRequest.privileges)
  return _internal_privileges();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonRequest::set_privileges(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000800u;
 privileges_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonRequest.privileges)
}
inline std::string* CommonRequest::mutable_privileges() {
  std::string* _s = _internal_mutable_privileges();
  // @@protoc_insertion_point(field_mutable:CommonRequest.privileges)
  return _s;
}
inline const std::string& CommonRequest::_internal_privileges() const {
  return privileges_.Get();
}
inline void CommonRequest::_internal_set_privileges(const std::string& value) {
  _has_bits_[0] |= 0x00000800u;
  privileges_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonRequest::_internal_mutable_privileges() {
  _has_bits_[0] |= 0x00000800u;
  return privileges_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonRequest::release_privileges() {
  // @@protoc_insertion_point(field_release:CommonRequest.privileges)
  if (!_internal_has_privileges()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000800u;
  auto* p = privileges_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (privileges_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    privileges_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonRequest::set_allocated_privileges(std::string* privileges) {
  if (privileges != nullptr) {
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  privileges_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), privileges,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (privileges_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    privileges_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonRequest.privileges)
}

// optional string backup_path = 13;
inline bool CommonRequest::_internal_has_backup_path() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool CommonRequest::has_backup_path() const {
  return _internal_has_backup_path();
}
inline void CommonRequest::clear_backup_path() {
  backup_path_.ClearToEmpty();
  _has_bits_[0] &= ~0x00001000u;
}
inline const std::string& CommonRequest::backup_path() const {
  // @@protoc_insertion_point(field_get:CommonRequest.backup_path)
  return _internal_backup_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonRequest::set_backup_path(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00001000u;
 backup_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonRequest.backup_path)
}
inline std::string* CommonRequest::mutable_backup_path() {
  std::string* _s = _internal_mutable_backup_path();
  // @@protoc_insertion_point(field_mutable:CommonRequest.backup_path)
  return _s;
}
inline const std::string& CommonRequest::_internal_backup_path() const {
  return backup_path_.Get();
}
inline void CommonRequest::_internal_set_backup_path(const std::string& value) {
  _has_bits_[0] |= 0x00001000u;
  backup_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonRequest::_internal_mutable_backup_path() {
  _has_bits_[0] |= 0x00001000u;
  return backup_path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonRequest::release_backup_path() {
  // @@protoc_insertion_point(field_release:CommonRequest.backup_path)
  if (!_internal_has_backup_path()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00001000u;
  auto* p = backup_path_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (backup_path_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    backup_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonRequest::set_allocated_backup_path(std::string* backup_path) {
  if (backup_path != nullptr) {
    _has_bits_[0] |= 0x00001000u;
  } else {
    _has_bits_[0] &= ~0x00001000u;
  }
  backup_path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), backup_path,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (backup_path_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    backup_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonRequest.backup_path)
}

// optional string sparql = 14;
inline bool CommonRequest::_internal_has_sparql() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool CommonRequest::has_sparql() const {
  return _internal_has_sparql();
}
inline void CommonRequest::clear_sparql() {
  sparql_.ClearToEmpty();
  _has_bits_[0] &= ~0x00002000u;
}
inline const std::string& CommonRequest::sparql() const {
  // @@protoc_insertion_point(field_get:CommonRequest.sparql)
  return _internal_sparql();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonRequest::set_sparql(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00002000u;
 sparql_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonRequest.sparql)
}
inline std::string* CommonRequest::mutable_sparql() {
  std::string* _s = _internal_mutable_sparql();
  // @@protoc_insertion_point(field_mutable:CommonRequest.sparql)
  return _s;
}
inline const std::string& CommonRequest::_internal_sparql() const {
  return sparql_.Get();
}
inline void CommonRequest::_internal_set_sparql(const std::string& value) {
  _has_bits_[0] |= 0x00002000u;
  sparql_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonRequest::_internal_mutable_sparql() {
  _has_bits_[0] |= 0x00002000u;
  return sparql_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonRequest::release_sparql() {
  // @@protoc_insertion_point(field_release:CommonRequest.sparql)
  if (!_internal_has_sparql()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00002000u;
  auto* p = sparql_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sparql_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sparql_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonRequest::set_allocated_sparql(std::string* sparql) {
  if (sparql != nullptr) {
    _has_bits_[0] |= 0x00002000u;
  } else {
    _has_bits_[0] &= ~0x00002000u;
  }
  sparql_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sparql,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sparql_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sparql_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonRequest.sparql)
}

// optional string format = 15;
inline bool CommonRequest::_internal_has_format() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool CommonRequest::has_format() const {
  return _internal_has_format();
}
inline void CommonRequest::clear_format() {
  format_.ClearToEmpty();
  _has_bits_[0] &= ~0x00004000u;
}
inline const std::string& CommonRequest::format() const {
  // @@protoc_insertion_point(field_get:CommonRequest.format)
  return _internal_format();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonRequest::set_format(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00004000u;
 format_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonRequest.format)
}
inline std::string* CommonRequest::mutable_format() {
  std::string* _s = _internal_mutable_format();
  // @@protoc_insertion_point(field_mutable:CommonRequest.format)
  return _s;
}
inline const std::string& CommonRequest::_internal_format() const {
  return format_.Get();
}
inline void CommonRequest::_internal_set_format(const std::string& value) {
  _has_bits_[0] |= 0x00004000u;
  format_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonRequest::_internal_mutable_format() {
  _has_bits_[0] |= 0x00004000u;
  return format_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonRequest::release_format() {
  // @@protoc_insertion_point(field_release:CommonRequest.format)
  if (!_internal_has_format()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00004000u;
  auto* p = format_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (format_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    format_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonRequest::set_allocated_format(std::string* format) {
  if (format != nullptr) {
    _has_bits_[0] |= 0x00004000u;
  } else {
    _has_bits_[0] &= ~0x00004000u;
  }
  format_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), format,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (format_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    format_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonRequest.format)
}

// optional string isolevel = 16;
inline bool CommonRequest::_internal_has_isolevel() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool CommonRequest::has_isolevel() const {
  return _internal_has_isolevel();
}
inline void CommonRequest::clear_isolevel() {
  isolevel_.ClearToEmpty();
  _has_bits_[0] &= ~0x00008000u;
}
inline const std::string& CommonRequest::isolevel() const {
  // @@protoc_insertion_point(field_get:CommonRequest.isolevel)
  return _internal_isolevel();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonRequest::set_isolevel(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00008000u;
 isolevel_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonRequest.isolevel)
}
inline std::string* CommonRequest::mutable_isolevel() {
  std::string* _s = _internal_mutable_isolevel();
  // @@protoc_insertion_point(field_mutable:CommonRequest.isolevel)
  return _s;
}
inline const std::string& CommonRequest::_internal_isolevel() const {
  return isolevel_.Get();
}
inline void CommonRequest::_internal_set_isolevel(const std::string& value) {
  _has_bits_[0] |= 0x00008000u;
  isolevel_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonRequest::_internal_mutable_isolevel() {
  _has_bits_[0] |= 0x00008000u;
  return isolevel_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonRequest::release_isolevel() {
  // @@protoc_insertion_point(field_release:CommonRequest.isolevel)
  if (!_internal_has_isolevel()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00008000u;
  auto* p = isolevel_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (isolevel_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    isolevel_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonRequest::set_allocated_isolevel(std::string* isolevel) {
  if (isolevel != nullptr) {
    _has_bits_[0] |= 0x00008000u;
  } else {
    _has_bits_[0] &= ~0x00008000u;
  }
  isolevel_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), isolevel,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (isolevel_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    isolevel_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonRequest.isolevel)
}

// optional string tid = 17;
inline bool CommonRequest::_internal_has_tid() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool CommonRequest::has_tid() const {
  return _internal_has_tid();
}
inline void CommonRequest::clear_tid() {
  tid_.ClearToEmpty();
  _has_bits_[0] &= ~0x00010000u;
}
inline const std::string& CommonRequest::tid() const {
  // @@protoc_insertion_point(field_get:CommonRequest.tid)
  return _internal_tid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonRequest::set_tid(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00010000u;
 tid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonRequest.tid)
}
inline std::string* CommonRequest::mutable_tid() {
  std::string* _s = _internal_mutable_tid();
  // @@protoc_insertion_point(field_mutable:CommonRequest.tid)
  return _s;
}
inline const std::string& CommonRequest::_internal_tid() const {
  return tid_.Get();
}
inline void CommonRequest::_internal_set_tid(const std::string& value) {
  _has_bits_[0] |= 0x00010000u;
  tid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonRequest::_internal_mutable_tid() {
  _has_bits_[0] |= 0x00010000u;
  return tid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonRequest::release_tid() {
  // @@protoc_insertion_point(field_release:CommonRequest.tid)
  if (!_internal_has_tid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00010000u;
  auto* p = tid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    tid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonRequest::set_allocated_tid(std::string* tid) {
  if (tid != nullptr) {
    _has_bits_[0] |= 0x00010000u;
  } else {
    _has_bits_[0] &= ~0x00010000u;
  }
  tid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    tid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonRequest.tid)
}

// optional string file = 18;
inline bool CommonRequest::_internal_has_file() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool CommonRequest::has_file() const {
  return _internal_has_file();
}
inline void CommonRequest::clear_file() {
  file_.ClearToEmpty();
  _has_bits_[0] &= ~0x00020000u;
}
inline const std::string& CommonRequest::file() const {
  // @@protoc_insertion_point(field_get:CommonRequest.file)
  return _internal_file();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonRequest::set_file(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00020000u;
 file_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonRequest.file)
}
inline std::string* CommonRequest::mutable_file() {
  std::string* _s = _internal_mutable_file();
  // @@protoc_insertion_point(field_mutable:CommonRequest.file)
  return _s;
}
inline const std::string& CommonRequest::_internal_file() const {
  return file_.Get();
}
inline void CommonRequest::_internal_set_file(const std::string& value) {
  _has_bits_[0] |= 0x00020000u;
  file_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonRequest::_internal_mutable_file() {
  _has_bits_[0] |= 0x00020000u;
  return file_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonRequest::release_file() {
  // @@protoc_insertion_point(field_release:CommonRequest.file)
  if (!_internal_has_file()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00020000u;
  auto* p = file_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    file_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonRequest::set_allocated_file(std::string* file) {
  if (file != nullptr) {
    _has_bits_[0] |= 0x00020000u;
  } else {
    _has_bits_[0] &= ~0x00020000u;
  }
  file_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    file_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonRequest.file)
}

// optional string date = 19;
inline bool CommonRequest::_internal_has_date() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool CommonRequest::has_date() const {
  return _internal_has_date();
}
inline void CommonRequest::clear_date() {
  date_.ClearToEmpty();
  _has_bits_[0] &= ~0x00040000u;
}
inline const std::string& CommonRequest::date() const {
  // @@protoc_insertion_point(field_get:CommonRequest.date)
  return _internal_date();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonRequest::set_date(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00040000u;
 date_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonRequest.date)
}
inline std::string* CommonRequest::mutable_date() {
  std::string* _s = _internal_mutable_date();
  // @@protoc_insertion_point(field_mutable:CommonRequest.date)
  return _s;
}
inline const std::string& CommonRequest::_internal_date() const {
  return date_.Get();
}
inline void CommonRequest::_internal_set_date(const std::string& value) {
  _has_bits_[0] |= 0x00040000u;
  date_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonRequest::_internal_mutable_date() {
  _has_bits_[0] |= 0x00040000u;
  return date_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonRequest::release_date() {
  // @@protoc_insertion_point(field_release:CommonRequest.date)
  if (!_internal_has_date()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00040000u;
  auto* p = date_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (date_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    date_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonRequest::set_allocated_date(std::string* date) {
  if (date != nullptr) {
    _has_bits_[0] |= 0x00040000u;
  } else {
    _has_bits_[0] &= ~0x00040000u;
  }
  date_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), date,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (date_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    date_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonRequest.date)
}

// optional int32 pageNo = 20;
inline bool CommonRequest::_internal_has_pageno() const {
  bool value = (_has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool CommonRequest::has_pageno() const {
  return _internal_has_pageno();
}
inline void CommonRequest::clear_pageno() {
  pageno_ = 0;
  _has_bits_[0] &= ~0x00400000u;
}
inline int32_t CommonRequest::_internal_pageno() const {
  return pageno_;
}
inline int32_t CommonRequest::pageno() const {
  // @@protoc_insertion_point(field_get:CommonRequest.pageNo)
  return _internal_pageno();
}
inline void CommonRequest::_internal_set_pageno(int32_t value) {
  _has_bits_[0] |= 0x00400000u;
  pageno_ = value;
}
inline void CommonRequest::set_pageno(int32_t value) {
  _internal_set_pageno(value);
  // @@protoc_insertion_point(field_set:CommonRequest.pageNo)
}

// optional int32 pageSize = 21;
inline bool CommonRequest::_internal_has_pagesize() const {
  bool value = (_has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool CommonRequest::has_pagesize() const {
  return _internal_has_pagesize();
}
inline void CommonRequest::clear_pagesize() {
  pagesize_ = 0;
  _has_bits_[0] &= ~0x00800000u;
}
inline int32_t CommonRequest::_internal_pagesize() const {
  return pagesize_;
}
inline int32_t CommonRequest::pagesize() const {
  // @@protoc_insertion_point(field_get:CommonRequest.pageSize)
  return _internal_pagesize();
}
inline void CommonRequest::_internal_set_pagesize(int32_t value) {
  _has_bits_[0] |= 0x00800000u;
  pagesize_ = value;
}
inline void CommonRequest::set_pagesize(int32_t value) {
  _internal_set_pagesize(value);
  // @@protoc_insertion_point(field_set:CommonRequest.pageSize)
}

// optional string ip_type = 22;
inline bool CommonRequest::_internal_has_ip_type() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool CommonRequest::has_ip_type() const {
  return _internal_has_ip_type();
}
inline void CommonRequest::clear_ip_type() {
  ip_type_.ClearToEmpty();
  _has_bits_[0] &= ~0x00080000u;
}
inline const std::string& CommonRequest::ip_type() const {
  // @@protoc_insertion_point(field_get:CommonRequest.ip_type)
  return _internal_ip_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonRequest::set_ip_type(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00080000u;
 ip_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonRequest.ip_type)
}
inline std::string* CommonRequest::mutable_ip_type() {
  std::string* _s = _internal_mutable_ip_type();
  // @@protoc_insertion_point(field_mutable:CommonRequest.ip_type)
  return _s;
}
inline const std::string& CommonRequest::_internal_ip_type() const {
  return ip_type_.Get();
}
inline void CommonRequest::_internal_set_ip_type(const std::string& value) {
  _has_bits_[0] |= 0x00080000u;
  ip_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonRequest::_internal_mutable_ip_type() {
  _has_bits_[0] |= 0x00080000u;
  return ip_type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonRequest::release_ip_type() {
  // @@protoc_insertion_point(field_release:CommonRequest.ip_type)
  if (!_internal_has_ip_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00080000u;
  auto* p = ip_type_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ip_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ip_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonRequest::set_allocated_ip_type(std::string* ip_type) {
  if (ip_type != nullptr) {
    _has_bits_[0] |= 0x00080000u;
  } else {
    _has_bits_[0] &= ~0x00080000u;
  }
  ip_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip_type,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ip_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ip_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonRequest.ip_type)
}

// optional string ips = 23;
inline bool CommonRequest::_internal_has_ips() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool CommonRequest::has_ips() const {
  return _internal_has_ips();
}
inline void CommonRequest::clear_ips() {
  ips_.ClearToEmpty();
  _has_bits_[0] &= ~0x00100000u;
}
inline const std::string& CommonRequest::ips() const {
  // @@protoc_insertion_point(field_get:CommonRequest.ips)
  return _internal_ips();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonRequest::set_ips(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00100000u;
 ips_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonRequest.ips)
}
inline std::string* CommonRequest::mutable_ips() {
  std::string* _s = _internal_mutable_ips();
  // @@protoc_insertion_point(field_mutable:CommonRequest.ips)
  return _s;
}
inline const std::string& CommonRequest::_internal_ips() const {
  return ips_.Get();
}
inline void CommonRequest::_internal_set_ips(const std::string& value) {
  _has_bits_[0] |= 0x00100000u;
  ips_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonRequest::_internal_mutable_ips() {
  _has_bits_[0] |= 0x00100000u;
  return ips_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonRequest::release_ips() {
  // @@protoc_insertion_point(field_release:CommonRequest.ips)
  if (!_internal_has_ips()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00100000u;
  auto* p = ips_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ips_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ips_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonRequest::set_allocated_ips(std::string* ips) {
  if (ips != nullptr) {
    _has_bits_[0] |= 0x00100000u;
  } else {
    _has_bits_[0] &= ~0x00100000u;
  }
  ips_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ips,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ips_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ips_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonRequest.ips)
}

// optional .FunInfo funInfo = 24;
inline bool CommonRequest::_internal_has_funinfo() const {
  bool value = (_has_bits_[0] & 0x00200000u) != 0;
  PROTOBUF_ASSUME(!value || funinfo_ != nullptr);
  return value;
}
inline bool CommonRequest::has_funinfo() const {
  return _internal_has_funinfo();
}
inline void CommonRequest::clear_funinfo() {
  if (funinfo_ != nullptr) funinfo_->Clear();
  _has_bits_[0] &= ~0x00200000u;
}
inline const ::FunInfo& CommonRequest::_internal_funinfo() const {
  const ::FunInfo* p = funinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::FunInfo&>(
      ::_FunInfo_default_instance_);
}
inline const ::FunInfo& CommonRequest::funinfo() const {
  // @@protoc_insertion_point(field_get:CommonRequest.funInfo)
  return _internal_funinfo();
}
inline void CommonRequest::unsafe_arena_set_allocated_funinfo(
    ::FunInfo* funinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(funinfo_);
  }
  funinfo_ = funinfo;
  if (funinfo) {
    _has_bits_[0] |= 0x00200000u;
  } else {
    _has_bits_[0] &= ~0x00200000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CommonRequest.funInfo)
}
inline ::FunInfo* CommonRequest::release_funinfo() {
  _has_bits_[0] &= ~0x00200000u;
  ::FunInfo* temp = funinfo_;
  funinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::FunInfo* CommonRequest::unsafe_arena_release_funinfo() {
  // @@protoc_insertion_point(field_release:CommonRequest.funInfo)
  _has_bits_[0] &= ~0x00200000u;
  ::FunInfo* temp = funinfo_;
  funinfo_ = nullptr;
  return temp;
}
inline ::FunInfo* CommonRequest::_internal_mutable_funinfo() {
  _has_bits_[0] |= 0x00200000u;
  if (funinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::FunInfo>(GetArenaForAllocation());
    funinfo_ = p;
  }
  return funinfo_;
}
inline ::FunInfo* CommonRequest::mutable_funinfo() {
  ::FunInfo* _msg = _internal_mutable_funinfo();
  // @@protoc_insertion_point(field_mutable:CommonRequest.funInfo)
  return _msg;
}
inline void CommonRequest::set_allocated_funinfo(::FunInfo* funinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete funinfo_;
  }
  if (funinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::FunInfo>::GetOwningArena(funinfo);
    if (message_arena != submessage_arena) {
      funinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, funinfo, submessage_arena);
    }
    _has_bits_[0] |= 0x00200000u;
  } else {
    _has_bits_[0] &= ~0x00200000u;
  }
  funinfo_ = funinfo;
  // @@protoc_insertion_point(field_set_allocated:CommonRequest.funInfo)
}

// -------------------------------------------------------------------

// UserInfo

// optional string username = 1;
inline bool UserInfo::_internal_has_username() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UserInfo::has_username() const {
  return _internal_has_username();
}
inline void UserInfo::clear_username() {
  username_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UserInfo::username() const {
  // @@protoc_insertion_point(field_get:UserInfo.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfo::set_username(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserInfo.username)
}
inline std::string* UserInfo::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:UserInfo.username)
  return _s;
}
inline const std::string& UserInfo::_internal_username() const {
  return username_.Get();
}
inline void UserInfo::_internal_set_username(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UserInfo::_internal_mutable_username() {
  _has_bits_[0] |= 0x00000001u;
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UserInfo::release_username() {
  // @@protoc_insertion_point(field_release:UserInfo.username)
  if (!_internal_has_username()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = username_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (username_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserInfo::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (username_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserInfo.username)
}

// optional string password = 2;
inline bool UserInfo::_internal_has_password() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UserInfo::has_password() const {
  return _internal_has_password();
}
inline void UserInfo::clear_password() {
  password_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& UserInfo::password() const {
  // @@protoc_insertion_point(field_get:UserInfo.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfo::set_password(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserInfo.password)
}
inline std::string* UserInfo::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:UserInfo.password)
  return _s;
}
inline const std::string& UserInfo::_internal_password() const {
  return password_.Get();
}
inline void UserInfo::_internal_set_password(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UserInfo::_internal_mutable_password() {
  _has_bits_[0] |= 0x00000002u;
  return password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UserInfo::release_password() {
  // @@protoc_insertion_point(field_release:UserInfo.password)
  if (!_internal_has_password()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = password_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (password_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserInfo::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (password_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserInfo.password)
}

// optional string queryPrivilege = 3;
inline bool UserInfo::_internal_has_queryprivilege() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool UserInfo::has_queryprivilege() const {
  return _internal_has_queryprivilege();
}
inline void UserInfo::clear_queryprivilege() {
  queryprivilege_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& UserInfo::queryprivilege() const {
  // @@protoc_insertion_point(field_get:UserInfo.queryPrivilege)
  return _internal_queryprivilege();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfo::set_queryprivilege(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 queryprivilege_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserInfo.queryPrivilege)
}
inline std::string* UserInfo::mutable_queryprivilege() {
  std::string* _s = _internal_mutable_queryprivilege();
  // @@protoc_insertion_point(field_mutable:UserInfo.queryPrivilege)
  return _s;
}
inline const std::string& UserInfo::_internal_queryprivilege() const {
  return queryprivilege_.Get();
}
inline void UserInfo::_internal_set_queryprivilege(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  queryprivilege_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UserInfo::_internal_mutable_queryprivilege() {
  _has_bits_[0] |= 0x00000004u;
  return queryprivilege_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UserInfo::release_queryprivilege() {
  // @@protoc_insertion_point(field_release:UserInfo.queryPrivilege)
  if (!_internal_has_queryprivilege()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = queryprivilege_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (queryprivilege_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    queryprivilege_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserInfo::set_allocated_queryprivilege(std::string* queryprivilege) {
  if (queryprivilege != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  queryprivilege_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), queryprivilege,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (queryprivilege_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    queryprivilege_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserInfo.queryPrivilege)
}

// optional string updatePrivilege = 4;
inline bool UserInfo::_internal_has_updateprivilege() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool UserInfo::has_updateprivilege() const {
  return _internal_has_updateprivilege();
}
inline void UserInfo::clear_updateprivilege() {
  updateprivilege_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& UserInfo::updateprivilege() const {
  // @@protoc_insertion_point(field_get:UserInfo.updatePrivilege)
  return _internal_updateprivilege();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfo::set_updateprivilege(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 updateprivilege_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserInfo.updatePrivilege)
}
inline std::string* UserInfo::mutable_updateprivilege() {
  std::string* _s = _internal_mutable_updateprivilege();
  // @@protoc_insertion_point(field_mutable:UserInfo.updatePrivilege)
  return _s;
}
inline const std::string& UserInfo::_internal_updateprivilege() const {
  return updateprivilege_.Get();
}
inline void UserInfo::_internal_set_updateprivilege(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  updateprivilege_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UserInfo::_internal_mutable_updateprivilege() {
  _has_bits_[0] |= 0x00000008u;
  return updateprivilege_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UserInfo::release_updateprivilege() {
  // @@protoc_insertion_point(field_release:UserInfo.updatePrivilege)
  if (!_internal_has_updateprivilege()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = updateprivilege_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (updateprivilege_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    updateprivilege_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserInfo::set_allocated_updateprivilege(std::string* updateprivilege) {
  if (updateprivilege != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  updateprivilege_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), updateprivilege,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (updateprivilege_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    updateprivilege_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserInfo.updatePrivilege)
}

// optional string loadPrivilege = 5;
inline bool UserInfo::_internal_has_loadprivilege() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool UserInfo::has_loadprivilege() const {
  return _internal_has_loadprivilege();
}
inline void UserInfo::clear_loadprivilege() {
  loadprivilege_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& UserInfo::loadprivilege() const {
  // @@protoc_insertion_point(field_get:UserInfo.loadPrivilege)
  return _internal_loadprivilege();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfo::set_loadprivilege(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 loadprivilege_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserInfo.loadPrivilege)
}
inline std::string* UserInfo::mutable_loadprivilege() {
  std::string* _s = _internal_mutable_loadprivilege();
  // @@protoc_insertion_point(field_mutable:UserInfo.loadPrivilege)
  return _s;
}
inline const std::string& UserInfo::_internal_loadprivilege() const {
  return loadprivilege_.Get();
}
inline void UserInfo::_internal_set_loadprivilege(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  loadprivilege_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UserInfo::_internal_mutable_loadprivilege() {
  _has_bits_[0] |= 0x00000010u;
  return loadprivilege_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UserInfo::release_loadprivilege() {
  // @@protoc_insertion_point(field_release:UserInfo.loadPrivilege)
  if (!_internal_has_loadprivilege()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = loadprivilege_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (loadprivilege_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    loadprivilege_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserInfo::set_allocated_loadprivilege(std::string* loadprivilege) {
  if (loadprivilege != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  loadprivilege_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), loadprivilege,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (loadprivilege_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    loadprivilege_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserInfo.loadPrivilege)
}

// optional string unloadPrivilege = 6;
inline bool UserInfo::_internal_has_unloadprivilege() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool UserInfo::has_unloadprivilege() const {
  return _internal_has_unloadprivilege();
}
inline void UserInfo::clear_unloadprivilege() {
  unloadprivilege_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& UserInfo::unloadprivilege() const {
  // @@protoc_insertion_point(field_get:UserInfo.unloadPrivilege)
  return _internal_unloadprivilege();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfo::set_unloadprivilege(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 unloadprivilege_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserInfo.unloadPrivilege)
}
inline std::string* UserInfo::mutable_unloadprivilege() {
  std::string* _s = _internal_mutable_unloadprivilege();
  // @@protoc_insertion_point(field_mutable:UserInfo.unloadPrivilege)
  return _s;
}
inline const std::string& UserInfo::_internal_unloadprivilege() const {
  return unloadprivilege_.Get();
}
inline void UserInfo::_internal_set_unloadprivilege(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  unloadprivilege_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UserInfo::_internal_mutable_unloadprivilege() {
  _has_bits_[0] |= 0x00000020u;
  return unloadprivilege_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UserInfo::release_unloadprivilege() {
  // @@protoc_insertion_point(field_release:UserInfo.unloadPrivilege)
  if (!_internal_has_unloadprivilege()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  auto* p = unloadprivilege_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (unloadprivilege_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    unloadprivilege_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserInfo::set_allocated_unloadprivilege(std::string* unloadprivilege) {
  if (unloadprivilege != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  unloadprivilege_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), unloadprivilege,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (unloadprivilege_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    unloadprivilege_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserInfo.unloadPrivilege)
}

// optional string backupPrivilege = 7;
inline bool UserInfo::_internal_has_backupprivilege() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool UserInfo::has_backupprivilege() const {
  return _internal_has_backupprivilege();
}
inline void UserInfo::clear_backupprivilege() {
  backupprivilege_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& UserInfo::backupprivilege() const {
  // @@protoc_insertion_point(field_get:UserInfo.backupPrivilege)
  return _internal_backupprivilege();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfo::set_backupprivilege(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000040u;
 backupprivilege_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserInfo.backupPrivilege)
}
inline std::string* UserInfo::mutable_backupprivilege() {
  std::string* _s = _internal_mutable_backupprivilege();
  // @@protoc_insertion_point(field_mutable:UserInfo.backupPrivilege)
  return _s;
}
inline const std::string& UserInfo::_internal_backupprivilege() const {
  return backupprivilege_.Get();
}
inline void UserInfo::_internal_set_backupprivilege(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  backupprivilege_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UserInfo::_internal_mutable_backupprivilege() {
  _has_bits_[0] |= 0x00000040u;
  return backupprivilege_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UserInfo::release_backupprivilege() {
  // @@protoc_insertion_point(field_release:UserInfo.backupPrivilege)
  if (!_internal_has_backupprivilege()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  auto* p = backupprivilege_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (backupprivilege_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    backupprivilege_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserInfo::set_allocated_backupprivilege(std::string* backupprivilege) {
  if (backupprivilege != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  backupprivilege_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), backupprivilege,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (backupprivilege_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    backupprivilege_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserInfo.backupPrivilege)
}

// optional string restorePrivilege = 8;
inline bool UserInfo::_internal_has_restoreprivilege() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool UserInfo::has_restoreprivilege() const {
  return _internal_has_restoreprivilege();
}
inline void UserInfo::clear_restoreprivilege() {
  restoreprivilege_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000080u;
}
inline const std::string& UserInfo::restoreprivilege() const {
  // @@protoc_insertion_point(field_get:UserInfo.restorePrivilege)
  return _internal_restoreprivilege();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfo::set_restoreprivilege(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000080u;
 restoreprivilege_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserInfo.restorePrivilege)
}
inline std::string* UserInfo::mutable_restoreprivilege() {
  std::string* _s = _internal_mutable_restoreprivilege();
  // @@protoc_insertion_point(field_mutable:UserInfo.restorePrivilege)
  return _s;
}
inline const std::string& UserInfo::_internal_restoreprivilege() const {
  return restoreprivilege_.Get();
}
inline void UserInfo::_internal_set_restoreprivilege(const std::string& value) {
  _has_bits_[0] |= 0x00000080u;
  restoreprivilege_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UserInfo::_internal_mutable_restoreprivilege() {
  _has_bits_[0] |= 0x00000080u;
  return restoreprivilege_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UserInfo::release_restoreprivilege() {
  // @@protoc_insertion_point(field_release:UserInfo.restorePrivilege)
  if (!_internal_has_restoreprivilege()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000080u;
  auto* p = restoreprivilege_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (restoreprivilege_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    restoreprivilege_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserInfo::set_allocated_restoreprivilege(std::string* restoreprivilege) {
  if (restoreprivilege != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  restoreprivilege_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), restoreprivilege,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (restoreprivilege_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    restoreprivilege_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserInfo.restorePrivilege)
}

// optional string exportPrivilege = 9;
inline bool UserInfo::_internal_has_exportprivilege() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool UserInfo::has_exportprivilege() const {
  return _internal_has_exportprivilege();
}
inline void UserInfo::clear_exportprivilege() {
  exportprivilege_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000100u;
}
inline const std::string& UserInfo::exportprivilege() const {
  // @@protoc_insertion_point(field_get:UserInfo.exportPrivilege)
  return _internal_exportprivilege();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfo::set_exportprivilege(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000100u;
 exportprivilege_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserInfo.exportPrivilege)
}
inline std::string* UserInfo::mutable_exportprivilege() {
  std::string* _s = _internal_mutable_exportprivilege();
  // @@protoc_insertion_point(field_mutable:UserInfo.exportPrivilege)
  return _s;
}
inline const std::string& UserInfo::_internal_exportprivilege() const {
  return exportprivilege_.Get();
}
inline void UserInfo::_internal_set_exportprivilege(const std::string& value) {
  _has_bits_[0] |= 0x00000100u;
  exportprivilege_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UserInfo::_internal_mutable_exportprivilege() {
  _has_bits_[0] |= 0x00000100u;
  return exportprivilege_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UserInfo::release_exportprivilege() {
  // @@protoc_insertion_point(field_release:UserInfo.exportPrivilege)
  if (!_internal_has_exportprivilege()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000100u;
  auto* p = exportprivilege_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (exportprivilege_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    exportprivilege_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserInfo::set_allocated_exportprivilege(std::string* exportprivilege) {
  if (exportprivilege != nullptr) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  exportprivilege_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), exportprivilege,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (exportprivilege_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    exportprivilege_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserInfo.exportPrivilege)
}

// -------------------------------------------------------------------

// DBInfo

// optional string database = 1;
inline bool DBInfo::_internal_has_database() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DBInfo::has_database() const {
  return _internal_has_database();
}
inline void DBInfo::clear_database() {
  database_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DBInfo::database() const {
  // @@protoc_insertion_point(field_get:DBInfo.database)
  return _internal_database();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DBInfo::set_database(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 database_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DBInfo.database)
}
inline std::string* DBInfo::mutable_database() {
  std::string* _s = _internal_mutable_database();
  // @@protoc_insertion_point(field_mutable:DBInfo.database)
  return _s;
}
inline const std::string& DBInfo::_internal_database() const {
  return database_.Get();
}
inline void DBInfo::_internal_set_database(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  database_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DBInfo::_internal_mutable_database() {
  _has_bits_[0] |= 0x00000001u;
  return database_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DBInfo::release_database() {
  // @@protoc_insertion_point(field_release:DBInfo.database)
  if (!_internal_has_database()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = database_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (database_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    database_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DBInfo::set_allocated_database(std::string* database) {
  if (database != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  database_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), database,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (database_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    database_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DBInfo.database)
}

// optional string creator = 2;
inline bool DBInfo::_internal_has_creator() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DBInfo::has_creator() const {
  return _internal_has_creator();
}
inline void DBInfo::clear_creator() {
  creator_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DBInfo::creator() const {
  // @@protoc_insertion_point(field_get:DBInfo.creator)
  return _internal_creator();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DBInfo::set_creator(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 creator_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DBInfo.creator)
}
inline std::string* DBInfo::mutable_creator() {
  std::string* _s = _internal_mutable_creator();
  // @@protoc_insertion_point(field_mutable:DBInfo.creator)
  return _s;
}
inline const std::string& DBInfo::_internal_creator() const {
  return creator_.Get();
}
inline void DBInfo::_internal_set_creator(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  creator_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DBInfo::_internal_mutable_creator() {
  _has_bits_[0] |= 0x00000002u;
  return creator_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DBInfo::release_creator() {
  // @@protoc_insertion_point(field_release:DBInfo.creator)
  if (!_internal_has_creator()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = creator_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (creator_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    creator_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DBInfo::set_allocated_creator(std::string* creator) {
  if (creator != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  creator_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), creator,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (creator_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    creator_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DBInfo.creator)
}

// optional string builtTime = 3;
inline bool DBInfo::_internal_has_builttime() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DBInfo::has_builttime() const {
  return _internal_has_builttime();
}
inline void DBInfo::clear_builttime() {
  builttime_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& DBInfo::builttime() const {
  // @@protoc_insertion_point(field_get:DBInfo.builtTime)
  return _internal_builttime();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DBInfo::set_builttime(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 builttime_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DBInfo.builtTime)
}
inline std::string* DBInfo::mutable_builttime() {
  std::string* _s = _internal_mutable_builttime();
  // @@protoc_insertion_point(field_mutable:DBInfo.builtTime)
  return _s;
}
inline const std::string& DBInfo::_internal_builttime() const {
  return builttime_.Get();
}
inline void DBInfo::_internal_set_builttime(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  builttime_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DBInfo::_internal_mutable_builttime() {
  _has_bits_[0] |= 0x00000004u;
  return builttime_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DBInfo::release_builttime() {
  // @@protoc_insertion_point(field_release:DBInfo.builtTime)
  if (!_internal_has_builttime()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = builttime_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (builttime_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    builttime_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DBInfo::set_allocated_builttime(std::string* builttime) {
  if (builttime != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  builttime_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), builttime,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (builttime_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    builttime_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DBInfo.builtTime)
}

// optional string status = 4;
inline bool DBInfo::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DBInfo::has_status() const {
  return _internal_has_status();
}
inline void DBInfo::clear_status() {
  status_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& DBInfo::status() const {
  // @@protoc_insertion_point(field_get:DBInfo.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DBInfo::set_status(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DBInfo.status)
}
inline std::string* DBInfo::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:DBInfo.status)
  return _s;
}
inline const std::string& DBInfo::_internal_status() const {
  return status_.Get();
}
inline void DBInfo::_internal_set_status(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DBInfo::_internal_mutable_status() {
  _has_bits_[0] |= 0x00000008u;
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DBInfo::release_status() {
  // @@protoc_insertion_point(field_release:DBInfo.status)
  if (!_internal_has_status()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = status_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (status_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    status_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DBInfo::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (status_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    status_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DBInfo.status)
}

// -------------------------------------------------------------------

// QueryHeadInfo

// repeated string link = 1;
inline int QueryHeadInfo::_internal_link_size() const {
  return link_.size();
}
inline int QueryHeadInfo::link_size() const {
  return _internal_link_size();
}
inline void QueryHeadInfo::clear_link() {
  link_.Clear();
}
inline std::string* QueryHeadInfo::add_link() {
  std::string* _s = _internal_add_link();
  // @@protoc_insertion_point(field_add_mutable:QueryHeadInfo.link)
  return _s;
}
inline const std::string& QueryHeadInfo::_internal_link(int index) const {
  return link_.Get(index);
}
inline const std::string& QueryHeadInfo::link(int index) const {
  // @@protoc_insertion_point(field_get:QueryHeadInfo.link)
  return _internal_link(index);
}
inline std::string* QueryHeadInfo::mutable_link(int index) {
  // @@protoc_insertion_point(field_mutable:QueryHeadInfo.link)
  return link_.Mutable(index);
}
inline void QueryHeadInfo::set_link(int index, const std::string& value) {
  link_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:QueryHeadInfo.link)
}
inline void QueryHeadInfo::set_link(int index, std::string&& value) {
  link_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:QueryHeadInfo.link)
}
inline void QueryHeadInfo::set_link(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  link_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:QueryHeadInfo.link)
}
inline void QueryHeadInfo::set_link(int index, const char* value, size_t size) {
  link_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QueryHeadInfo.link)
}
inline std::string* QueryHeadInfo::_internal_add_link() {
  return link_.Add();
}
inline void QueryHeadInfo::add_link(const std::string& value) {
  link_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:QueryHeadInfo.link)
}
inline void QueryHeadInfo::add_link(std::string&& value) {
  link_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:QueryHeadInfo.link)
}
inline void QueryHeadInfo::add_link(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  link_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:QueryHeadInfo.link)
}
inline void QueryHeadInfo::add_link(const char* value, size_t size) {
  link_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:QueryHeadInfo.link)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
QueryHeadInfo::link() const {
  // @@protoc_insertion_point(field_list:QueryHeadInfo.link)
  return link_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
QueryHeadInfo::mutable_link() {
  // @@protoc_insertion_point(field_mutable_list:QueryHeadInfo.link)
  return &link_;
}

// repeated string vars = 2;
inline int QueryHeadInfo::_internal_vars_size() const {
  return vars_.size();
}
inline int QueryHeadInfo::vars_size() const {
  return _internal_vars_size();
}
inline void QueryHeadInfo::clear_vars() {
  vars_.Clear();
}
inline std::string* QueryHeadInfo::add_vars() {
  std::string* _s = _internal_add_vars();
  // @@protoc_insertion_point(field_add_mutable:QueryHeadInfo.vars)
  return _s;
}
inline const std::string& QueryHeadInfo::_internal_vars(int index) const {
  return vars_.Get(index);
}
inline const std::string& QueryHeadInfo::vars(int index) const {
  // @@protoc_insertion_point(field_get:QueryHeadInfo.vars)
  return _internal_vars(index);
}
inline std::string* QueryHeadInfo::mutable_vars(int index) {
  // @@protoc_insertion_point(field_mutable:QueryHeadInfo.vars)
  return vars_.Mutable(index);
}
inline void QueryHeadInfo::set_vars(int index, const std::string& value) {
  vars_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:QueryHeadInfo.vars)
}
inline void QueryHeadInfo::set_vars(int index, std::string&& value) {
  vars_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:QueryHeadInfo.vars)
}
inline void QueryHeadInfo::set_vars(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  vars_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:QueryHeadInfo.vars)
}
inline void QueryHeadInfo::set_vars(int index, const char* value, size_t size) {
  vars_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QueryHeadInfo.vars)
}
inline std::string* QueryHeadInfo::_internal_add_vars() {
  return vars_.Add();
}
inline void QueryHeadInfo::add_vars(const std::string& value) {
  vars_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:QueryHeadInfo.vars)
}
inline void QueryHeadInfo::add_vars(std::string&& value) {
  vars_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:QueryHeadInfo.vars)
}
inline void QueryHeadInfo::add_vars(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  vars_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:QueryHeadInfo.vars)
}
inline void QueryHeadInfo::add_vars(const char* value, size_t size) {
  vars_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:QueryHeadInfo.vars)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
QueryHeadInfo::vars() const {
  // @@protoc_insertion_point(field_list:QueryHeadInfo.vars)
  return vars_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
QueryHeadInfo::mutable_vars() {
  // @@protoc_insertion_point(field_mutable_list:QueryHeadInfo.vars)
  return &vars_;
}

// -------------------------------------------------------------------

// QueryResultInfo

// repeated string bindings = 1;
inline int QueryResultInfo::_internal_bindings_size() const {
  return bindings_.size();
}
inline int QueryResultInfo::bindings_size() const {
  return _internal_bindings_size();
}
inline void QueryResultInfo::clear_bindings() {
  bindings_.Clear();
}
inline std::string* QueryResultInfo::add_bindings() {
  std::string* _s = _internal_add_bindings();
  // @@protoc_insertion_point(field_add_mutable:QueryResultInfo.bindings)
  return _s;
}
inline const std::string& QueryResultInfo::_internal_bindings(int index) const {
  return bindings_.Get(index);
}
inline const std::string& QueryResultInfo::bindings(int index) const {
  // @@protoc_insertion_point(field_get:QueryResultInfo.bindings)
  return _internal_bindings(index);
}
inline std::string* QueryResultInfo::mutable_bindings(int index) {
  // @@protoc_insertion_point(field_mutable:QueryResultInfo.bindings)
  return bindings_.Mutable(index);
}
inline void QueryResultInfo::set_bindings(int index, const std::string& value) {
  bindings_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:QueryResultInfo.bindings)
}
inline void QueryResultInfo::set_bindings(int index, std::string&& value) {
  bindings_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:QueryResultInfo.bindings)
}
inline void QueryResultInfo::set_bindings(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  bindings_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:QueryResultInfo.bindings)
}
inline void QueryResultInfo::set_bindings(int index, const char* value, size_t size) {
  bindings_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QueryResultInfo.bindings)
}
inline std::string* QueryResultInfo::_internal_add_bindings() {
  return bindings_.Add();
}
inline void QueryResultInfo::add_bindings(const std::string& value) {
  bindings_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:QueryResultInfo.bindings)
}
inline void QueryResultInfo::add_bindings(std::string&& value) {
  bindings_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:QueryResultInfo.bindings)
}
inline void QueryResultInfo::add_bindings(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  bindings_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:QueryResultInfo.bindings)
}
inline void QueryResultInfo::add_bindings(const char* value, size_t size) {
  bindings_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:QueryResultInfo.bindings)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
QueryResultInfo::bindings() const {
  // @@protoc_insertion_point(field_list:QueryResultInfo.bindings)
  return bindings_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
QueryResultInfo::mutable_bindings() {
  // @@protoc_insertion_point(field_mutable_list:QueryResultInfo.bindings)
  return &bindings_;
}

// -------------------------------------------------------------------

// TxnLogInfo

// optional string dbName = 1;
inline bool TxnLogInfo::_internal_has_dbname() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TxnLogInfo::has_dbname() const {
  return _internal_has_dbname();
}
inline void TxnLogInfo::clear_dbname() {
  dbname_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TxnLogInfo::dbname() const {
  // @@protoc_insertion_point(field_get:TxnLogInfo.dbName)
  return _internal_dbname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TxnLogInfo::set_dbname(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 dbname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TxnLogInfo.dbName)
}
inline std::string* TxnLogInfo::mutable_dbname() {
  std::string* _s = _internal_mutable_dbname();
  // @@protoc_insertion_point(field_mutable:TxnLogInfo.dbName)
  return _s;
}
inline const std::string& TxnLogInfo::_internal_dbname() const {
  return dbname_.Get();
}
inline void TxnLogInfo::_internal_set_dbname(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  dbname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TxnLogInfo::_internal_mutable_dbname() {
  _has_bits_[0] |= 0x00000001u;
  return dbname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TxnLogInfo::release_dbname() {
  // @@protoc_insertion_point(field_release:TxnLogInfo.dbName)
  if (!_internal_has_dbname()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = dbname_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (dbname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    dbname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TxnLogInfo::set_allocated_dbname(std::string* dbname) {
  if (dbname != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  dbname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), dbname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (dbname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    dbname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TxnLogInfo.dbName)
}

// optional string TID = 2;
inline bool TxnLogInfo::_internal_has_tid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TxnLogInfo::has_tid() const {
  return _internal_has_tid();
}
inline void TxnLogInfo::clear_tid() {
  tid_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TxnLogInfo::tid() const {
  // @@protoc_insertion_point(field_get:TxnLogInfo.TID)
  return _internal_tid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TxnLogInfo::set_tid(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 tid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TxnLogInfo.TID)
}
inline std::string* TxnLogInfo::mutable_tid() {
  std::string* _s = _internal_mutable_tid();
  // @@protoc_insertion_point(field_mutable:TxnLogInfo.TID)
  return _s;
}
inline const std::string& TxnLogInfo::_internal_tid() const {
  return tid_.Get();
}
inline void TxnLogInfo::_internal_set_tid(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  tid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TxnLogInfo::_internal_mutable_tid() {
  _has_bits_[0] |= 0x00000002u;
  return tid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TxnLogInfo::release_tid() {
  // @@protoc_insertion_point(field_release:TxnLogInfo.TID)
  if (!_internal_has_tid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = tid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    tid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TxnLogInfo::set_allocated_tid(std::string* tid) {
  if (tid != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  tid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    tid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TxnLogInfo.TID)
}

// optional string user = 3;
inline bool TxnLogInfo::_internal_has_user() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TxnLogInfo::has_user() const {
  return _internal_has_user();
}
inline void TxnLogInfo::clear_user() {
  user_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& TxnLogInfo::user() const {
  // @@protoc_insertion_point(field_get:TxnLogInfo.user)
  return _internal_user();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TxnLogInfo::set_user(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 user_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TxnLogInfo.user)
}
inline std::string* TxnLogInfo::mutable_user() {
  std::string* _s = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:TxnLogInfo.user)
  return _s;
}
inline const std::string& TxnLogInfo::_internal_user() const {
  return user_.Get();
}
inline void TxnLogInfo::_internal_set_user(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  user_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TxnLogInfo::_internal_mutable_user() {
  _has_bits_[0] |= 0x00000004u;
  return user_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TxnLogInfo::release_user() {
  // @@protoc_insertion_point(field_release:TxnLogInfo.user)
  if (!_internal_has_user()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = user_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TxnLogInfo::set_allocated_user(std::string* user) {
  if (user != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  user_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TxnLogInfo.user)
}

// optional string beginTime = 4;
inline bool TxnLogInfo::_internal_has_begintime() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TxnLogInfo::has_begintime() const {
  return _internal_has_begintime();
}
inline void TxnLogInfo::clear_begintime() {
  begintime_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& TxnLogInfo::begintime() const {
  // @@protoc_insertion_point(field_get:TxnLogInfo.beginTime)
  return _internal_begintime();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TxnLogInfo::set_begintime(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 begintime_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TxnLogInfo.beginTime)
}
inline std::string* TxnLogInfo::mutable_begintime() {
  std::string* _s = _internal_mutable_begintime();
  // @@protoc_insertion_point(field_mutable:TxnLogInfo.beginTime)
  return _s;
}
inline const std::string& TxnLogInfo::_internal_begintime() const {
  return begintime_.Get();
}
inline void TxnLogInfo::_internal_set_begintime(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  begintime_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TxnLogInfo::_internal_mutable_begintime() {
  _has_bits_[0] |= 0x00000008u;
  return begintime_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TxnLogInfo::release_begintime() {
  // @@protoc_insertion_point(field_release:TxnLogInfo.beginTime)
  if (!_internal_has_begintime()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = begintime_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (begintime_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    begintime_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TxnLogInfo::set_allocated_begintime(std::string* begintime) {
  if (begintime != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  begintime_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), begintime,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (begintime_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    begintime_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TxnLogInfo.beginTime)
}

// optional string state = 5;
inline bool TxnLogInfo::_internal_has_state() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TxnLogInfo::has_state() const {
  return _internal_has_state();
}
inline void TxnLogInfo::clear_state() {
  state_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& TxnLogInfo::state() const {
  // @@protoc_insertion_point(field_get:TxnLogInfo.state)
  return _internal_state();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TxnLogInfo::set_state(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 state_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TxnLogInfo.state)
}
inline std::string* TxnLogInfo::mutable_state() {
  std::string* _s = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:TxnLogInfo.state)
  return _s;
}
inline const std::string& TxnLogInfo::_internal_state() const {
  return state_.Get();
}
inline void TxnLogInfo::_internal_set_state(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  state_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TxnLogInfo::_internal_mutable_state() {
  _has_bits_[0] |= 0x00000010u;
  return state_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TxnLogInfo::release_state() {
  // @@protoc_insertion_point(field_release:TxnLogInfo.state)
  if (!_internal_has_state()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = state_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (state_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    state_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TxnLogInfo::set_allocated_state(std::string* state) {
  if (state != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  state_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), state,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (state_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    state_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TxnLogInfo.state)
}

// optional string endTime = 6;
inline bool TxnLogInfo::_internal_has_endtime() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TxnLogInfo::has_endtime() const {
  return _internal_has_endtime();
}
inline void TxnLogInfo::clear_endtime() {
  endtime_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& TxnLogInfo::endtime() const {
  // @@protoc_insertion_point(field_get:TxnLogInfo.endTime)
  return _internal_endtime();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TxnLogInfo::set_endtime(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 endtime_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TxnLogInfo.endTime)
}
inline std::string* TxnLogInfo::mutable_endtime() {
  std::string* _s = _internal_mutable_endtime();
  // @@protoc_insertion_point(field_mutable:TxnLogInfo.endTime)
  return _s;
}
inline const std::string& TxnLogInfo::_internal_endtime() const {
  return endtime_.Get();
}
inline void TxnLogInfo::_internal_set_endtime(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  endtime_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TxnLogInfo::_internal_mutable_endtime() {
  _has_bits_[0] |= 0x00000020u;
  return endtime_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TxnLogInfo::release_endtime() {
  // @@protoc_insertion_point(field_release:TxnLogInfo.endTime)
  if (!_internal_has_endtime()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  auto* p = endtime_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (endtime_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    endtime_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TxnLogInfo::set_allocated_endtime(std::string* endtime) {
  if (endtime != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  endtime_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), endtime,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (endtime_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    endtime_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TxnLogInfo.endTime)
}

// -------------------------------------------------------------------

// QueryLogInfo

// optional string QueryDateTime = 1;
inline bool QueryLogInfo::_internal_has_querydatetime() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool QueryLogInfo::has_querydatetime() const {
  return _internal_has_querydatetime();
}
inline void QueryLogInfo::clear_querydatetime() {
  querydatetime_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& QueryLogInfo::querydatetime() const {
  // @@protoc_insertion_point(field_get:QueryLogInfo.QueryDateTime)
  return _internal_querydatetime();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryLogInfo::set_querydatetime(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 querydatetime_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:QueryLogInfo.QueryDateTime)
}
inline std::string* QueryLogInfo::mutable_querydatetime() {
  std::string* _s = _internal_mutable_querydatetime();
  // @@protoc_insertion_point(field_mutable:QueryLogInfo.QueryDateTime)
  return _s;
}
inline const std::string& QueryLogInfo::_internal_querydatetime() const {
  return querydatetime_.Get();
}
inline void QueryLogInfo::_internal_set_querydatetime(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  querydatetime_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryLogInfo::_internal_mutable_querydatetime() {
  _has_bits_[0] |= 0x00000001u;
  return querydatetime_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryLogInfo::release_querydatetime() {
  // @@protoc_insertion_point(field_release:QueryLogInfo.QueryDateTime)
  if (!_internal_has_querydatetime()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = querydatetime_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (querydatetime_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    querydatetime_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void QueryLogInfo::set_allocated_querydatetime(std::string* querydatetime) {
  if (querydatetime != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  querydatetime_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), querydatetime,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (querydatetime_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    querydatetime_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:QueryLogInfo.QueryDateTime)
}

// optional string Sparql = 2;
inline bool QueryLogInfo::_internal_has_sparql() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool QueryLogInfo::has_sparql() const {
  return _internal_has_sparql();
}
inline void QueryLogInfo::clear_sparql() {
  sparql_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& QueryLogInfo::sparql() const {
  // @@protoc_insertion_point(field_get:QueryLogInfo.Sparql)
  return _internal_sparql();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryLogInfo::set_sparql(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 sparql_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:QueryLogInfo.Sparql)
}
inline std::string* QueryLogInfo::mutable_sparql() {
  std::string* _s = _internal_mutable_sparql();
  // @@protoc_insertion_point(field_mutable:QueryLogInfo.Sparql)
  return _s;
}
inline const std::string& QueryLogInfo::_internal_sparql() const {
  return sparql_.Get();
}
inline void QueryLogInfo::_internal_set_sparql(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  sparql_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryLogInfo::_internal_mutable_sparql() {
  _has_bits_[0] |= 0x00000002u;
  return sparql_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryLogInfo::release_sparql() {
  // @@protoc_insertion_point(field_release:QueryLogInfo.Sparql)
  if (!_internal_has_sparql()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = sparql_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sparql_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sparql_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void QueryLogInfo::set_allocated_sparql(std::string* sparql) {
  if (sparql != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  sparql_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sparql,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sparql_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sparql_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:QueryLogInfo.Sparql)
}

// optional string Format = 3;
inline bool QueryLogInfo::_internal_has_format() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool QueryLogInfo::has_format() const {
  return _internal_has_format();
}
inline void QueryLogInfo::clear_format() {
  format_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& QueryLogInfo::format() const {
  // @@protoc_insertion_point(field_get:QueryLogInfo.Format)
  return _internal_format();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryLogInfo::set_format(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 format_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:QueryLogInfo.Format)
}
inline std::string* QueryLogInfo::mutable_format() {
  std::string* _s = _internal_mutable_format();
  // @@protoc_insertion_point(field_mutable:QueryLogInfo.Format)
  return _s;
}
inline const std::string& QueryLogInfo::_internal_format() const {
  return format_.Get();
}
inline void QueryLogInfo::_internal_set_format(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  format_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryLogInfo::_internal_mutable_format() {
  _has_bits_[0] |= 0x00000004u;
  return format_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryLogInfo::release_format() {
  // @@protoc_insertion_point(field_release:QueryLogInfo.Format)
  if (!_internal_has_format()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = format_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (format_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    format_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void QueryLogInfo::set_allocated_format(std::string* format) {
  if (format != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  format_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), format,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (format_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    format_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:QueryLogInfo.Format)
}

// optional string RemoteIP = 4;
inline bool QueryLogInfo::_internal_has_remoteip() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool QueryLogInfo::has_remoteip() const {
  return _internal_has_remoteip();
}
inline void QueryLogInfo::clear_remoteip() {
  remoteip_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& QueryLogInfo::remoteip() const {
  // @@protoc_insertion_point(field_get:QueryLogInfo.RemoteIP)
  return _internal_remoteip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryLogInfo::set_remoteip(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 remoteip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:QueryLogInfo.RemoteIP)
}
inline std::string* QueryLogInfo::mutable_remoteip() {
  std::string* _s = _internal_mutable_remoteip();
  // @@protoc_insertion_point(field_mutable:QueryLogInfo.RemoteIP)
  return _s;
}
inline const std::string& QueryLogInfo::_internal_remoteip() const {
  return remoteip_.Get();
}
inline void QueryLogInfo::_internal_set_remoteip(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  remoteip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryLogInfo::_internal_mutable_remoteip() {
  _has_bits_[0] |= 0x00000008u;
  return remoteip_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryLogInfo::release_remoteip() {
  // @@protoc_insertion_point(field_release:QueryLogInfo.RemoteIP)
  if (!_internal_has_remoteip()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = remoteip_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (remoteip_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    remoteip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void QueryLogInfo::set_allocated_remoteip(std::string* remoteip) {
  if (remoteip != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  remoteip_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), remoteip,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (remoteip_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    remoteip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:QueryLogInfo.RemoteIP)
}

// optional string FileName = 5;
inline bool QueryLogInfo::_internal_has_filename() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool QueryLogInfo::has_filename() const {
  return _internal_has_filename();
}
inline void QueryLogInfo::clear_filename() {
  filename_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& QueryLogInfo::filename() const {
  // @@protoc_insertion_point(field_get:QueryLogInfo.FileName)
  return _internal_filename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryLogInfo::set_filename(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 filename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:QueryLogInfo.FileName)
}
inline std::string* QueryLogInfo::mutable_filename() {
  std::string* _s = _internal_mutable_filename();
  // @@protoc_insertion_point(field_mutable:QueryLogInfo.FileName)
  return _s;
}
inline const std::string& QueryLogInfo::_internal_filename() const {
  return filename_.Get();
}
inline void QueryLogInfo::_internal_set_filename(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  filename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryLogInfo::_internal_mutable_filename() {
  _has_bits_[0] |= 0x00000010u;
  return filename_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryLogInfo::release_filename() {
  // @@protoc_insertion_point(field_release:QueryLogInfo.FileName)
  if (!_internal_has_filename()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = filename_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (filename_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    filename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void QueryLogInfo::set_allocated_filename(std::string* filename) {
  if (filename != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  filename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), filename,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (filename_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    filename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:QueryLogInfo.FileName)
}

// optional int32 QueryTime = 6;
inline bool QueryLogInfo::_internal_has_querytime() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool QueryLogInfo::has_querytime() const {
  return _internal_has_querytime();
}
inline void QueryLogInfo::clear_querytime() {
  querytime_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline int32_t QueryLogInfo::_internal_querytime() const {
  return querytime_;
}
inline int32_t QueryLogInfo::querytime() const {
  // @@protoc_insertion_point(field_get:QueryLogInfo.QueryTime)
  return _internal_querytime();
}
inline void QueryLogInfo::_internal_set_querytime(int32_t value) {
  _has_bits_[0] |= 0x00000020u;
  querytime_ = value;
}
inline void QueryLogInfo::set_querytime(int32_t value) {
  _internal_set_querytime(value);
  // @@protoc_insertion_point(field_set:QueryLogInfo.QueryTime)
}

// optional int32 AnsNum = 7;
inline bool QueryLogInfo::_internal_has_ansnum() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool QueryLogInfo::has_ansnum() const {
  return _internal_has_ansnum();
}
inline void QueryLogInfo::clear_ansnum() {
  ansnum_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline int32_t QueryLogInfo::_internal_ansnum() const {
  return ansnum_;
}
inline int32_t QueryLogInfo::ansnum() const {
  // @@protoc_insertion_point(field_get:QueryLogInfo.AnsNum)
  return _internal_ansnum();
}
inline void QueryLogInfo::_internal_set_ansnum(int32_t value) {
  _has_bits_[0] |= 0x00000040u;
  ansnum_ = value;
}
inline void QueryLogInfo::set_ansnum(int32_t value) {
  _internal_set_ansnum(value);
  // @@protoc_insertion_point(field_set:QueryLogInfo.AnsNum)
}

// -------------------------------------------------------------------

// AccessLogInfo

// optional string ip = 1;
inline bool AccessLogInfo::_internal_has_ip() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AccessLogInfo::has_ip() const {
  return _internal_has_ip();
}
inline void AccessLogInfo::clear_ip() {
  ip_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AccessLogInfo::ip() const {
  // @@protoc_insertion_point(field_get:AccessLogInfo.ip)
  return _internal_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccessLogInfo::set_ip(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:AccessLogInfo.ip)
}
inline std::string* AccessLogInfo::mutable_ip() {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:AccessLogInfo.ip)
  return _s;
}
inline const std::string& AccessLogInfo::_internal_ip() const {
  return ip_.Get();
}
inline void AccessLogInfo::_internal_set_ip(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AccessLogInfo::_internal_mutable_ip() {
  _has_bits_[0] |= 0x00000001u;
  return ip_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AccessLogInfo::release_ip() {
  // @@protoc_insertion_point(field_release:AccessLogInfo.ip)
  if (!_internal_has_ip()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = ip_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ip_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AccessLogInfo::set_allocated_ip(std::string* ip) {
  if (ip != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  ip_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ip_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:AccessLogInfo.ip)
}

// optional string operation = 2;
inline bool AccessLogInfo::_internal_has_operation() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AccessLogInfo::has_operation() const {
  return _internal_has_operation();
}
inline void AccessLogInfo::clear_operation() {
  operation_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AccessLogInfo::operation() const {
  // @@protoc_insertion_point(field_get:AccessLogInfo.operation)
  return _internal_operation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccessLogInfo::set_operation(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 operation_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:AccessLogInfo.operation)
}
inline std::string* AccessLogInfo::mutable_operation() {
  std::string* _s = _internal_mutable_operation();
  // @@protoc_insertion_point(field_mutable:AccessLogInfo.operation)
  return _s;
}
inline const std::string& AccessLogInfo::_internal_operation() const {
  return operation_.Get();
}
inline void AccessLogInfo::_internal_set_operation(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  operation_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AccessLogInfo::_internal_mutable_operation() {
  _has_bits_[0] |= 0x00000002u;
  return operation_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AccessLogInfo::release_operation() {
  // @@protoc_insertion_point(field_release:AccessLogInfo.operation)
  if (!_internal_has_operation()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = operation_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (operation_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    operation_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AccessLogInfo::set_allocated_operation(std::string* operation) {
  if (operation != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  operation_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), operation,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (operation_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    operation_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:AccessLogInfo.operation)
}

// optional string createtime = 3;
inline bool AccessLogInfo::_internal_has_createtime() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AccessLogInfo::has_createtime() const {
  return _internal_has_createtime();
}
inline void AccessLogInfo::clear_createtime() {
  createtime_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& AccessLogInfo::createtime() const {
  // @@protoc_insertion_point(field_get:AccessLogInfo.createtime)
  return _internal_createtime();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccessLogInfo::set_createtime(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 createtime_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:AccessLogInfo.createtime)
}
inline std::string* AccessLogInfo::mutable_createtime() {
  std::string* _s = _internal_mutable_createtime();
  // @@protoc_insertion_point(field_mutable:AccessLogInfo.createtime)
  return _s;
}
inline const std::string& AccessLogInfo::_internal_createtime() const {
  return createtime_.Get();
}
inline void AccessLogInfo::_internal_set_createtime(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  createtime_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AccessLogInfo::_internal_mutable_createtime() {
  _has_bits_[0] |= 0x00000004u;
  return createtime_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AccessLogInfo::release_createtime() {
  // @@protoc_insertion_point(field_release:AccessLogInfo.createtime)
  if (!_internal_has_createtime()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = createtime_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (createtime_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    createtime_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AccessLogInfo::set_allocated_createtime(std::string* createtime) {
  if (createtime != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  createtime_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), createtime,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (createtime_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    createtime_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:AccessLogInfo.createtime)
}

// optional int32 code = 4;
inline bool AccessLogInfo::_internal_has_code() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool AccessLogInfo::has_code() const {
  return _internal_has_code();
}
inline void AccessLogInfo::clear_code() {
  code_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline int32_t AccessLogInfo::_internal_code() const {
  return code_;
}
inline int32_t AccessLogInfo::code() const {
  // @@protoc_insertion_point(field_get:AccessLogInfo.code)
  return _internal_code();
}
inline void AccessLogInfo::_internal_set_code(int32_t value) {
  _has_bits_[0] |= 0x00000010u;
  code_ = value;
}
inline void AccessLogInfo::set_code(int32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:AccessLogInfo.code)
}

// optional string msg = 5;
inline bool AccessLogInfo::_internal_has_msg() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool AccessLogInfo::has_msg() const {
  return _internal_has_msg();
}
inline void AccessLogInfo::clear_msg() {
  msg_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& AccessLogInfo::msg() const {
  // @@protoc_insertion_point(field_get:AccessLogInfo.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccessLogInfo::set_msg(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:AccessLogInfo.msg)
}
inline std::string* AccessLogInfo::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:AccessLogInfo.msg)
  return _s;
}
inline const std::string& AccessLogInfo::_internal_msg() const {
  return msg_.Get();
}
inline void AccessLogInfo::_internal_set_msg(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AccessLogInfo::_internal_mutable_msg() {
  _has_bits_[0] |= 0x00000008u;
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AccessLogInfo::release_msg() {
  // @@protoc_insertion_point(field_release:AccessLogInfo.msg)
  if (!_internal_has_msg()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = msg_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (msg_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    msg_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AccessLogInfo::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (msg_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    msg_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:AccessLogInfo.msg)
}

// -------------------------------------------------------------------

// IPManageInfo

// optional string ipType = 1;
inline bool IPManageInfo::_internal_has_iptype() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool IPManageInfo::has_iptype() const {
  return _internal_has_iptype();
}
inline void IPManageInfo::clear_iptype() {
  iptype_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& IPManageInfo::iptype() const {
  // @@protoc_insertion_point(field_get:IPManageInfo.ipType)
  return _internal_iptype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IPManageInfo::set_iptype(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 iptype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IPManageInfo.ipType)
}
inline std::string* IPManageInfo::mutable_iptype() {
  std::string* _s = _internal_mutable_iptype();
  // @@protoc_insertion_point(field_mutable:IPManageInfo.ipType)
  return _s;
}
inline const std::string& IPManageInfo::_internal_iptype() const {
  return iptype_.Get();
}
inline void IPManageInfo::_internal_set_iptype(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  iptype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* IPManageInfo::_internal_mutable_iptype() {
  _has_bits_[0] |= 0x00000001u;
  return iptype_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* IPManageInfo::release_iptype() {
  // @@protoc_insertion_point(field_release:IPManageInfo.ipType)
  if (!_internal_has_iptype()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = iptype_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (iptype_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    iptype_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void IPManageInfo::set_allocated_iptype(std::string* iptype) {
  if (iptype != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  iptype_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), iptype,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (iptype_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    iptype_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IPManageInfo.ipType)
}

// repeated string ips = 2;
inline int IPManageInfo::_internal_ips_size() const {
  return ips_.size();
}
inline int IPManageInfo::ips_size() const {
  return _internal_ips_size();
}
inline void IPManageInfo::clear_ips() {
  ips_.Clear();
}
inline std::string* IPManageInfo::add_ips() {
  std::string* _s = _internal_add_ips();
  // @@protoc_insertion_point(field_add_mutable:IPManageInfo.ips)
  return _s;
}
inline const std::string& IPManageInfo::_internal_ips(int index) const {
  return ips_.Get(index);
}
inline const std::string& IPManageInfo::ips(int index) const {
  // @@protoc_insertion_point(field_get:IPManageInfo.ips)
  return _internal_ips(index);
}
inline std::string* IPManageInfo::mutable_ips(int index) {
  // @@protoc_insertion_point(field_mutable:IPManageInfo.ips)
  return ips_.Mutable(index);
}
inline void IPManageInfo::set_ips(int index, const std::string& value) {
  ips_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:IPManageInfo.ips)
}
inline void IPManageInfo::set_ips(int index, std::string&& value) {
  ips_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:IPManageInfo.ips)
}
inline void IPManageInfo::set_ips(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  ips_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:IPManageInfo.ips)
}
inline void IPManageInfo::set_ips(int index, const char* value, size_t size) {
  ips_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IPManageInfo.ips)
}
inline std::string* IPManageInfo::_internal_add_ips() {
  return ips_.Add();
}
inline void IPManageInfo::add_ips(const std::string& value) {
  ips_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:IPManageInfo.ips)
}
inline void IPManageInfo::add_ips(std::string&& value) {
  ips_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:IPManageInfo.ips)
}
inline void IPManageInfo::add_ips(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  ips_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:IPManageInfo.ips)
}
inline void IPManageInfo::add_ips(const char* value, size_t size) {
  ips_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:IPManageInfo.ips)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
IPManageInfo::ips() const {
  // @@protoc_insertion_point(field_list:IPManageInfo.ips)
  return ips_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
IPManageInfo::mutable_ips() {
  // @@protoc_insertion_point(field_mutable_list:IPManageInfo.ips)
  return &ips_;
}

// -------------------------------------------------------------------

// FunInfo

// optional string funName = 1;
inline bool FunInfo::_internal_has_funname() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FunInfo::has_funname() const {
  return _internal_has_funname();
}
inline void FunInfo::clear_funname() {
  funname_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FunInfo::funname() const {
  // @@protoc_insertion_point(field_get:FunInfo.funName)
  return _internal_funname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FunInfo::set_funname(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 funname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FunInfo.funName)
}
inline std::string* FunInfo::mutable_funname() {
  std::string* _s = _internal_mutable_funname();
  // @@protoc_insertion_point(field_mutable:FunInfo.funName)
  return _s;
}
inline const std::string& FunInfo::_internal_funname() const {
  return funname_.Get();
}
inline void FunInfo::_internal_set_funname(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  funname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FunInfo::_internal_mutable_funname() {
  _has_bits_[0] |= 0x00000001u;
  return funname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FunInfo::release_funname() {
  // @@protoc_insertion_point(field_release:FunInfo.funName)
  if (!_internal_has_funname()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = funname_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (funname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    funname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FunInfo::set_allocated_funname(std::string* funname) {
  if (funname != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  funname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), funname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (funname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    funname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:FunInfo.funName)
}

// optional string funDesc = 2;
inline bool FunInfo::_internal_has_fundesc() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FunInfo::has_fundesc() const {
  return _internal_has_fundesc();
}
inline void FunInfo::clear_fundesc() {
  fundesc_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& FunInfo::fundesc() const {
  // @@protoc_insertion_point(field_get:FunInfo.funDesc)
  return _internal_fundesc();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FunInfo::set_fundesc(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 fundesc_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FunInfo.funDesc)
}
inline std::string* FunInfo::mutable_fundesc() {
  std::string* _s = _internal_mutable_fundesc();
  // @@protoc_insertion_point(field_mutable:FunInfo.funDesc)
  return _s;
}
inline const std::string& FunInfo::_internal_fundesc() const {
  return fundesc_.Get();
}
inline void FunInfo::_internal_set_fundesc(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  fundesc_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FunInfo::_internal_mutable_fundesc() {
  _has_bits_[0] |= 0x00000002u;
  return fundesc_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FunInfo::release_fundesc() {
  // @@protoc_insertion_point(field_release:FunInfo.funDesc)
  if (!_internal_has_fundesc()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = fundesc_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (fundesc_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    fundesc_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FunInfo::set_allocated_fundesc(std::string* fundesc) {
  if (fundesc != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  fundesc_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fundesc,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (fundesc_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    fundesc_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:FunInfo.funDesc)
}

// optional string funArgs = 3;
inline bool FunInfo::_internal_has_funargs() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool FunInfo::has_funargs() const {
  return _internal_has_funargs();
}
inline void FunInfo::clear_funargs() {
  funargs_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& FunInfo::funargs() const {
  // @@protoc_insertion_point(field_get:FunInfo.funArgs)
  return _internal_funargs();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FunInfo::set_funargs(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 funargs_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FunInfo.funArgs)
}
inline std::string* FunInfo::mutable_funargs() {
  std::string* _s = _internal_mutable_funargs();
  // @@protoc_insertion_point(field_mutable:FunInfo.funArgs)
  return _s;
}
inline const std::string& FunInfo::_internal_funargs() const {
  return funargs_.Get();
}
inline void FunInfo::_internal_set_funargs(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  funargs_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FunInfo::_internal_mutable_funargs() {
  _has_bits_[0] |= 0x00000004u;
  return funargs_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FunInfo::release_funargs() {
  // @@protoc_insertion_point(field_release:FunInfo.funArgs)
  if (!_internal_has_funargs()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = funargs_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (funargs_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    funargs_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FunInfo::set_allocated_funargs(std::string* funargs) {
  if (funargs != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  funargs_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), funargs,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (funargs_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    funargs_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:FunInfo.funArgs)
}

// optional string funBody = 4;
inline bool FunInfo::_internal_has_funbody() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool FunInfo::has_funbody() const {
  return _internal_has_funbody();
}
inline void FunInfo::clear_funbody() {
  funbody_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& FunInfo::funbody() const {
  // @@protoc_insertion_point(field_get:FunInfo.funBody)
  return _internal_funbody();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FunInfo::set_funbody(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 funbody_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FunInfo.funBody)
}
inline std::string* FunInfo::mutable_funbody() {
  std::string* _s = _internal_mutable_funbody();
  // @@protoc_insertion_point(field_mutable:FunInfo.funBody)
  return _s;
}
inline const std::string& FunInfo::_internal_funbody() const {
  return funbody_.Get();
}
inline void FunInfo::_internal_set_funbody(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  funbody_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FunInfo::_internal_mutable_funbody() {
  _has_bits_[0] |= 0x00000008u;
  return funbody_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FunInfo::release_funbody() {
  // @@protoc_insertion_point(field_release:FunInfo.funBody)
  if (!_internal_has_funbody()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = funbody_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (funbody_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    funbody_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FunInfo::set_allocated_funbody(std::string* funbody) {
  if (funbody != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  funbody_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), funbody,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (funbody_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    funbody_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:FunInfo.funBody)
}

// optional string funSubs = 5;
inline bool FunInfo::_internal_has_funsubs() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool FunInfo::has_funsubs() const {
  return _internal_has_funsubs();
}
inline void FunInfo::clear_funsubs() {
  funsubs_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& FunInfo::funsubs() const {
  // @@protoc_insertion_point(field_get:FunInfo.funSubs)
  return _internal_funsubs();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FunInfo::set_funsubs(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 funsubs_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FunInfo.funSubs)
}
inline std::string* FunInfo::mutable_funsubs() {
  std::string* _s = _internal_mutable_funsubs();
  // @@protoc_insertion_point(field_mutable:FunInfo.funSubs)
  return _s;
}
inline const std::string& FunInfo::_internal_funsubs() const {
  return funsubs_.Get();
}
inline void FunInfo::_internal_set_funsubs(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  funsubs_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FunInfo::_internal_mutable_funsubs() {
  _has_bits_[0] |= 0x00000010u;
  return funsubs_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FunInfo::release_funsubs() {
  // @@protoc_insertion_point(field_release:FunInfo.funSubs)
  if (!_internal_has_funsubs()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = funsubs_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (funsubs_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    funsubs_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FunInfo::set_allocated_funsubs(std::string* funsubs) {
  if (funsubs != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  funsubs_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), funsubs,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (funsubs_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    funsubs_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:FunInfo.funSubs)
}

// optional string funStatus = 6;
inline bool FunInfo::_internal_has_funstatus() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool FunInfo::has_funstatus() const {
  return _internal_has_funstatus();
}
inline void FunInfo::clear_funstatus() {
  funstatus_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& FunInfo::funstatus() const {
  // @@protoc_insertion_point(field_get:FunInfo.funStatus)
  return _internal_funstatus();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FunInfo::set_funstatus(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 funstatus_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FunInfo.funStatus)
}
inline std::string* FunInfo::mutable_funstatus() {
  std::string* _s = _internal_mutable_funstatus();
  // @@protoc_insertion_point(field_mutable:FunInfo.funStatus)
  return _s;
}
inline const std::string& FunInfo::_internal_funstatus() const {
  return funstatus_.Get();
}
inline void FunInfo::_internal_set_funstatus(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  funstatus_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FunInfo::_internal_mutable_funstatus() {
  _has_bits_[0] |= 0x00000020u;
  return funstatus_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FunInfo::release_funstatus() {
  // @@protoc_insertion_point(field_release:FunInfo.funStatus)
  if (!_internal_has_funstatus()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  auto* p = funstatus_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (funstatus_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    funstatus_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FunInfo::set_allocated_funstatus(std::string* funstatus) {
  if (funstatus != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  funstatus_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), funstatus,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (funstatus_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    funstatus_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:FunInfo.funStatus)
}

// optional string funReturn = 7;
inline bool FunInfo::_internal_has_funreturn() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool FunInfo::has_funreturn() const {
  return _internal_has_funreturn();
}
inline void FunInfo::clear_funreturn() {
  funreturn_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& FunInfo::funreturn() const {
  // @@protoc_insertion_point(field_get:FunInfo.funReturn)
  return _internal_funreturn();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FunInfo::set_funreturn(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000040u;
 funreturn_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FunInfo.funReturn)
}
inline std::string* FunInfo::mutable_funreturn() {
  std::string* _s = _internal_mutable_funreturn();
  // @@protoc_insertion_point(field_mutable:FunInfo.funReturn)
  return _s;
}
inline const std::string& FunInfo::_internal_funreturn() const {
  return funreturn_.Get();
}
inline void FunInfo::_internal_set_funreturn(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  funreturn_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FunInfo::_internal_mutable_funreturn() {
  _has_bits_[0] |= 0x00000040u;
  return funreturn_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FunInfo::release_funreturn() {
  // @@protoc_insertion_point(field_release:FunInfo.funReturn)
  if (!_internal_has_funreturn()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  auto* p = funreturn_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (funreturn_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    funreturn_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FunInfo::set_allocated_funreturn(std::string* funreturn) {
  if (funreturn != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  funreturn_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), funreturn,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (funreturn_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    funreturn_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:FunInfo.funReturn)
}

// optional string lastTime = 8;
inline bool FunInfo::_internal_has_lasttime() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool FunInfo::has_lasttime() const {
  return _internal_has_lasttime();
}
inline void FunInfo::clear_lasttime() {
  lasttime_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000080u;
}
inline const std::string& FunInfo::lasttime() const {
  // @@protoc_insertion_point(field_get:FunInfo.lastTime)
  return _internal_lasttime();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FunInfo::set_lasttime(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000080u;
 lasttime_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FunInfo.lastTime)
}
inline std::string* FunInfo::mutable_lasttime() {
  std::string* _s = _internal_mutable_lasttime();
  // @@protoc_insertion_point(field_mutable:FunInfo.lastTime)
  return _s;
}
inline const std::string& FunInfo::_internal_lasttime() const {
  return lasttime_.Get();
}
inline void FunInfo::_internal_set_lasttime(const std::string& value) {
  _has_bits_[0] |= 0x00000080u;
  lasttime_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FunInfo::_internal_mutable_lasttime() {
  _has_bits_[0] |= 0x00000080u;
  return lasttime_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FunInfo::release_lasttime() {
  // @@protoc_insertion_point(field_release:FunInfo.lastTime)
  if (!_internal_has_lasttime()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000080u;
  auto* p = lasttime_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (lasttime_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    lasttime_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FunInfo::set_allocated_lasttime(std::string* lasttime) {
  if (lasttime != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  lasttime_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), lasttime,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (lasttime_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    lasttime_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:FunInfo.lastTime)
}

// -------------------------------------------------------------------

// CommonResponse

// optional int32 StatusCode = 1;
inline bool CommonResponse::_internal_has_statuscode() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool CommonResponse::has_statuscode() const {
  return _internal_has_statuscode();
}
inline void CommonResponse::clear_statuscode() {
  statuscode_ = 0;
  _has_bits_[0] &= ~0x00040000u;
}
inline int32_t CommonResponse::_internal_statuscode() const {
  return statuscode_;
}
inline int32_t CommonResponse::statuscode() const {
  // @@protoc_insertion_point(field_get:CommonResponse.StatusCode)
  return _internal_statuscode();
}
inline void CommonResponse::_internal_set_statuscode(int32_t value) {
  _has_bits_[0] |= 0x00040000u;
  statuscode_ = value;
}
inline void CommonResponse::set_statuscode(int32_t value) {
  _internal_set_statuscode(value);
  // @@protoc_insertion_point(field_set:CommonResponse.StatusCode)
}

// optional string StatusMsg = 2;
inline bool CommonResponse::_internal_has_statusmsg() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommonResponse::has_statusmsg() const {
  return _internal_has_statusmsg();
}
inline void CommonResponse::clear_statusmsg() {
  statusmsg_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommonResponse::statusmsg() const {
  // @@protoc_insertion_point(field_get:CommonResponse.StatusMsg)
  return _internal_statusmsg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonResponse::set_statusmsg(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 statusmsg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonResponse.StatusMsg)
}
inline std::string* CommonResponse::mutable_statusmsg() {
  std::string* _s = _internal_mutable_statusmsg();
  // @@protoc_insertion_point(field_mutable:CommonResponse.StatusMsg)
  return _s;
}
inline const std::string& CommonResponse::_internal_statusmsg() const {
  return statusmsg_.Get();
}
inline void CommonResponse::_internal_set_statusmsg(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  statusmsg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonResponse::_internal_mutable_statusmsg() {
  _has_bits_[0] |= 0x00000001u;
  return statusmsg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonResponse::release_statusmsg() {
  // @@protoc_insertion_point(field_release:CommonResponse.StatusMsg)
  if (!_internal_has_statusmsg()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = statusmsg_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (statusmsg_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    statusmsg_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonResponse::set_allocated_statusmsg(std::string* statusmsg) {
  if (statusmsg != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  statusmsg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), statusmsg,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (statusmsg_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    statusmsg_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonResponse.StatusMsg)
}

// repeated .google.protobuf.Any ResponseBody = 3;
inline int CommonResponse::_internal_responsebody_size() const {
  return responsebody_.size();
}
inline int CommonResponse::responsebody_size() const {
  return _internal_responsebody_size();
}
inline ::PROTOBUF_NAMESPACE_ID::Any* CommonResponse::mutable_responsebody(int index) {
  // @@protoc_insertion_point(field_mutable:CommonResponse.ResponseBody)
  return responsebody_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any >*
CommonResponse::mutable_responsebody() {
  // @@protoc_insertion_point(field_mutable_list:CommonResponse.ResponseBody)
  return &responsebody_;
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& CommonResponse::_internal_responsebody(int index) const {
  return responsebody_.Get(index);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& CommonResponse::responsebody(int index) const {
  // @@protoc_insertion_point(field_get:CommonResponse.ResponseBody)
  return _internal_responsebody(index);
}
inline ::PROTOBUF_NAMESPACE_ID::Any* CommonResponse::_internal_add_responsebody() {
  return responsebody_.Add();
}
inline ::PROTOBUF_NAMESPACE_ID::Any* CommonResponse::add_responsebody() {
  ::PROTOBUF_NAMESPACE_ID::Any* _add = _internal_add_responsebody();
  // @@protoc_insertion_point(field_add:CommonResponse.ResponseBody)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any >&
CommonResponse::responsebody() const {
  // @@protoc_insertion_point(field_list:CommonResponse.ResponseBody)
  return responsebody_;
}

// optional .QueryHeadInfo head = 4;
inline bool CommonResponse::_internal_has_head() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  PROTOBUF_ASSUME(!value || head_ != nullptr);
  return value;
}
inline bool CommonResponse::has_head() const {
  return _internal_has_head();
}
inline void CommonResponse::clear_head() {
  if (head_ != nullptr) head_->Clear();
  _has_bits_[0] &= ~0x00010000u;
}
inline const ::QueryHeadInfo& CommonResponse::_internal_head() const {
  const ::QueryHeadInfo* p = head_;
  return p != nullptr ? *p : reinterpret_cast<const ::QueryHeadInfo&>(
      ::_QueryHeadInfo_default_instance_);
}
inline const ::QueryHeadInfo& CommonResponse::head() const {
  // @@protoc_insertion_point(field_get:CommonResponse.head)
  return _internal_head();
}
inline void CommonResponse::unsafe_arena_set_allocated_head(
    ::QueryHeadInfo* head) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(head_);
  }
  head_ = head;
  if (head) {
    _has_bits_[0] |= 0x00010000u;
  } else {
    _has_bits_[0] &= ~0x00010000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CommonResponse.head)
}
inline ::QueryHeadInfo* CommonResponse::release_head() {
  _has_bits_[0] &= ~0x00010000u;
  ::QueryHeadInfo* temp = head_;
  head_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::QueryHeadInfo* CommonResponse::unsafe_arena_release_head() {
  // @@protoc_insertion_point(field_release:CommonResponse.head)
  _has_bits_[0] &= ~0x00010000u;
  ::QueryHeadInfo* temp = head_;
  head_ = nullptr;
  return temp;
}
inline ::QueryHeadInfo* CommonResponse::_internal_mutable_head() {
  _has_bits_[0] |= 0x00010000u;
  if (head_ == nullptr) {
    auto* p = CreateMaybeMessage<::QueryHeadInfo>(GetArenaForAllocation());
    head_ = p;
  }
  return head_;
}
inline ::QueryHeadInfo* CommonResponse::mutable_head() {
  ::QueryHeadInfo* _msg = _internal_mutable_head();
  // @@protoc_insertion_point(field_mutable:CommonResponse.head)
  return _msg;
}
inline void CommonResponse::set_allocated_head(::QueryHeadInfo* head) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete head_;
  }
  if (head) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::QueryHeadInfo>::GetOwningArena(head);
    if (message_arena != submessage_arena) {
      head = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, head, submessage_arena);
    }
    _has_bits_[0] |= 0x00010000u;
  } else {
    _has_bits_[0] &= ~0x00010000u;
  }
  head_ = head;
  // @@protoc_insertion_point(field_set_allocated:CommonResponse.head)
}

// optional .QueryResultInfo results = 5;
inline bool CommonResponse::_internal_has_results() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  PROTOBUF_ASSUME(!value || results_ != nullptr);
  return value;
}
inline bool CommonResponse::has_results() const {
  return _internal_has_results();
}
inline void CommonResponse::clear_results() {
  if (results_ != nullptr) results_->Clear();
  _has_bits_[0] &= ~0x00020000u;
}
inline const ::QueryResultInfo& CommonResponse::_internal_results() const {
  const ::QueryResultInfo* p = results_;
  return p != nullptr ? *p : reinterpret_cast<const ::QueryResultInfo&>(
      ::_QueryResultInfo_default_instance_);
}
inline const ::QueryResultInfo& CommonResponse::results() const {
  // @@protoc_insertion_point(field_get:CommonResponse.results)
  return _internal_results();
}
inline void CommonResponse::unsafe_arena_set_allocated_results(
    ::QueryResultInfo* results) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(results_);
  }
  results_ = results;
  if (results) {
    _has_bits_[0] |= 0x00020000u;
  } else {
    _has_bits_[0] &= ~0x00020000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CommonResponse.results)
}
inline ::QueryResultInfo* CommonResponse::release_results() {
  _has_bits_[0] &= ~0x00020000u;
  ::QueryResultInfo* temp = results_;
  results_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::QueryResultInfo* CommonResponse::unsafe_arena_release_results() {
  // @@protoc_insertion_point(field_release:CommonResponse.results)
  _has_bits_[0] &= ~0x00020000u;
  ::QueryResultInfo* temp = results_;
  results_ = nullptr;
  return temp;
}
inline ::QueryResultInfo* CommonResponse::_internal_mutable_results() {
  _has_bits_[0] |= 0x00020000u;
  if (results_ == nullptr) {
    auto* p = CreateMaybeMessage<::QueryResultInfo>(GetArenaForAllocation());
    results_ = p;
  }
  return results_;
}
inline ::QueryResultInfo* CommonResponse::mutable_results() {
  ::QueryResultInfo* _msg = _internal_mutable_results();
  // @@protoc_insertion_point(field_mutable:CommonResponse.results)
  return _msg;
}
inline void CommonResponse::set_allocated_results(::QueryResultInfo* results) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete results_;
  }
  if (results) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::QueryResultInfo>::GetOwningArena(results);
    if (message_arena != submessage_arena) {
      results = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, results, submessage_arena);
    }
    _has_bits_[0] |= 0x00020000u;
  } else {
    _has_bits_[0] &= ~0x00020000u;
  }
  results_ = results;
  // @@protoc_insertion_point(field_set_allocated:CommonResponse.results)
}

// optional int32 AnsNum = 6;
inline bool CommonResponse::_internal_has_ansnum() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool CommonResponse::has_ansnum() const {
  return _internal_has_ansnum();
}
inline void CommonResponse::clear_ansnum() {
  ansnum_ = 0;
  _has_bits_[0] &= ~0x00080000u;
}
inline int32_t CommonResponse::_internal_ansnum() const {
  return ansnum_;
}
inline int32_t CommonResponse::ansnum() const {
  // @@protoc_insertion_point(field_get:CommonResponse.AnsNum)
  return _internal_ansnum();
}
inline void CommonResponse::_internal_set_ansnum(int32_t value) {
  _has_bits_[0] |= 0x00080000u;
  ansnum_ = value;
}
inline void CommonResponse::set_ansnum(int32_t value) {
  _internal_set_ansnum(value);
  // @@protoc_insertion_point(field_set:CommonResponse.AnsNum)
}

// optional int32 OutputLimit = 7;
inline bool CommonResponse::_internal_has_outputlimit() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool CommonResponse::has_outputlimit() const {
  return _internal_has_outputlimit();
}
inline void CommonResponse::clear_outputlimit() {
  outputlimit_ = 0;
  _has_bits_[0] &= ~0x00100000u;
}
inline int32_t CommonResponse::_internal_outputlimit() const {
  return outputlimit_;
}
inline int32_t CommonResponse::outputlimit() const {
  // @@protoc_insertion_point(field_get:CommonResponse.OutputLimit)
  return _internal_outputlimit();
}
inline void CommonResponse::_internal_set_outputlimit(int32_t value) {
  _has_bits_[0] |= 0x00100000u;
  outputlimit_ = value;
}
inline void CommonResponse::set_outputlimit(int32_t value) {
  _internal_set_outputlimit(value);
  // @@protoc_insertion_point(field_set:CommonResponse.OutputLimit)
}

// optional string ThreadId = 8;
inline bool CommonResponse::_internal_has_threadid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommonResponse::has_threadid() const {
  return _internal_has_threadid();
}
inline void CommonResponse::clear_threadid() {
  threadid_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CommonResponse::threadid() const {
  // @@protoc_insertion_point(field_get:CommonResponse.ThreadId)
  return _internal_threadid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonResponse::set_threadid(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 threadid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonResponse.ThreadId)
}
inline std::string* CommonResponse::mutable_threadid() {
  std::string* _s = _internal_mutable_threadid();
  // @@protoc_insertion_point(field_mutable:CommonResponse.ThreadId)
  return _s;
}
inline const std::string& CommonResponse::_internal_threadid() const {
  return threadid_.Get();
}
inline void CommonResponse::_internal_set_threadid(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  threadid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonResponse::_internal_mutable_threadid() {
  _has_bits_[0] |= 0x00000002u;
  return threadid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonResponse::release_threadid() {
  // @@protoc_insertion_point(field_release:CommonResponse.ThreadId)
  if (!_internal_has_threadid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = threadid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (threadid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    threadid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonResponse::set_allocated_threadid(std::string* threadid) {
  if (threadid != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  threadid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), threadid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (threadid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    threadid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonResponse.ThreadId)
}

// optional string QueryTime = 9;
inline bool CommonResponse::_internal_has_querytime() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CommonResponse::has_querytime() const {
  return _internal_has_querytime();
}
inline void CommonResponse::clear_querytime() {
  querytime_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CommonResponse::querytime() const {
  // @@protoc_insertion_point(field_get:CommonResponse.QueryTime)
  return _internal_querytime();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonResponse::set_querytime(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 querytime_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonResponse.QueryTime)
}
inline std::string* CommonResponse::mutable_querytime() {
  std::string* _s = _internal_mutable_querytime();
  // @@protoc_insertion_point(field_mutable:CommonResponse.QueryTime)
  return _s;
}
inline const std::string& CommonResponse::_internal_querytime() const {
  return querytime_.Get();
}
inline void CommonResponse::_internal_set_querytime(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  querytime_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonResponse::_internal_mutable_querytime() {
  _has_bits_[0] |= 0x00000004u;
  return querytime_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonResponse::release_querytime() {
  // @@protoc_insertion_point(field_release:CommonResponse.QueryTime)
  if (!_internal_has_querytime()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = querytime_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (querytime_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    querytime_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonResponse::set_allocated_querytime(std::string* querytime) {
  if (querytime != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  querytime_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), querytime,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (querytime_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    querytime_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonResponse.QueryTime)
}

// optional string FileName = 10;
inline bool CommonResponse::_internal_has_filename() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CommonResponse::has_filename() const {
  return _internal_has_filename();
}
inline void CommonResponse::clear_filename() {
  filename_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CommonResponse::filename() const {
  // @@protoc_insertion_point(field_get:CommonResponse.FileName)
  return _internal_filename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonResponse::set_filename(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 filename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonResponse.FileName)
}
inline std::string* CommonResponse::mutable_filename() {
  std::string* _s = _internal_mutable_filename();
  // @@protoc_insertion_point(field_mutable:CommonResponse.FileName)
  return _s;
}
inline const std::string& CommonResponse::_internal_filename() const {
  return filename_.Get();
}
inline void CommonResponse::_internal_set_filename(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  filename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonResponse::_internal_mutable_filename() {
  _has_bits_[0] |= 0x00000008u;
  return filename_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonResponse::release_filename() {
  // @@protoc_insertion_point(field_release:CommonResponse.FileName)
  if (!_internal_has_filename()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = filename_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (filename_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    filename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonResponse::set_allocated_filename(std::string* filename) {
  if (filename != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  filename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), filename,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (filename_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    filename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonResponse.FileName)
}

// optional string filepath = 11;
inline bool CommonResponse::_internal_has_filepath() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CommonResponse::has_filepath() const {
  return _internal_has_filepath();
}
inline void CommonResponse::clear_filepath() {
  filepath_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& CommonResponse::filepath() const {
  // @@protoc_insertion_point(field_get:CommonResponse.filepath)
  return _internal_filepath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonResponse::set_filepath(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 filepath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonResponse.filepath)
}
inline std::string* CommonResponse::mutable_filepath() {
  std::string* _s = _internal_mutable_filepath();
  // @@protoc_insertion_point(field_mutable:CommonResponse.filepath)
  return _s;
}
inline const std::string& CommonResponse::_internal_filepath() const {
  return filepath_.Get();
}
inline void CommonResponse::_internal_set_filepath(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  filepath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonResponse::_internal_mutable_filepath() {
  _has_bits_[0] |= 0x00000010u;
  return filepath_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonResponse::release_filepath() {
  // @@protoc_insertion_point(field_release:CommonResponse.filepath)
  if (!_internal_has_filepath()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = filepath_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (filepath_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    filepath_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonResponse::set_allocated_filepath(std::string* filepath) {
  if (filepath != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  filepath_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), filepath,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (filepath_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    filepath_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonResponse.filepath)
}

// optional string TID = 12;
inline bool CommonResponse::_internal_has_tid() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CommonResponse::has_tid() const {
  return _internal_has_tid();
}
inline void CommonResponse::clear_tid() {
  tid_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& CommonResponse::tid() const {
  // @@protoc_insertion_point(field_get:CommonResponse.TID)
  return _internal_tid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonResponse::set_tid(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 tid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonResponse.TID)
}
inline std::string* CommonResponse::mutable_tid() {
  std::string* _s = _internal_mutable_tid();
  // @@protoc_insertion_point(field_mutable:CommonResponse.TID)
  return _s;
}
inline const std::string& CommonResponse::_internal_tid() const {
  return tid_.Get();
}
inline void CommonResponse::_internal_set_tid(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  tid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonResponse::_internal_mutable_tid() {
  _has_bits_[0] |= 0x00000020u;
  return tid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonResponse::release_tid() {
  // @@protoc_insertion_point(field_release:CommonResponse.TID)
  if (!_internal_has_tid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  auto* p = tid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    tid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonResponse::set_allocated_tid(std::string* tid) {
  if (tid != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  tid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    tid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonResponse.TID)
}

// repeated .google.protobuf.Any list = 13;
inline int CommonResponse::_internal_list_size() const {
  return list_.size();
}
inline int CommonResponse::list_size() const {
  return _internal_list_size();
}
inline ::PROTOBUF_NAMESPACE_ID::Any* CommonResponse::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:CommonResponse.list)
  return list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any >*
CommonResponse::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:CommonResponse.list)
  return &list_;
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& CommonResponse::_internal_list(int index) const {
  return list_.Get(index);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& CommonResponse::list(int index) const {
  // @@protoc_insertion_point(field_get:CommonResponse.list)
  return _internal_list(index);
}
inline ::PROTOBUF_NAMESPACE_ID::Any* CommonResponse::_internal_add_list() {
  return list_.Add();
}
inline ::PROTOBUF_NAMESPACE_ID::Any* CommonResponse::add_list() {
  ::PROTOBUF_NAMESPACE_ID::Any* _add = _internal_add_list();
  // @@protoc_insertion_point(field_add:CommonResponse.list)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any >&
CommonResponse::list() const {
  // @@protoc_insertion_point(field_list:CommonResponse.list)
  return list_;
}

// optional string CoreVersion = 14;
inline bool CommonResponse::_internal_has_coreversion() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CommonResponse::has_coreversion() const {
  return _internal_has_coreversion();
}
inline void CommonResponse::clear_coreversion() {
  coreversion_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& CommonResponse::coreversion() const {
  // @@protoc_insertion_point(field_get:CommonResponse.CoreVersion)
  return _internal_coreversion();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonResponse::set_coreversion(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000040u;
 coreversion_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonResponse.CoreVersion)
}
inline std::string* CommonResponse::mutable_coreversion() {
  std::string* _s = _internal_mutable_coreversion();
  // @@protoc_insertion_point(field_mutable:CommonResponse.CoreVersion)
  return _s;
}
inline const std::string& CommonResponse::_internal_coreversion() const {
  return coreversion_.Get();
}
inline void CommonResponse::_internal_set_coreversion(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  coreversion_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonResponse::_internal_mutable_coreversion() {
  _has_bits_[0] |= 0x00000040u;
  return coreversion_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonResponse::release_coreversion() {
  // @@protoc_insertion_point(field_release:CommonResponse.CoreVersion)
  if (!_internal_has_coreversion()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  auto* p = coreversion_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (coreversion_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    coreversion_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonResponse::set_allocated_coreversion(std::string* coreversion) {
  if (coreversion != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  coreversion_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), coreversion,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (coreversion_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    coreversion_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonResponse.CoreVersion)
}

// optional string licensetype = 15;
inline bool CommonResponse::_internal_has_licensetype() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CommonResponse::has_licensetype() const {
  return _internal_has_licensetype();
}
inline void CommonResponse::clear_licensetype() {
  licensetype_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000080u;
}
inline const std::string& CommonResponse::licensetype() const {
  // @@protoc_insertion_point(field_get:CommonResponse.licensetype)
  return _internal_licensetype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonResponse::set_licensetype(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000080u;
 licensetype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonResponse.licensetype)
}
inline std::string* CommonResponse::mutable_licensetype() {
  std::string* _s = _internal_mutable_licensetype();
  // @@protoc_insertion_point(field_mutable:CommonResponse.licensetype)
  return _s;
}
inline const std::string& CommonResponse::_internal_licensetype() const {
  return licensetype_.Get();
}
inline void CommonResponse::_internal_set_licensetype(const std::string& value) {
  _has_bits_[0] |= 0x00000080u;
  licensetype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonResponse::_internal_mutable_licensetype() {
  _has_bits_[0] |= 0x00000080u;
  return licensetype_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonResponse::release_licensetype() {
  // @@protoc_insertion_point(field_release:CommonResponse.licensetype)
  if (!_internal_has_licensetype()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000080u;
  auto* p = licensetype_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (licensetype_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    licensetype_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonResponse::set_allocated_licensetype(std::string* licensetype) {
  if (licensetype != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  licensetype_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), licensetype,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (licensetype_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    licensetype_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonResponse.licensetype)
}

// optional string RootPath = 16;
inline bool CommonResponse::_internal_has_rootpath() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CommonResponse::has_rootpath() const {
  return _internal_has_rootpath();
}
inline void CommonResponse::clear_rootpath() {
  rootpath_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000100u;
}
inline const std::string& CommonResponse::rootpath() const {
  // @@protoc_insertion_point(field_get:CommonResponse.RootPath)
  return _internal_rootpath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonResponse::set_rootpath(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000100u;
 rootpath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonResponse.RootPath)
}
inline std::string* CommonResponse::mutable_rootpath() {
  std::string* _s = _internal_mutable_rootpath();
  // @@protoc_insertion_point(field_mutable:CommonResponse.RootPath)
  return _s;
}
inline const std::string& CommonResponse::_internal_rootpath() const {
  return rootpath_.Get();
}
inline void CommonResponse::_internal_set_rootpath(const std::string& value) {
  _has_bits_[0] |= 0x00000100u;
  rootpath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonResponse::_internal_mutable_rootpath() {
  _has_bits_[0] |= 0x00000100u;
  return rootpath_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonResponse::release_rootpath() {
  // @@protoc_insertion_point(field_release:CommonResponse.RootPath)
  if (!_internal_has_rootpath()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000100u;
  auto* p = rootpath_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (rootpath_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    rootpath_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonResponse::set_allocated_rootpath(std::string* rootpath) {
  if (rootpath != nullptr) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  rootpath_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), rootpath,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (rootpath_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    rootpath_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonResponse.RootPath)
}

// optional string successNum = 17;
inline bool CommonResponse::_internal_has_successnum() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool CommonResponse::has_successnum() const {
  return _internal_has_successnum();
}
inline void CommonResponse::clear_successnum() {
  successnum_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000200u;
}
inline const std::string& CommonResponse::successnum() const {
  // @@protoc_insertion_point(field_get:CommonResponse.successNum)
  return _internal_successnum();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonResponse::set_successnum(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000200u;
 successnum_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonResponse.successNum)
}
inline std::string* CommonResponse::mutable_successnum() {
  std::string* _s = _internal_mutable_successnum();
  // @@protoc_insertion_point(field_mutable:CommonResponse.successNum)
  return _s;
}
inline const std::string& CommonResponse::_internal_successnum() const {
  return successnum_.Get();
}
inline void CommonResponse::_internal_set_successnum(const std::string& value) {
  _has_bits_[0] |= 0x00000200u;
  successnum_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonResponse::_internal_mutable_successnum() {
  _has_bits_[0] |= 0x00000200u;
  return successnum_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonResponse::release_successnum() {
  // @@protoc_insertion_point(field_release:CommonResponse.successNum)
  if (!_internal_has_successnum()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000200u;
  auto* p = successnum_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (successnum_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    successnum_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonResponse::set_allocated_successnum(std::string* successnum) {
  if (successnum != nullptr) {
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  successnum_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), successnum,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (successnum_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    successnum_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonResponse.successNum)
}

// optional int32 totalSize = 18;
inline bool CommonResponse::_internal_has_totalsize() const {
  bool value = (_has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool CommonResponse::has_totalsize() const {
  return _internal_has_totalsize();
}
inline void CommonResponse::clear_totalsize() {
  totalsize_ = 0;
  _has_bits_[0] &= ~0x00200000u;
}
inline int32_t CommonResponse::_internal_totalsize() const {
  return totalsize_;
}
inline int32_t CommonResponse::totalsize() const {
  // @@protoc_insertion_point(field_get:CommonResponse.totalSize)
  return _internal_totalsize();
}
inline void CommonResponse::_internal_set_totalsize(int32_t value) {
  _has_bits_[0] |= 0x00200000u;
  totalsize_ = value;
}
inline void CommonResponse::set_totalsize(int32_t value) {
  _internal_set_totalsize(value);
  // @@protoc_insertion_point(field_set:CommonResponse.totalSize)
}

// optional int32 totalPage = 19;
inline bool CommonResponse::_internal_has_totalpage() const {
  bool value = (_has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool CommonResponse::has_totalpage() const {
  return _internal_has_totalpage();
}
inline void CommonResponse::clear_totalpage() {
  totalpage_ = 0;
  _has_bits_[0] &= ~0x00400000u;
}
inline int32_t CommonResponse::_internal_totalpage() const {
  return totalpage_;
}
inline int32_t CommonResponse::totalpage() const {
  // @@protoc_insertion_point(field_get:CommonResponse.totalPage)
  return _internal_totalpage();
}
inline void CommonResponse::_internal_set_totalpage(int32_t value) {
  _has_bits_[0] |= 0x00400000u;
  totalpage_ = value;
}
inline void CommonResponse::set_totalpage(int32_t value) {
  _internal_set_totalpage(value);
  // @@protoc_insertion_point(field_set:CommonResponse.totalPage)
}

// optional int32 pageNo = 20;
inline bool CommonResponse::_internal_has_pageno() const {
  bool value = (_has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool CommonResponse::has_pageno() const {
  return _internal_has_pageno();
}
inline void CommonResponse::clear_pageno() {
  pageno_ = 0;
  _has_bits_[0] &= ~0x00800000u;
}
inline int32_t CommonResponse::_internal_pageno() const {
  return pageno_;
}
inline int32_t CommonResponse::pageno() const {
  // @@protoc_insertion_point(field_get:CommonResponse.pageNo)
  return _internal_pageno();
}
inline void CommonResponse::_internal_set_pageno(int32_t value) {
  _has_bits_[0] |= 0x00800000u;
  pageno_ = value;
}
inline void CommonResponse::set_pageno(int32_t value) {
  _internal_set_pageno(value);
  // @@protoc_insertion_point(field_set:CommonResponse.pageNo)
}

// optional int32 pageSize = 21;
inline bool CommonResponse::_internal_has_pagesize() const {
  bool value = (_has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline bool CommonResponse::has_pagesize() const {
  return _internal_has_pagesize();
}
inline void CommonResponse::clear_pagesize() {
  pagesize_ = 0;
  _has_bits_[0] &= ~0x01000000u;
}
inline int32_t CommonResponse::_internal_pagesize() const {
  return pagesize_;
}
inline int32_t CommonResponse::pagesize() const {
  // @@protoc_insertion_point(field_get:CommonResponse.pageSize)
  return _internal_pagesize();
}
inline void CommonResponse::_internal_set_pagesize(int32_t value) {
  _has_bits_[0] |= 0x01000000u;
  pagesize_ = value;
}
inline void CommonResponse::set_pagesize(int32_t value) {
  _internal_set_pagesize(value);
  // @@protoc_insertion_point(field_set:CommonResponse.pageSize)
}

// optional string backupfilepath = 22;
inline bool CommonResponse::_internal_has_backupfilepath() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool CommonResponse::has_backupfilepath() const {
  return _internal_has_backupfilepath();
}
inline void CommonResponse::clear_backupfilepath() {
  backupfilepath_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000400u;
}
inline const std::string& CommonResponse::backupfilepath() const {
  // @@protoc_insertion_point(field_get:CommonResponse.backupfilepath)
  return _internal_backupfilepath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonResponse::set_backupfilepath(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000400u;
 backupfilepath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonResponse.backupfilepath)
}
inline std::string* CommonResponse::mutable_backupfilepath() {
  std::string* _s = _internal_mutable_backupfilepath();
  // @@protoc_insertion_point(field_mutable:CommonResponse.backupfilepath)
  return _s;
}
inline const std::string& CommonResponse::_internal_backupfilepath() const {
  return backupfilepath_.Get();
}
inline void CommonResponse::_internal_set_backupfilepath(const std::string& value) {
  _has_bits_[0] |= 0x00000400u;
  backupfilepath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonResponse::_internal_mutable_backupfilepath() {
  _has_bits_[0] |= 0x00000400u;
  return backupfilepath_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonResponse::release_backupfilepath() {
  // @@protoc_insertion_point(field_release:CommonResponse.backupfilepath)
  if (!_internal_has_backupfilepath()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000400u;
  auto* p = backupfilepath_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (backupfilepath_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    backupfilepath_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonResponse::set_allocated_backupfilepath(std::string* backupfilepath) {
  if (backupfilepath != nullptr) {
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  backupfilepath_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), backupfilepath,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (backupfilepath_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    backupfilepath_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonResponse.backupfilepath)
}

// optional string Result = 23;
inline bool CommonResponse::_internal_has_result() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool CommonResponse::has_result() const {
  return _internal_has_result();
}
inline void CommonResponse::clear_result() {
  result_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000800u;
}
inline const std::string& CommonResponse::result() const {
  // @@protoc_insertion_point(field_get:CommonResponse.Result)
  return _internal_result();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonResponse::set_result(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000800u;
 result_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonResponse.Result)
}
inline std::string* CommonResponse::mutable_result() {
  std::string* _s = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:CommonResponse.Result)
  return _s;
}
inline const std::string& CommonResponse::_internal_result() const {
  return result_.Get();
}
inline void CommonResponse::_internal_set_result(const std::string& value) {
  _has_bits_[0] |= 0x00000800u;
  result_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonResponse::_internal_mutable_result() {
  _has_bits_[0] |= 0x00000800u;
  return result_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonResponse::release_result() {
  // @@protoc_insertion_point(field_release:CommonResponse.Result)
  if (!_internal_has_result()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000800u;
  auto* p = result_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (result_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    result_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonResponse::set_allocated_result(std::string* result) {
  if (result != nullptr) {
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  result_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), result,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (result_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    result_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonResponse.Result)
}

// optional string database = 24;
inline bool CommonResponse::_internal_has_database() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool CommonResponse::has_database() const {
  return _internal_has_database();
}
inline void CommonResponse::clear_database() {
  database_.ClearToEmpty();
  _has_bits_[0] &= ~0x00001000u;
}
inline const std::string& CommonResponse::database() const {
  // @@protoc_insertion_point(field_get:CommonResponse.database)
  return _internal_database();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonResponse::set_database(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00001000u;
 database_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonResponse.database)
}
inline std::string* CommonResponse::mutable_database() {
  std::string* _s = _internal_mutable_database();
  // @@protoc_insertion_point(field_mutable:CommonResponse.database)
  return _s;
}
inline const std::string& CommonResponse::_internal_database() const {
  return database_.Get();
}
inline void CommonResponse::_internal_set_database(const std::string& value) {
  _has_bits_[0] |= 0x00001000u;
  database_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonResponse::_internal_mutable_database() {
  _has_bits_[0] |= 0x00001000u;
  return database_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonResponse::release_database() {
  // @@protoc_insertion_point(field_release:CommonResponse.database)
  if (!_internal_has_database()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00001000u;
  auto* p = database_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (database_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    database_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonResponse::set_allocated_database(std::string* database) {
  if (database != nullptr) {
    _has_bits_[0] |= 0x00001000u;
  } else {
    _has_bits_[0] &= ~0x00001000u;
  }
  database_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), database,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (database_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    database_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonResponse.database)
}

// optional string creator = 25;
inline bool CommonResponse::_internal_has_creator() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool CommonResponse::has_creator() const {
  return _internal_has_creator();
}
inline void CommonResponse::clear_creator() {
  creator_.ClearToEmpty();
  _has_bits_[0] &= ~0x00002000u;
}
inline const std::string& CommonResponse::creator() const {
  // @@protoc_insertion_point(field_get:CommonResponse.creator)
  return _internal_creator();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonResponse::set_creator(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00002000u;
 creator_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonResponse.creator)
}
inline std::string* CommonResponse::mutable_creator() {
  std::string* _s = _internal_mutable_creator();
  // @@protoc_insertion_point(field_mutable:CommonResponse.creator)
  return _s;
}
inline const std::string& CommonResponse::_internal_creator() const {
  return creator_.Get();
}
inline void CommonResponse::_internal_set_creator(const std::string& value) {
  _has_bits_[0] |= 0x00002000u;
  creator_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonResponse::_internal_mutable_creator() {
  _has_bits_[0] |= 0x00002000u;
  return creator_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonResponse::release_creator() {
  // @@protoc_insertion_point(field_release:CommonResponse.creator)
  if (!_internal_has_creator()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00002000u;
  auto* p = creator_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (creator_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    creator_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonResponse::set_allocated_creator(std::string* creator) {
  if (creator != nullptr) {
    _has_bits_[0] |= 0x00002000u;
  } else {
    _has_bits_[0] &= ~0x00002000u;
  }
  creator_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), creator,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (creator_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    creator_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonResponse.creator)
}

// optional string builtTime = 26;
inline bool CommonResponse::_internal_has_builttime() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool CommonResponse::has_builttime() const {
  return _internal_has_builttime();
}
inline void CommonResponse::clear_builttime() {
  builttime_.ClearToEmpty();
  _has_bits_[0] &= ~0x00004000u;
}
inline const std::string& CommonResponse::builttime() const {
  // @@protoc_insertion_point(field_get:CommonResponse.builtTime)
  return _internal_builttime();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonResponse::set_builttime(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00004000u;
 builttime_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonResponse.builtTime)
}
inline std::string* CommonResponse::mutable_builttime() {
  std::string* _s = _internal_mutable_builttime();
  // @@protoc_insertion_point(field_mutable:CommonResponse.builtTime)
  return _s;
}
inline const std::string& CommonResponse::_internal_builttime() const {
  return builttime_.Get();
}
inline void CommonResponse::_internal_set_builttime(const std::string& value) {
  _has_bits_[0] |= 0x00004000u;
  builttime_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonResponse::_internal_mutable_builttime() {
  _has_bits_[0] |= 0x00004000u;
  return builttime_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonResponse::release_builttime() {
  // @@protoc_insertion_point(field_release:CommonResponse.builtTime)
  if (!_internal_has_builttime()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00004000u;
  auto* p = builttime_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (builttime_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    builttime_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonResponse::set_allocated_builttime(std::string* builttime) {
  if (builttime != nullptr) {
    _has_bits_[0] |= 0x00004000u;
  } else {
    _has_bits_[0] &= ~0x00004000u;
  }
  builttime_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), builttime,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (builttime_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    builttime_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonResponse.builtTime)
}

// optional string tripleNum = 27;
inline bool CommonResponse::_internal_has_triplenum() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool CommonResponse::has_triplenum() const {
  return _internal_has_triplenum();
}
inline void CommonResponse::clear_triplenum() {
  triplenum_.ClearToEmpty();
  _has_bits_[0] &= ~0x00008000u;
}
inline const std::string& CommonResponse::triplenum() const {
  // @@protoc_insertion_point(field_get:CommonResponse.tripleNum)
  return _internal_triplenum();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonResponse::set_triplenum(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00008000u;
 triplenum_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CommonResponse.tripleNum)
}
inline std::string* CommonResponse::mutable_triplenum() {
  std::string* _s = _internal_mutable_triplenum();
  // @@protoc_insertion_point(field_mutable:CommonResponse.tripleNum)
  return _s;
}
inline const std::string& CommonResponse::_internal_triplenum() const {
  return triplenum_.Get();
}
inline void CommonResponse::_internal_set_triplenum(const std::string& value) {
  _has_bits_[0] |= 0x00008000u;
  triplenum_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonResponse::_internal_mutable_triplenum() {
  _has_bits_[0] |= 0x00008000u;
  return triplenum_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonResponse::release_triplenum() {
  // @@protoc_insertion_point(field_release:CommonResponse.tripleNum)
  if (!_internal_has_triplenum()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00008000u;
  auto* p = triplenum_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (triplenum_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    triplenum_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommonResponse::set_allocated_triplenum(std::string* triplenum) {
  if (triplenum != nullptr) {
    _has_bits_[0] |= 0x00008000u;
  } else {
    _has_bits_[0] &= ~0x00008000u;
  }
  triplenum_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), triplenum,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (triplenum_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    triplenum_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CommonResponse.tripleNum)
}

// optional int32 entityNum = 28;
inline bool CommonResponse::_internal_has_entitynum() const {
  bool value = (_has_bits_[0] & 0x02000000u) != 0;
  return value;
}
inline bool CommonResponse::has_entitynum() const {
  return _internal_has_entitynum();
}
inline void CommonResponse::clear_entitynum() {
  entitynum_ = 0;
  _has_bits_[0] &= ~0x02000000u;
}
inline int32_t CommonResponse::_internal_entitynum() const {
  return entitynum_;
}
inline int32_t CommonResponse::entitynum() const {
  // @@protoc_insertion_point(field_get:CommonResponse.entityNum)
  return _internal_entitynum();
}
inline void CommonResponse::_internal_set_entitynum(int32_t value) {
  _has_bits_[0] |= 0x02000000u;
  entitynum_ = value;
}
inline void CommonResponse::set_entitynum(int32_t value) {
  _internal_set_entitynum(value);
  // @@protoc_insertion_point(field_set:CommonResponse.entityNum)
}

// optional int32 literalNum = 29;
inline bool CommonResponse::_internal_has_literalnum() const {
  bool value = (_has_bits_[0] & 0x04000000u) != 0;
  return value;
}
inline bool CommonResponse::has_literalnum() const {
  return _internal_has_literalnum();
}
inline void CommonResponse::clear_literalnum() {
  literalnum_ = 0;
  _has_bits_[0] &= ~0x04000000u;
}
inline int32_t CommonResponse::_internal_literalnum() const {
  return literalnum_;
}
inline int32_t CommonResponse::literalnum() const {
  // @@protoc_insertion_point(field_get:CommonResponse.literalNum)
  return _internal_literalnum();
}
inline void CommonResponse::_internal_set_literalnum(int32_t value) {
  _has_bits_[0] |= 0x04000000u;
  literalnum_ = value;
}
inline void CommonResponse::set_literalnum(int32_t value) {
  _internal_set_literalnum(value);
  // @@protoc_insertion_point(field_set:CommonResponse.literalNum)
}

// optional int32 subjectNum = 30;
inline bool CommonResponse::_internal_has_subjectnum() const {
  bool value = (_has_bits_[0] & 0x08000000u) != 0;
  return value;
}
inline bool CommonResponse::has_subjectnum() const {
  return _internal_has_subjectnum();
}
inline void CommonResponse::clear_subjectnum() {
  subjectnum_ = 0;
  _has_bits_[0] &= ~0x08000000u;
}
inline int32_t CommonResponse::_internal_subjectnum() const {
  return subjectnum_;
}
inline int32_t CommonResponse::subjectnum() const {
  // @@protoc_insertion_point(field_get:CommonResponse.subjectNum)
  return _internal_subjectnum();
}
inline void CommonResponse::_internal_set_subjectnum(int32_t value) {
  _has_bits_[0] |= 0x08000000u;
  subjectnum_ = value;
}
inline void CommonResponse::set_subjectnum(int32_t value) {
  _internal_set_subjectnum(value);
  // @@protoc_insertion_point(field_set:CommonResponse.subjectNum)
}

// optional int32 predicateNum = 31;
inline bool CommonResponse::_internal_has_predicatenum() const {
  bool value = (_has_bits_[0] & 0x10000000u) != 0;
  return value;
}
inline bool CommonResponse::has_predicatenum() const {
  return _internal_has_predicatenum();
}
inline void CommonResponse::clear_predicatenum() {
  predicatenum_ = 0;
  _has_bits_[0] &= ~0x10000000u;
}
inline int32_t CommonResponse::_internal_predicatenum() const {
  return predicatenum_;
}
inline int32_t CommonResponse::predicatenum() const {
  // @@protoc_insertion_point(field_get:CommonResponse.predicateNum)
  return _internal_predicatenum();
}
inline void CommonResponse::_internal_set_predicatenum(int32_t value) {
  _has_bits_[0] |= 0x10000000u;
  predicatenum_ = value;
}
inline void CommonResponse::set_predicatenum(int32_t value) {
  _internal_set_predicatenum(value);
  // @@protoc_insertion_point(field_set:CommonResponse.predicateNum)
}

// optional int32 connectionNum = 32;
inline bool CommonResponse::_internal_has_connectionnum() const {
  bool value = (_has_bits_[0] & 0x20000000u) != 0;
  return value;
}
inline bool CommonResponse::has_connectionnum() const {
  return _internal_has_connectionnum();
}
inline void CommonResponse::clear_connectionnum() {
  connectionnum_ = 0;
  _has_bits_[0] &= ~0x20000000u;
}
inline int32_t CommonResponse::_internal_connectionnum() const {
  return connectionnum_;
}
inline int32_t CommonResponse::connectionnum() const {
  // @@protoc_insertion_point(field_get:CommonResponse.connectionNum)
  return _internal_connectionnum();
}
inline void CommonResponse::_internal_set_connectionnum(int32_t value) {
  _has_bits_[0] |= 0x20000000u;
  connectionnum_ = value;
}
inline void CommonResponse::set_connectionnum(int32_t value) {
  _internal_set_connectionnum(value);
  // @@protoc_insertion_point(field_set:CommonResponse.connectionNum)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_grpc_2eproto
